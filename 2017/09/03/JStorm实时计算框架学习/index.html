<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java、分布式、大数据、微服务、机器学习"><title>JStorm实时计算框架学习 | Coselding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JStorm实时计算框架学习</h1><a id="logo" href="/.">Coselding</a><p class="description">非淡泊无以明志，非宁静无以致远。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/timeline/"><i class="fa fa-hourglass-start"> 时间轴</i></a><a href="/old/"><i class="fa fa-link"> 以前</i></a><a href="/about/"><i class="fa fa-user"> 关于我</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JStorm实时计算框架学习</h1><div class="post-meta">Sep 3, 2017<span> | </span><span class="category"><a href="/categories/实时计算/">实时计算</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a href="/2017/09/03/JStorm实时计算框架学习/#comments" class="ds-thread-count cloud-tie-join-count"><span style="font-size: 15px; color: #6E7173;" class="join-count">0</span><span> 条参与</span></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一些关键概念"><span class="toc-number">1.1.</span> <span class="toc-text">一些关键概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#生命周期"><span class="toc-number">2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Topology生命周期"><span class="toc-number">2.1.</span> <span class="toc-text">Topology生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spout生命周期"><span class="toc-number">2.2.</span> <span class="toc-text">Spout生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#提交时"><span class="toc-number">2.2.1.</span> <span class="toc-text">提交时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在Worker节点中执行"><span class="toc-number">2.2.2.</span> <span class="toc-text">在Worker节点中执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bolt生命周期"><span class="toc-number">2.3.</span> <span class="toc-text">Bolt生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#提交时-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">提交时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在Worker节点中执行-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">在Worker节点中执行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据流向控制"><span class="toc-number">3.</span> <span class="toc-text">数据流向控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据流传输过程"><span class="toc-number">4.</span> <span class="toc-text">数据流传输过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编程例子讲解"><span class="toc-number">5.</span> <span class="toc-text">编程例子讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RandomSentenceSpout"><span class="toc-number">5.1.</span> <span class="toc-text">RandomSentenceSpout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SplitBolt"><span class="toc-number">5.2.</span> <span class="toc-text">SplitBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountBolt"><span class="toc-number">5.3.</span> <span class="toc-text">CountBolt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WordCountTopology主入口，拓扑构建"><span class="toc-number">5.4.</span> <span class="toc-text">WordCountTopology主入口，拓扑构建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#批量用法"><span class="toc-number">6.</span> <span class="toc-text">批量用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ack机制"><span class="toc-number">7.</span> <span class="toc-text">Ack机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JStorm事务"><span class="toc-number">8.</span> <span class="toc-text">JStorm事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trident"><span class="toc-number">9.</span> <span class="toc-text">Trident</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#故障恢复"><span class="toc-number">10.</span> <span class="toc-text">故障恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JStorm使用感受"><span class="toc-number">11.</span> <span class="toc-text">JStorm使用感受</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">12.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><blockquote>
<ul>
<li>这是一个JStorm使用教程，不包含环境搭建教程，直接在公司现有集群上跑任务，关于JStorm集群环境搭建，后续研究完会考虑额外写一篇博客。</li>
<li>你如果想了解JStorm是什么，有多牛逼什么什么的，请看最后的参考博客链接，里面有各种版本的介绍，我就不在这里总结这种东西了，我相信这些东西你第一次接触的时候会看，等学了JStorm之后也不会再去看这些东西了。。。</li>
</ul>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JStorm和MapReduce的一些对比<br><img src="/2017/09/03/JStorm实时计算框架学习/compare-table.png" alt="compare-table.png"></li>
</ul>
<h3 id="一些关键概念"><a href="#一些关键概念" class="headerlink" title="一些关键概念"></a>一些关键概念</h3><ol>
<li>nimbus：主控节点运行Nimbus守护进程，类似于Hadoop中的ResourceManager，负责在集群中分发代码，对节点分配任务，并监视主机故障。</li>
<li>supervisor：每个工作节点运行Supervisor守护进程，负责监听工作节点上已经分配的主机作业，启动和停止Nimbus已经分配的工作进程，类似于Hadoop中的NodeManager。<br>supervisor会定时从zookeeper获取拓补信息topologies、任务分配信息assignments及各类心跳信息，以此为依据进行任务分配。<br>在supervisor同步时，会根据新的任务分配情况来启动新的worker或者关闭旧的worker并进行负载均衡。</li>
<li>worker：Worker是具体处理Spout/Bolt逻辑的进程，根据提交的拓扑中conf.setNumWorkers(3);定义分配每个拓扑对应的worker数量，Storm会在每个Worker上均匀分配任务，一个Worker只能执行一个topology，但是可以执行其中的多个任务线程。</li>
<li>task：任务是指Worker中每个Spout/Bolt线程，每个Spout和Bolt在集群中会执行许多任务，每个任务对应一个线程执行，可以通过TopologyBuilder类的setSpout()和setBolt()方法来设置每个Spout或者Bolt的并行度。</li>
<li>Executor：Task接收到任务就是在Executor中执行的，可以理解为执行Task专门的一个线程。</li>
<li>topology：Storm中Topology的概念类似于Hadoop中的MapReduce Job，是一个用来编排、容纳一组计算逻辑组件（Spout、Bolt）的对象（Hadoop MapReduce中一个Job包含一组Map Task、Reduce Task），这一组计算组件可以按照DAG图的方式编排起来（通过选择Stream Groupings来控制数据流分发流向），从而组合成一个计算逻辑更加负责的对象，那就是Topology。一个Topology运行以后就不能停止，它会无限地运行下去，除非手动干预（显式执行bin/storm kill ）或意外故障（如停机、整个Storm集群挂掉）让它终止。</li>
<li>spout：Storm中Spout是一个Topology的消息生产的源头，Spout应该是一个持续不断生产消息的组件，例如，它可以是一个Socket Server在监听外部Client连接并发送消息，可以是一个消息队列（MQ）的消费者、可以是用来接收Flume Agent的Sink所发送消息的服务，等等。Spout生产的消息在Storm中被抽象为Tuple，在整个Topology的多个计算组件之间都是根据需要抽象构建的Tuple消息来进行连接，从而形成流。</li>
<li>bolt：Storm中消息的处理逻辑被封装到Bolt组件中，任何处理逻辑都可以在Bolt里面执行，处理过程和普通计算应用程序没什么区别，只是需要根据Storm的计算语义来合理设置一下组件之间消息流的声明、分发、连接即可。Bolt可以接收来自一个或多个Spout的Tuple消息，也可以来自多个其它Bolt的Tuple消息，也可能是Spout和其它Bolt组合发送的Tuple消息。</li>
<li>tuple：JStorm中信息传输的单位，Storm程序是无限执行下去的，数据流是无止境的，但是每次驱动程序执行的只是一个数据流单位，就是Tuple，Spout的一次nextTuple以及Bolt的一次execute的执行操作的都是一个Tuple。Tuple只要是任意可序列化对象即可。</li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Topology生命周期"><a href="#Topology生命周期" class="headerlink" title="Topology生命周期"></a>Topology生命周期</h3><ol>
<li>上传代码并做校验（/nimbus/inbox）；</li>
<li>建立本地目录（/stormdist/topology-id/）；</li>
<li>建立zookeeper上的心跳目录；</li>
<li>计算topology的工作量（parallelism hint），分配task-id并写入zookeeper；</li>
<li>把task分配给supervisor执行；</li>
<li>在supervisor中定时检查是否有新的task，下载新代码、删除老代码，剩下的工作交个小弟worker；</li>
<li>在worker中把task拿到，看里面有哪些spout/Bolt，然后计算需要给哪些task发消息并建立连接；</li>
<li>在nimbus将topology终止的时候会将zookeeper上的相关信息删除；<br><img src="/2017/09/03/JStorm实时计算框架学习/topology-lifecycle.png" alt="topology-lifecycle.png"></li>
</ol>
<h3 id="Spout生命周期"><a href="#Spout生命周期" class="headerlink" title="Spout生命周期"></a>Spout生命周期</h3><h4 id="提交时"><a href="#提交时" class="headerlink" title="提交时"></a>提交时</h4><ol>
<li>构造方法：初始化构造参数，其中包含的必须都是可序列化的</li>
<li>getComponentConfiguration：获取该类特殊的配置参数，只和该组件相关的配置，通常<code>return null</code></li>
<li>declareOutputFields：获取该组件会输出的流、字段列表，其后续的其他组件订阅相应的流或者字段需要和这里对应，否则会出错</li>
<li>将内存中的该实例序列化为字节码文件。</li>
</ol>
<h4 id="在Worker节点中执行"><a href="#在Worker节点中执行" class="headerlink" title="在Worker节点中执行"></a>在Worker节点中执行</h4><ol>
<li>将传输过来的字节码文件反序列化为类实例</li>
<li>open：初始化这个组件类实例，可以加载消息队列消费端、JDBC链接池等非可序列化对象</li>
<li>activate：该实例设置为活跃状态（有数据流驱动时）调用，过段时间暂时没有数据流驱动就会睡眠</li>
<li>nextTuple：循环调用，可在这里从数据源获取数据emit到下一个节点，JStorm就会自动循环调用执行下去</li>
<li>ack：往后emit的一个Tuple在acker节点察觉成功了，回调通知Spout</li>
<li>fail：往后emit的一个Tuple在acker节点察觉失败或者超时了，回调通知Spout</li>
<li>deactivate：没数据流驱动达到一段时间，进入睡眠前调用</li>
<li>close：程序停止时调用，释放资源</li>
</ol>
<h3 id="Bolt生命周期"><a href="#Bolt生命周期" class="headerlink" title="Bolt生命周期"></a>Bolt生命周期</h3><h4 id="提交时-1"><a href="#提交时-1" class="headerlink" title="提交时"></a>提交时</h4><ol>
<li>构造方法：初始化构造参数，其中包含的必须都是可序列化的</li>
<li>getComponentConfiguration：获取该类特殊的配置参数，只和该组件相关的配置，通常<code>return null</code></li>
<li>declareOutputFields：获取该组件会输出的流、字段列表，其后续的其他组件订阅相应的流或者字段需要和这里对应，否则会出错</li>
<li>将内存中的该实例序列化为字节码文件。</li>
</ol>
<h4 id="在Worker节点中执行-1"><a href="#在Worker节点中执行-1" class="headerlink" title="在Worker节点中执行"></a>在Worker节点中执行</h4><ol>
<li>将传输过来的字节码文件反序列化为类实例</li>
<li>prepare：初始化这个组件类实例，可以加载配置，数据处理类初始化，数据输出对象初始化</li>
<li>execute：循环调用，可在这里从上个节点获取Tuple，进行相应处理之后emit到下一个节点，JStorm就会自动循环调用执行下去</li>
<li>cleanup：程序停止时调用，释放资源</li>
</ol>
<h2 id="数据流向控制"><a href="#数据流向控制" class="headerlink" title="数据流向控制"></a>数据流向控制</h2><p><img src="/2017/09/03/JStorm实时计算框架学习/jstorm-grouping.png" alt="jstorm-grouping.png"></p>
<ol>
<li>ShuffleGrouping：对符合条件的目标Worker，其中可能的多个Task，随机分配Task来接收和处理该Tuple</li>
<li>FieldsGrouping：会按照指定的field值进行分配，可以保证相同field对应值的Tuple分配到相同一个Task中执行 —— 可以想象成拿指定的field的值hash取模决定哪个Task（具体算法没研究）</li>
<li>除了这两个其他暂时没用到，也感觉剩下的比较用不到，等用了再更</li>
<li>具体的流的聚合和分发，参考这篇博客，例子很详细：<a href="http://shiyanjun.cn/archives/977.html" target="_blank" rel="external">JStorm流的汇聚和分发</a></li>
</ol>
<h2 id="数据流传输过程"><a href="#数据流传输过程" class="headerlink" title="数据流传输过程"></a>数据流传输过程</h2><ol>
<li>Spout中的数据源取出一份数据（无限循环取出），作为一个Tuple，emit到下一个节点</li>
<li>根据Spout中declareOutputFields定义的字段和流，查阅后继订阅该节点或者流的Bolt，Tuple会被发送到每个订阅节点或者流的后继节点当中</li>
<li>后继订阅的Bolt节点接收到该Tuple，使用<code>tuple.getValueByField</code>通过上一节点declareOutputFields的字段名获取相应的字段值，也可以根据fields的声明顺序使用<code>tuple.getValue</code>通过下标获取相应的值</li>
<li>拿到相应的数据之后，进行相关逻辑处理，之后emit到下一个节点当中，以此类推，直到最终节点将数据输出到mysql、ES、HDFS等存储系统当中</li>
<li>emit时可以指定相应的streamId来指定当前的数据要传输到的哪个streamId当中（该组件的declareOutputFields需要声明所需的所有streamId），在Topology构建时后继节点指定该streamId来订阅相应的数据。</li>
</ol>
<h2 id="编程例子讲解"><a href="#编程例子讲解" class="headerlink" title="编程例子讲解"></a>编程例子讲解</h2><ul>
<li>这个例子是一个单词计数程序，通过一组字符串数组中随机获取一个档次作为数据源往后输出，在后续节点统计各个单词被获取的总次数。</li>
<li>包括RandomSentenceSpout、SplitBolt、CountBolt三个节点，各个节点并行度都为1，是一个最简单的单条链式的拓扑，如下<br><img src="/2017/09/03/JStorm实时计算框架学习/jstorm-example.jpg" alt="jstorm-example.jpg"></li>
</ul>
<h3 id="RandomSentenceSpout"><a href="#RandomSentenceSpout" class="headerlink" title="RandomSentenceSpout"></a>RandomSentenceSpout</h3><ul>
<li>表示数据源，这里用从数组随机获取一个元素作为模拟数据源获取，日常开发通常是从MQ中获取相应数据进行数据流驱动。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * RandomSentenceSpout实现了IRichSpout接口</div><div class="line"> * Spout需要实现的接口可以是：</div><div class="line"> *    1,IRichSpout：最基本的Spout,继承自ISpout, IComponent,沒有任何特殊方法（一般用这个）</div><div class="line"> *    2,IControlSpout:继承自IComponent,包括open，close，activate，deactivate，nextTuple，ack(Object msgId)，fail等方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomSentenceSpout</span> <span class="keyword">implements</span> <span class="title">IRichSpout</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4058847280819269954L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(RandomSentenceSpout.class);</div><div class="line">    <span class="comment">//可以理解为JStorm的数据传输管道，通过这个对象将这个组件的数据传输到下一个组件当中</span></div><div class="line">    <span class="keyword">private</span> SpoutOutputCollector _collector;</div><div class="line">    <span class="comment">//随机生成对象</span></div><div class="line">    <span class="keyword">private</span> Random _rand;</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Spout初始化的时候调用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span> </span>&#123;</div><div class="line">        _collector = collector;</div><div class="line">        _rand = <span class="keyword">new</span> Random();</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 系统框架会不断调用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//模拟数据源</span></div><div class="line">        String[] sentences = <span class="keyword">new</span> String[]&#123;<span class="string">"Hello world! This is my first programme of JStorm"</span>,</div><div class="line">                <span class="string">"Hello JStorm,Nice to meet you!"</span>, <span class="string">"Hi JStorm, do you have a really good proformance"</span>,</div><div class="line">                <span class="string">"Goodbye JStorm,see you tomorrow"</span>&#125;;</div><div class="line">        <span class="comment">//随机取出字符串</span></div><div class="line">        String sentence = sentences[_rand.nextInt(sentences.length)];</div><div class="line">        <span class="comment">//将得到的字符串输出到下一个组件</span></div><div class="line">        <span class="comment">//！！！这里Values中值填充顺序要和下面declareOutputFields中字段声明顺序一致</span></div><div class="line">        _collector.emit(<span class="keyword">new</span> Values(sentence), Time.currentTimeSecs());</div><div class="line">        Utils.sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object arg0)</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"ACK!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"ACTIVE!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object arg0)</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"FAILED!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 声明框架有哪些输出的字段</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        <span class="comment">//下一个组件通过word这个关键字拿到这个组件往后输出的单词sentence</span></div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SplitBolt"><a href="#SplitBolt" class="headerlink" title="SplitBolt"></a>SplitBolt</h3><ul>
<li>将获取的字符串通过空白符分割，并转为小写之后输出到下一个节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * IBasicBolt:继承自IComponent,包括prepare,execut,cleanup等方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7104767103420386784L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(SplitBolt.class);</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * cleanup方法在bolt被关闭的时候调用， 它应该清理所有被打开的资源。（基本只能在local mode使用）</div><div class="line">     * 但是集群不保证这个方法一定会被执行。比如执行task的机器down掉了，那么根本就没有办法来调用那个方法。</div><div class="line">     * cleanup设计的时候是被用来在local mode的时候才被调用(也就是说在一个进程里面模拟整个storm集群),</div><div class="line">     * 并且你想在关闭一些topology的时候避免资源泄漏。</div><div class="line">     * （非 Javadoc）</div><div class="line">     * <span class="doctag">@see</span> backtype.storm.topology.base.BaseBasicBolt#cleanup()</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接收消息之后被调用的方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line">        <span class="comment">//以下两个方式获取前驱节点发送过来的sentence，一个根据fieldName，一个根据字段声明顺序</span></div><div class="line"><span class="comment">//        String sentence = input.getValueByField("word");</span></div><div class="line">        String sentence = input.getString(<span class="number">0</span>);</div><div class="line">        String[] words = sentence.split(<span class="string">"[,|\\s+]"</span>);</div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            word = word.trim();</div><div class="line">            <span class="comment">//将非空单词输出到下一个节点</span></div><div class="line">            <span class="keyword">if</span> (!word.isEmpty()) &#123;</div><div class="line">                word = word.toLowerCase();</div><div class="line">                collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * prepare方法在worker初始化task的时候调用.</div><div class="line">     *</div><div class="line">     * prepare方法提供给bolt一个Outputcollector用来发射tuple。</div><div class="line">     * Bolt可以在任何时候发射tuple — 在prepare, execute或者cleanup方法里面, 或者甚至在另一个线程里面异步发射。</div><div class="line">     * 这里prepare方法只是简单地把OutputCollector作为一个类字段保存下来给后面execute方法 使用。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stromConf, TopologyContext context)</span> </span>&#123;</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * declearOutputFields方法仅在有新的topology提交到服务器,</div><div class="line">     * 用来决定输出内容流的格式(相当于定义spout/bolt之间传输stream的name:value格式),</div><div class="line">     * 在topology执行的过程中并不会被调用.</div><div class="line">     * （非 Javadoc）</div><div class="line">     * <span class="doctag">@see</span> backtype.storm.topology.IComponent#declareOutputFields(backtype.storm.topology.OutputFieldsDeclarer)</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CountBolt"><a href="#CountBolt" class="headerlink" title="CountBolt"></a>CountBolt</h3><ul>
<li>这个组件接收到的每个值都是单个单词，通过一个内存Map统计各个单词总数</li>
<li>后台设置一个异步线程10s一次输出当前Map中的各个单词总数</li>
<li>日常开发通常在这个终端节点将实时计算得到的结果输出到HDFS、mysql、HBase、ElasticSearch等存储系统当中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; counters;</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = Logger.getLogger(CountBolt.class);</div><div class="line">    <span class="comment">//异步输出结果集的子线程</span></div><div class="line">    <span class="keyword">private</span> AsyncLoopThread statThread;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * On create</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.counters = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line">        <span class="keyword">this</span>.name = context.getThisComponentId();</div><div class="line">        <span class="keyword">this</span>.id = context.getThisTaskId();</div><div class="line">        <span class="comment">//异步循环输出结果集</span></div><div class="line">        <span class="keyword">this</span>.statThread = <span class="keyword">new</span> AsyncLoopThread(<span class="keyword">new</span> statRunnable());</div><div class="line"></div><div class="line">        LOG.info(stormConf.get(<span class="string">"abc"</span>) + <span class="string">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span>);</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"count"</span>));</div><div class="line">        <span class="comment">// declarer.declareStream("coord-"+"word-counter", new Fields("epoch","ebagNum"));</span></div><div class="line">        <span class="comment">// LOG.info("set stream coord-"+component);</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接收消息之后被调用的方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line"><span class="comment">//        String str = input.getString(0);</span></div><div class="line">        String str = input.getStringByField(<span class="string">"word"</span>);</div><div class="line">        <span class="keyword">if</span> (!counters.containsKey(str)) &#123;</div><div class="line">            <span class="comment">//单词计数</span></div><div class="line">            counters.put(str, <span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//单词计数</span></div><div class="line">            Integer c = counters.get(str) + <span class="number">1</span>;</div><div class="line">            counters.put(str, c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异步输出结果集的死循环子线程</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">statRunnable</span> <span class="keyword">extends</span> <span class="title">RunnableCallback</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">10000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                LOG.info(<span class="string">"\n-- Word Counter ["</span> + name + <span class="string">"-"</span> + id + <span class="string">"] --"</span>);</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : counters.entrySet()) &#123;</div><div class="line">                    LOG.info(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">                &#125;</div><div class="line">                LOG.info(<span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="WordCountTopology主入口，拓扑构建"><a href="#WordCountTopology主入口，拓扑构建" class="headerlink" title="WordCountTopology主入口，拓扑构建"></a>WordCountTopology主入口，拓扑构建</h3><ul>
<li>这里通过setSpout和setBolt将上面的三个节点连接成线 —— 即最开始说明的链式拓扑图</li>
<li>JStorm提交执行相关执行参数统一写入一个Properties或Yaml配置文件中，命令行执行第一个参数是该配置文件的路径<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountTopology</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOG = LoggerFactory.getLogger(WordCountTopology.class);</div><div class="line"></div><div class="line">    <span class="comment">//装载配置文件配置参数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map conf = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</div><div class="line">            System.err.println(<span class="string">"Please input configuration file"</span>);</div><div class="line">            System.exit(-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//加载配置文件配置到内存</span></div><div class="line">        LoadConf(args[<span class="number">0</span>]);</div><div class="line">        <span class="comment">//构建JStorm拓扑</span></div><div class="line">        TopologyBuilder builder = setupBuilder();</div><div class="line">        System.out.println(<span class="string">"Topology准备提交"</span>);</div><div class="line">        <span class="comment">//提交任务到集群</span></div><div class="line">        submitTopology(builder);</div><div class="line">        System.out.println(<span class="string">"Topology提交完成"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//!!!!这里通过setSpout和setBolt设置各个节点之间的连接关系，</span></div><div class="line">    <span class="comment">// 是这里把所有各自独立的节点用线连接起来，构建成一张具体的任务执行拓扑图</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TopologyBuilder <span class="title">setupBuilder</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 设置spout和bolt,完整参数为</div><div class="line">         * 1,spout的id(即name)</div><div class="line">         * 2,spout对象</div><div class="line">         * 3,executor数量即并发数，也就是设置多少个executor来执行spout/bolt(此项没有默认null)</div><div class="line">         */</div><div class="line">        <span class="comment">//setSpout，声明Spout名称Id为sentence-spout，并行度1</span></div><div class="line">        builder.setSpout(<span class="string">"sentence-spout"</span>, <span class="keyword">new</span> RandomSentenceSpout(), <span class="number">1</span>);</div><div class="line">        <span class="comment">//setBolt:SplitBolt的grouping策略是上层随机分发，CountBolt的grouping策略是按照上层字段分发</span></div><div class="line">        <span class="comment">//如果想要从多个Bolt获取数据，可以继续设置grouping</span></div><div class="line">        <span class="comment">//声明Bolt名称Id为split-bolt，并行度1</span></div><div class="line">        builder.setBolt(<span class="string">"split-bolt"</span>, <span class="keyword">new</span> SplitBolt(), <span class="number">1</span>)</div><div class="line">                <span class="comment">//设置该Bolt的数据源为sentence-spout的输出</span></div><div class="line">                .shuffleGrouping(<span class="string">"sentence-spout"</span>);</div><div class="line">        <span class="comment">//声明Bolt名称Id为count-bolt，并行度1</span></div><div class="line">        builder.setBolt(<span class="string">"count-bolt"</span>, <span class="keyword">new</span> CountBolt(), <span class="number">1</span>)</div><div class="line">                <span class="comment">//设置该Bolt的数据源为sentence-spout和split-bolt的输出</span></div><div class="line">                <span class="comment">//fieldsGrouping保证相同word对应的值发送到同一个Task节点，这是单词计数业务需要</span></div><div class="line">                .fieldsGrouping(<span class="string">"split-bolt"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>))</div><div class="line">                .fieldsGrouping(<span class="string">"sentence-spout"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        <span class="keyword">return</span> builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//提交任务到JStorm集群</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submitTopology</span><span class="params">(TopologyBuilder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (local_mode(conf)) &#123;<span class="comment">//本地模式，需要有本地JStorm环境支持</span></div><div class="line">                LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">                cluster.submitTopology(</div><div class="line">                        String.valueOf(conf.get(<span class="string">"topology.name"</span>)), conf,</div><div class="line">                        builder.createTopology());</div><div class="line"></div><div class="line">                Thread.sleep(<span class="number">200000</span>);</div><div class="line">                cluster.shutdown();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StormSubmitter.submitTopology(</div><div class="line">                        String.valueOf(conf.get(<span class="string">"topology.name"</span>)), conf,</div><div class="line">                        builder.createTopology());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOG.error(e.getMessage(), e.getCause());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//加载Properties配置文件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadProperty</span><span class="params">(String prop)</span> </span>&#123;</div><div class="line">        Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = <span class="keyword">new</span> FileInputStream(prop);</div><div class="line">            properties.load(stream);</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"No such file "</span> + prop);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        conf.putAll(properties);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//加载Yaml配置文件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadYaml</span><span class="params">(String confPath)</span> </span>&#123;</div><div class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = <span class="keyword">new</span> FileInputStream(confPath);</div><div class="line">            conf = (Map) yaml.load(stream);</div><div class="line">            <span class="keyword">if</span> (conf == <span class="keyword">null</span> || conf.isEmpty() == <span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to read config file"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"No such file "</span> + confPath);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No config file"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to read config file"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据后缀名选择加载配置文件方案</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadConf</span><span class="params">(String arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (arg.endsWith(<span class="string">"yaml"</span>)) &#123;</div><div class="line">            LoadYaml(arg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LoadProperty(arg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">local_mode</span><span class="params">(Map conf)</span> </span>&#123;</div><div class="line">        String mode = (String) conf.get(Config.STORM_CLUSTER_MODE);</div><div class="line">        <span class="keyword">if</span> (mode != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mode.equals(<span class="string">"local"</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="批量用法"><a href="#批量用法" class="headerlink" title="批量用法"></a>批量用法</h2><p>基本的用法是每次处理一个tuple，但是这种效率比较低，很多情况下是可以批量获取消息然后一起处理，批量用法对这种方式提供了支持。打开代码可以很明显地发现jstorm和storm的有着不小的区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// storm 中的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBatchSpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitBatch</span><span class="params">(<span class="keyword">long</span> batchId, TridentCollector collector)</span></span>;<span class="comment">// 批次发射tuple</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(<span class="keyword">long</span> batchId)</span></span>; <span class="comment">// 成功处理批次</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Map <span class="title">getComponentConfiguration</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Fields <span class="title">getOutputFields</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// jstorm中的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBatchSpout</span> <span class="keyword">extends</span> <span class="title">IBasicBolt</span>, <span class="title">ICommitter</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外如果用批次的话就需要改用BatchTopologyBuilder来构建拓扑结构，在IBatchSpout中主要实现的接口如下：</p>
<ol>
<li>execute：虽然和IBolt中名字、参数一致，但是增加了一些默认逻辑<blockquote>
<ul>
<li>入参的input.getValue(0)表示批次（BatchId）。</li>
<li>发送消息时collector.emit(new Values(batchId, value))，发送的列表第一个字段表示批次（BatchId）。</li>
</ul>
</blockquote>
</li>
<li>commit：批次成功时调用，常见的是修改offset。</li>
<li>revert：批次失败时调用，可以在这里根据offset取出批次数据进行重试。</li>
</ol>
<h2 id="Ack机制"><a href="#Ack机制" class="headerlink" title="Ack机制"></a>Ack机制</h2><ul>
<li>为保证无数据丢失，Storm/JStorm使用了非常漂亮的可靠性处理机制，如图当定义Topology时指定Acker，JStorm除了Topology本身任务外，还会启动一组称为Acker的特殊任务，负责跟踪Topolgogy DAG中的每个消息。每当发现一个DAG被成功处理完成，Acker就向创建根消息的Spout任务发送一个Ack信号。Topology中Acker任务的并行度默认parallelism hint=1，当系统中有大量的消息时，应该适当提高Acker任务的并行度。</li>
<li>Acker按照Tuple Tree的方式跟踪消息。当Spout发送一个消息的时候，它就通知对应的Acker一个新的根消息产生了，这时Acker就会创建一个新的Tuple Tree。当Acker发现这棵树被完全处理之后，他就会通知对应的Spout任务。</li>
<li>Acker任务保存了数据结构<code>Map&lt;MessageID,Map&lt; TaskID, Value&gt;&gt;</code>，其中MessageID是Spout根消息ID，TaskID是Spout任务ID，Value表示一个64bit的长整型数字，是树中所有消息的随机ID的异或结果。通过TaskID，Acker知道当消息树处理完成后通知哪个Spout任务，通过MessageID，Acker知道属于Spout任务的哪个消息被成功处理完成。Value表示了整棵树的的状态，无论这棵树多大，只需要这个固定大小的数字就可以跟踪整棵树。当消息被创建和被应答的时候都会有相同的MessageID发送过来做异或。当Acker发现一棵树的Value值为0的时候，表明这棵树已经被成功处理完成。</li>
<li>举例说明具体流程，以下为拓扑：<br><img src="/2017/09/03/JStorm实时计算框架学习/ack-example.jpg" alt="ack-example.jpg"></li>
<li>Acker数据的变化过程：（算法）<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Step1：A发送T0给B后：</div><div class="line">产生一个随机数r0，树种存R0：R0=r0</div><div class="line">&lt;id0,&lt;taskA,R0&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step2.B接收到T0并成功处理后向C发送T1，向D发送T2：</div><div class="line">接收到上级传过来的R0，自己传给两个下家，产生两个随机数代表下家存入树中：R1=R0^r1^r2=r0^r1^r2</div><div class="line">&lt;id0,&lt;taskA,R0^R1&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r0^r0^r1^r2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r1^r2&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step3.C接收到T1并成功处理后：</div><div class="line">接收到上家传过来的r1，没有下家：R2=r1</div><div class="line">&lt;id0,&lt;taskA,r1^r2^R2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r1^r2^r1&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r2&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step4.D接收到T2并成功处理后：</div><div class="line">接收到上家传过来的r2，没有下家：R3=r2</div><div class="line">&lt;id0,&lt;taskA,r2^R3&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r2^r2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,0&gt;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当结果为0时Acker可以通知taskA根消息id0的消息树已被成功处理完成，调用Spout的ack方法通知，若超时发现消息树中值不为0，调用Spout中的fail。</p>
<ul>
<li>整体节点间通信：<br><img src="/2017/09/03/JStorm实时计算框架学习/jstorm-ack.png" alt="jstorm-ack.png"></li>
</ul>
<blockquote>
<ul>
<li>需要指出的是，Acker并不是必须的，当实际业务可以容忍数据丢失情况下可以不用Acker，对数据丢失零容忍的业务必须打开Acker，另外当系统的消息规模较大是可适当增加Acker的并行度。</li>
</ul>
</blockquote>
<h2 id="JStorm事务"><a href="#JStorm事务" class="headerlink" title="JStorm事务"></a>JStorm事务</h2><p>事务拓扑并不是新的东西，只是在原始的ISpout、IBolt上做了一层封装。在事务拓扑中以并行（processing）和顺序（commiting）混合的方式来完成任务，使用Transactional Topology可以保证每个消息只会成功处理一次。不过需要注意的是，在Spout需要保证能够根据BatchId进行多次重试，在<a href="https://github.com/alibaba/jstorm/blob/master/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java" target="_blank" rel="external">这里</a>有一个基本的例子，<a href="http://ifeve.com/getting-started-of-storm8/" target="_blank" rel="external">这里</a>有一个不错的讲解。</p>
<h2 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h2><pre><code>这次一种更高级的抽象（甚至不需要知道底层是怎么map-reduce的），所面向的不再是spout和bolt，而是stream。主要涉及到下面几种接口：
</code></pre><ol>
<li>在本地完成的操作<blockquote>
<ul>
<li>Function：自定义操作。</li>
<li>Filters：自定义过滤。</li>
<li>partitionAggregate：对同批次的数据进行local combiner操作。</li>
<li>project：只保留stream中指定的field。</li>
<li>stateQuery、partitionPersist：查询和持久化。</li>
</ul>
</blockquote>
</li>
<li>决定Tuple如何分发到下一个处理环节<blockquote>
<ul>
<li>shuffle：随机。</li>
<li>broadcast：广播。</li>
<li>partitionBy：以某一个特定的field进行hash，分到某一个分区，这样该field位置相同的都会放到同一个分区。</li>
<li>global：所有tuple发到指定的分区。</li>
<li>batchGlobal：同一批的tuple被放到相同的分区（不同批次不同分区）。</li>
<li>partition：用户自定义的分区策略。</li>
</ul>
</blockquote>
</li>
<li>不同partition处理结果的汇聚操作<blockquote>
<ul>
<li>aggregate：只针对同一批次的数据。</li>
<li>persistentAggregate：针对所有批次进行汇聚，并将中间状态持久化。</li>
</ul>
</blockquote>
</li>
<li>对stream中的tuple进行重新分组，后续的操作将会对每一个分组独立进行（类似sql中的group by）<blockquote>
<ul>
<li>groupBy</li>
</ul>
</blockquote>
</li>
<li>将多个Stream融合成一个<blockquote>
<ul>
<li>merge：多个流进行简单的合并。</li>
<li>join：多个流按照某个KEY进行UNION操作（只能针对同一个批次的数据）。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在<a href="http://gitlab.alibaba-inc.com/aloha/aloha-utility/blob/master/metaspout/src/main/java/com/alibaba/aloha/meta/example/TestTridentTopology.java#L11" target="_blank" rel="external">这里</a>有一个jstorm中使用Trident的简单例子。</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ol>
<li><p>节点故障</p>
<ul>
<li>Nimbus故障。Nimbus本身无状态，所以Nimbus故障不会影响正在正常运行任务，另外Nimbus HA保证Nimbus故障后可以及时被备份Nimbus接管。</li>
<li>Supervisors节点故障。Supervisor故障后，Nimbus会将故障节点上的任务迁移到其他可用节点上继续运行，但是Supervisor故障需要外部监控并及时手动重启。</li>
<li>Worker故障。Worker健康状况监控由Supervisor负责，当Woker出现故障时，Supervisor会及时在本机重试重启。</li>
<li>Zookeeper节点故障。Zookeeper本身具有很好的故障恢复机制，能保证至少半数以上节点在线就可正常运行，及时修复故障节点即可。</li>
</ul>
</li>
<li><p>任务失败</p>
<ul>
<li>Spout失败。消息不能被及时被Pull到系统中，造成外部大量消息不能被及时处理，而外部大量计算资源空闲。</li>
<li>Bolt失败。消息不能被处理，Acker持有的所有与该Bolt相关的消息反馈值都不能回归到0，最后因为超时最终Spout的fail将被调用。</li>
<li>Acker失败。Acker持有的所有反馈信息不管成功与否都不能及时反馈到Spout，最后同样因为超时Spout的fail将被调用。</li>
<li>任务失败后，需要Nimbus及时监控到并重新分配失败任务。</li>
</ul>
</li>
</ol>
<h2 id="JStorm使用感受"><a href="#JStorm使用感受" class="headerlink" title="JStorm使用感受"></a>JStorm使用感受</h2><ol>
<li>JStorm各个节点之间是松耦合的，各个节点之间的通信只和Tuple数据流结构相关，其他处理逻辑各自独立</li>
<li>JStorm不处理数据的存储服务，计算结果自行存储到HDFS、HBase、Mysql、ElasticSearch等存储系统当中</li>
<li>JStorm的拓扑节点设计中，应该把延时操作分发到多个节点当中执行，每个节点只处理各自单一的功能逻辑，如上面的例子，我把单词分割和单词计数分成两个Bolt来实现，这才是流式计算的特点，让数据流动起来，而不是在一个节点完成所有工作，也保证了程序可用性更强</li>
<li>JStorm各个节点内部的处理逻辑非常开放，想怎么处理都行，只要最终往后输出相应的Tuple即可，编程时非常自由，不像MapReduce，很多操作都在MR模型中得到限制</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/hzorac/p/5570723.html" target="_blank" rel="external">ACK机制过程详解和故障恢复过程</a></li>
<li><a href="http://www.jstorm.io/" target="_blank" rel="external">官网文档</a></li>
<li><a href="http://www.cnblogs.com/antispam/p/4182210.html" target="_blank" rel="external">JSTORM使用笔记</a></li>
<li><a href="https://github.com/alibaba/jstorm" target="_blank" rel="external">JStorm开源地址</a></li>
<li><a href="http://shiyanjun.cn/archives/977.html" target="_blank" rel="external">JStorm流的汇聚和分发</a></li>
<li><a href="http://www.cnblogs.com/panfeng412/archive/2012/06/04/storm-common-patterns-of-stream-join.html" target="_blank" rel="external">Storm常见模式——流聚合（类似并发包中的栅栏）</a></li>
<li><a href="http://ifeve.com/getting-started-with-storm-5/" target="_blank" rel="external">锚定anchors的使用</a></li>
<li><a href="http://ifeve.com/getting-started-with-storm-2/" target="_blank" rel="external">并发编程网Storm入门</a></li>
<li></li>
</ul>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.coselding.cn/2017/09/03/JStorm实时计算框架学习/" data-id="cj74sx1qc0007rk50e791qfdz" class="article-share-link">分享</a><div class="tags"><a href="/tags/实时计算/">实时计算</a><a href="/tags/java/">java</a><a href="/tags/JStorm/">JStorm</a><a href="/tags/流式计算/">流式计算</a></div><div class="post-nav"><a href="/2017/05/25/Solr6.5.1集群部署和后台管理/" class="next">Solr 6.5.1集群部署和后台管理</a></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
  url: document.location.href,
  productKey: "8c4e8416431747c595ded338559ffe2e",
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/03/JStorm实时计算框架学习/">JStorm实时计算框架学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/25/Solr6.5.1集群部署和后台管理/">Solr 6.5.1集群部署和后台管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/maven多套环境配置文件和junit冲突问题解决方案/">maven多套环境配置文件和junit冲突问题解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/04/Quartz调度系统入门和调度高可用实现方案/">Quartz调度系统入门和调度高可用实现方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/16/Swagger-maven-plugin-环境配置踩坑记录/">Swagger-maven-plugin-环境配置踩坑记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/09/记毕设过程中遇到的一个InnoDB的坑/">记毕设过程中遇到的一个InnoDB的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/12/知识、任务管理软件个人测评/">知识、任务管理软件个人测评</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/02/Dubbo入门学习笔记/">Dubbo入门学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/02/ZooKeeper配置和学习笔记/">ZooKeeper配置和学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/Pushy入门文档中文翻译/">Pushy入门文档中文翻译</a></li></ul></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/个人心得/">个人心得</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/实时计算/">实时计算</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推送/">推送</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/lucene/" style="font-size: 15px;">lucene</a> <a href="/tags/pushy/" style="font-size: 15px;">pushy</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a> <a href="/tags/http-2/" style="font-size: 15px;">http/2</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/RPC/" style="font-size: 15px;">RPC</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/SOA/" style="font-size: 15px;">SOA</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/实时计算/" style="font-size: 15px;">实时计算</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/JStorm/" style="font-size: 15px;">JStorm</a> <a href="/tags/流式计算/" style="font-size: 15px;">流式计算</a> <a href="/tags/调度/" style="font-size: 15px;">调度</a> <a href="/tags/quartz/" style="font-size: 15px;">quartz</a> <a href="/tags/分布式调度/" style="font-size: 15px;">分布式调度</a> <a href="/tags/Swagger/" style="font-size: 15px;">Swagger</a> <a href="/tags/自动化/" style="font-size: 15px;">自动化</a> <a href="/tags/RESTful/" style="font-size: 15px;">RESTful</a> <a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/搜索引擎/" style="font-size: 15px;">搜索引擎</a> <a href="/tags/solr/" style="font-size: 15px;">solr</a> <a href="/tags/APNs/" style="font-size: 15px;">APNs</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/折腾/" style="font-size: 15px;">折腾</a> <a href="/tags/环境搭建/" style="font-size: 15px;">环境搭建</a> <a href="/tags/mac实用插件/" style="font-size: 15px;">mac实用插件</a> <a href="/tags/集群管理/" style="font-size: 15px;">集群管理</a> <a href="/tags/选举/" style="font-size: 15px;">选举</a> <a href="/tags/zookeeper/" style="font-size: 15px;">zookeeper</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/junit/" style="font-size: 15px;">junit</a> <a href="/tags/filter/" style="font-size: 15px;">filter</a> <a href="/tags/spring-test/" style="font-size: 15px;">spring-test</a> <a href="/tags/经验/" style="font-size: 15px;">经验</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/校招/" style="font-size: 15px;">校招</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/读写锁/" style="font-size: 15px;">读写锁</a> <a href="/tags/事务/" style="font-size: 15px;">事务</a> <a href="/tags/时间管理/" style="font-size: 15px;">时间管理</a> <a href="/tags/知识管理/" style="font-size: 15px;">知识管理</a> <a href="/tags/doit-im/" style="font-size: 15px;">doit.im</a> <a href="/tags/GTD/" style="font-size: 15px;">GTD</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zning.net.cn" title="张宁网" target="_blank">张宁网</a><ul></ul><a href="https://cloudups.github.io" title="凌云阁" target="_blank">凌云阁</a><ul></ul><a href="https://noahzu.github.io" title="Android资源开发小栈" target="_blank">Android资源开发小栈</a><ul></ul><a href="https://heinika.github.io/" title="陈利津" target="_blank">陈利津</a><ul></ul><a href="http://www.itfenghui.com/" title="SEO" target="_blank">SEO</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Coselding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?abf89816d80a3915fe058fcbceeaa9b9";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>