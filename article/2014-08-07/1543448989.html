<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java、分布式、大数据、微服务、机器学习"><title> | Coselding</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Coselding</h1><a id="logo" href="/.">Coselding</a><p class="description">非淡泊无以明志，非宁静无以致远。</p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/links/"><i class="fa fa-link"> 链接</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"></h1><div class="post-content"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>android的消息处理机制（图+源码分析）——Looper,Handler,Message</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 引入 Bootstrap -->
    <link href="http://bootswatch.com/cerulean/bootstrap.min.css" rel="stylesheet">
    <!-- HTML5 Shim 和 Respond.js 用于让 IE8 支持 HTML5元素和媒体查询 -->
    <!-- 注意： 如果通过 file://  引入 Respond.js 文件，则该文件无法起效果 -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
    <!-- jQuery (Bootstrap 的 JavaScript 插件需要引入 jQuery) -->
    <script src="http://cdn.static.runoob.com/libs/jquery/2.1.1/jquery.min.js"></script>
    <!-- 包括所有已编译的插件 -->
    <script src="http://cdn.static.runoob.com/libs/bootstrap/3.3.7/js/bootstrap.min.js"></script>

    <link href="/css/style.css" rel="stylesheet">
</head>
<body>
<nav class="navbar navbar-default" role="navigation">
    <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#example-navbar-collapse">
            <span class="sr-only">切换导航</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        <div class="navbar-brand"></div>
        <img src="/logo.jpg" style="border-radius:25px;" width="50px" height="50px">&nbsp;&nbsp;
        <a class="title-text nav-title" style="color: #FFFFFF" href="/public/contact.html">Coselding</a>
    </div>
    <div class="collapse navbar-collapse" id="example-navbar-collapse">
        <ul class="nav navbar-nav navbar-right" id="menu-click">
            <li class="active"><a href="/Coselding-old/">旧版入口>></a></li>
            <li><a href="/list">所有文章</a></li>
            <li><a href="https://github.com/Coselding" target="_blank" rel="external">Github</a></li>
            <li><a href="http://blog.csdn.net/u014394255" target="_blank" rel="external">CSDN博客</a></li>
            <li><a href="/comment/">留言板</a></li>
            <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    Menu<b class="caret"></b>
                </a>
                <ul class="dropdown-menu">
                    <li><a href="/s/">短网址</a></li>
                    <li><a href="/WordUpload/">作业提交系统</a></li>
                    <li class="divider"></li>
                    <li><a href="/public/contact.html">关于我</a></li>
                </ul>
            </li>
        </ul>
    </div>
</nav>

<div class="container">
    <div class="container-fluid">
        <h1 class="collection-header" id="sub-title"><span>非淡泊无以明志，非宁静无以致远。</span></h1>
        <div class="collection-info">
            <span class="meta-info mobile-hidden">
                <span class="glyphicon glyphicon-map-marker"></span>
                福建漳州
            </span>&nbsp;&nbsp;
            <span class="meta-info">
                <span class="glyphicon glyphicon-tag"></span>
                Java Developer
            </span>&nbsp;&nbsp;
            <span class="meta-info">
                <span class="glyphicon glyphicon-user"></span>
                <a href="/public/contact.html" target="_blank">林宇强</a>
            </span>&nbsp;&nbsp;
            <span class="meta-info">
                <span class="glyphicon glyphicon-link"></span>
                <a href="https://github.com/Coselding" target="_blank">Github</a>
            </span>
        </div>
    </div>
</div>

<div class="container">
    <div class="clearfix">
        <div class="col-md-8 column">
            <h3 class="text-left text-primary"></h3>
        </div>
    </div>
</div>

<div class="container">
    <div class="row clearfix">
        <div class="col-md-9 column">
            <div class="panel panel-default">
                <div class="panel-body">
                    <h2 class="panel-title text-left">
                        <a href="/list?cid=2" title="Android">
                        Android
                        </a>
                        &gt;&gt;
                        android的消息处理机制（图+源码分析）——Looper,Handler,Message
                    </h2>
                </div>
                <div class="panel-body">
                    <h2 class="panel-title text-center">android的消息处理机制（图+源码分析）——Looper,Handler,Message</h2>
                </div>

                <div class="panel-body">
                    <div class="text-center">
                        <a href="/list?cid=2" title="查看该标签文章">
                            <span class="glyphicon glyphicon-tags"></span> Android
                        </a>
                        &nbsp;&nbsp;
                        <a href="#">
                            <span class="glyphicon glyphicon-user"></span> Coselding
                        </a>
                        &nbsp;&nbsp;
                        <span class="glyphicon glyphicon-time"></span> 2014-08-07 11:16
                    </div>
                </div>

                <div class="panel-body">
                
                <div> 
 <h1><span style="font-family:微软雅黑;">作为一个大三的预备程序员，我学习android的一大乐趣是可以通过源码学习google大牛们的设计思想。android源码中包含了大量的设计模式，除此以外，android sdk还精心为我们设计了各种helper类，对于和我一样渴望水平得到进阶的人来说，都太值得一读了。这不，前几天为了了解android的消息处理机制，我看了<strong>Looper</strong><strong>，</strong><strong>Handler</strong><strong>，</strong><strong>Message</strong>这几个类的源码，结果又一次被googler的设计震撼了，特与大家分享。</span></h1> 
</div> 
<p><span style="font-family:微软雅黑;">android的消息处理有三个核心类：Looper,Handler和Message。其实还有一个Message Queue（消息队列），但是MQ被封装到Looper里面了，我们不会直接与MQ打交道，因此我没将其作为核心类。下面一一介绍：</span></p> 
<h1><span style="font-family:微软雅黑;">线程的魔法师 Looper</span></h1> 
<p><span style="font-family:微软雅黑;">Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成<strong>Looper</strong><strong>线程</strong>。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程。使用Looper类创建Looper线程很简单：</span></p> 
<pre>
<span style="font-family:微软雅黑;">public class LooperThread extends Thread {

&nbsp;&nbsp;&nbsp; @Override
&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将当前线程初始化为Looper线程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looper.prepare();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...其他处理，如实例化handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 开始循环处理消息队列
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looper.loop();
&nbsp;&nbsp;&nbsp; }
}
</span></pre> 
<p><span style="font-family:微软雅黑;">通过上面两行核心代码，你的线程就升级为Looper线程了！！！是不是很神奇？让我们放慢镜头，看看这两行代码各自做了什么。</span></p> 
<p><span style="font-family:微软雅黑;">1)Looper.prepare()</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/d0780a27-db12-4a06-832e-8b01c41b3313_.png"><img alt="" src="/upload/images/d0780a27-db12-4a06-832e-8b01c41b3313_.png" style="; ;" width="100%" height=""></a></span></p> 
<p><span style="font-family:微软雅黑;">通过上图可以看到，现在你的线程中有一个Looper对象，它的内部维护了一个消息队列MQ。注意，<strong>一个</strong><strong>Thread</strong><strong>只能有一个</strong><strong>Looper</strong><strong>对象</strong>，为什么呢？咱们来看源码。</span></p> 
<div> 
 <p>&nbsp;</p> 
</div> 
<pre>
<span style="font-family:微软雅黑;">public class Looper {

&nbsp;&nbsp;&nbsp; // 每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象
&nbsp;&nbsp;&nbsp; private static final ThreadLocal sThreadLocal = new ThreadLocal();
&nbsp;&nbsp;&nbsp; // Looper内的消息队列
&nbsp;&nbsp;&nbsp; final MessageQueue mQueue;
&nbsp;&nbsp;&nbsp; // 当前线程
&nbsp;&nbsp;&nbsp; Thread mThread;
&nbsp;&nbsp;&nbsp; // 。。。其他属性
&nbsp;&nbsp;&nbsp; // 每个Looper对象中有它的消息队列，和它所属的线程
&nbsp;&nbsp;&nbsp; private Looper() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mQueue = new MessageQueue();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mRun = true;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mThread = Thread.currentThread();
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // 我们调用该方法会在调用线程的TLS中创建Looper对象
&nbsp;&nbsp;&nbsp; public static final void prepare() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sThreadLocal.get() != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 试图在有Looper的线程中再次创建Looper将抛出异常
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new RuntimeException("Only one Looper may be created per thread");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sThreadLocal.set(new Looper());
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // 其他方法
}
</span></pre> 
<p><span style="font-family:微软雅黑;">通过源码，prepare()背后的工作方式一目了然，其核心就是将looper对象定义为ThreadLocal。如果你还不清楚什么是ThreadLocal，请参考<a href="http://blog.csdn.net/qjyong/article/details/2158097" target="http://www.cnblogs.com/codingmyworld/archive/2011/09/14/_blank"><strong>《理解</strong><strong>ThreadLocal</strong><strong>》</strong></a>。</span></p> 
<p><span style="font-family:微软雅黑;">2）Looper.loop()</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/6f90c194-65ea-4f9f-9af9-a6a154d78ecb_.png"><img alt="" src="/upload/images/6f90c194-65ea-4f9f-9af9-a6a154d78ecb_.png" style="; ;" width="100%" height=""></a></span></p> 
<p><span style="font-family:微软雅黑;">调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MQ中取出队头的消息(也叫任务)执行。其源码分析如下：</span></p> 
<pre>
<span style="font-family:微软雅黑;">&nbsp; public static final void loop() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looper me = myLooper();&nbsp; //得到当前线程Looper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageQueue queue = me.mQueue;&nbsp; //得到当前looper的MQ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 这两行没看懂= = 不过不影响理解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Binder.clearCallingIdentity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final long ident = Binder.clearCallingIdentity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 开始循环
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message msg = queue.next(); // 取出message
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg.target == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // message没有target为结束信号，退出循环
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 日志。。。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (me.mLogging!= null) me.mLogging.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + msg.callback + ": " + msg.what
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 非常重要！将真正的处理工作交给message的target，即后面要讲的handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.target.dispatchMessage(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 还是日志。。。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (me.mLogging!= null) me.mLogging.println(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&lt;&lt;&lt;&lt;&lt; Finished to&nbsp;&nbsp;&nbsp; " + msg.target + " "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + msg.callback);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 下面没看懂，同样不影响理解
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final long newIdent = Binder.clearCallingIdentity();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ident != newIdent) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Log.wtf("Looper", "Thread identity changed from 0x"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + Long.toHexString(ident) + " to 0x"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + Long.toHexString(newIdent) + " while dispatching to "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + msg.target.getClass().getName() + " "
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + msg.callback + " what=" + msg.what);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 回收message资源
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.recycle();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
</span></pre> 
<p><span style="font-family:微软雅黑;">除了prepare()和loop()方法，Looper类还提供了一些有用的方法，比如</span></p> 
<p><span style="font-family:微软雅黑;">Looper.myLooper()得到当前线程looper对象：</span></p> 
<pre>
<span style="font-family:微软雅黑;">&nbsp;&nbsp;&nbsp; public static final Looper myLooper() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 在任意线程调用Looper.myLooper()返回的都是那个线程的looper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (Looper)sThreadLocal.get();
&nbsp;&nbsp;&nbsp; }</span></pre> 
<p><span style="font-family:微软雅黑;">getThread()得到looper对象所属线程：</span></p> 
<pre>
<span style="font-family:微软雅黑;">&nbsp;&nbsp;&nbsp; public Thread getThread() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return mThread;
&nbsp;&nbsp;&nbsp; }</span></pre> 
<p><span style="font-family:微软雅黑;">quit()方法结束looper循环：</span></p> 
<div> 
 <p><span style="font-family:微软雅黑;">View Code</span></p> 
</div> 
<p><span style="font-family:微软雅黑;">到此为止，你应该对Looper有了基本的了解，总结几点：</span></p> 
<p><span style="font-family:微软雅黑;">1.每个线程有且最多只能有一个Looper对象，它是一个ThreadLocal</span></p> 
<p><span style="font-family:微软雅黑;">2.Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行</span></p> 
<p><span style="font-family:微软雅黑;">3.Looper使一个线程变成Looper线程。</span></p> 
<p><span style="font-family:微软雅黑;">那么，我们如何往MQ上添加消息呢？下面有请Handler！（掌声~~~）</span></p> 
<h1><span style="font-family:微软雅黑;">异步处理大师 Handler</span></h1> 
<p><span style="font-family:微软雅黑;">什么是handler？handler扮演了往MQ上添加消息和处理消息的角色（只处理由自己发出的消息），即<strong>通知</strong><strong>MQ</strong><strong>它要执行一个任务</strong><strong>(sendMessage)</strong><strong>，并在</strong><strong>loop</strong><strong>到自己的时候执行该任务</strong><strong>(handleMessage)</strong><strong>，整个过程是异步的</strong>。handler创建时会关联一个looper，默认的构造方法将关联当前线程的looper，不过这也是可以set的。默认的构造方法：</span></p> 
<pre>
<span style="font-family:微软雅黑;">public class handler {
&nbsp;&nbsp;&nbsp; final MessageQueue mQueue;&nbsp; // 关联的MQ
&nbsp;&nbsp;&nbsp; final Looper mLooper;&nbsp; // 关联的looper
&nbsp;&nbsp;&nbsp; final Callback mCallback; 
&nbsp;&nbsp;&nbsp; // 其他属性
&nbsp;&nbsp;&nbsp; public Handler() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 没看懂，直接略过，，，
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (FIND_POTENTIAL_LEAKS) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final Class
  <!--? extends Handler--> klass = getClass();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;klass.getCanonicalName());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 默认将关联当前线程的looper
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mLooper = Looper.myLooper();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // looper不能为空，即该默认的构造方法只能在looper线程中使用
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mLooper == null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new RuntimeException(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;"Can't create handler inside thread that has not called Looper.prepare()");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 重要！！！直接把关联looper的MQ作为自己的MQ，因此它的消息将发送到关联looper的MQ上
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mQueue = mLooper.mQueue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mCallback = null;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // 其他方法
}
</span></pre> 
<p><span style="font-family:微软雅黑;">下面我们就可以为之前的LooperThread类加入Handler：</span></p> 
<pre>
<span style="font-family:微软雅黑;">public class LooperThread extends Thread {

&nbsp;&nbsp;&nbsp; private Handler handler1;
&nbsp;&nbsp;&nbsp; private Handler handler2;

&nbsp;&nbsp;&nbsp; @Override
&nbsp;&nbsp;&nbsp; public void run() {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将当前线程初始化为Looper线程
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looper.prepare();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 实例化两个handler
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler1 = new Handler();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler2 = new Handler();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 开始循环处理消息队列
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Looper.loop();
&nbsp;&nbsp;&nbsp; }
}
</span></pre> 
<p><span style="font-family:微软雅黑;">加入handler后的效果如下图：</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/ad3e2995-f00d-4bc1-a91d-9f169b95ebc9_.png"><img alt="" src="/upload/images/ad3e2995-f00d-4bc1-a91d-9f169b95ebc9_.png" style="; ;" width="100%" height=""></a> /&gt;</span></p> 
<p><span style="font-family:微软雅黑;">可以看到，<strong>一个线程可以有多个</strong><strong>Handler</strong><strong>，但是只能有一个</strong><strong>Looper</strong><strong>！</strong></span></p> 
<p><span style="font-family:微软雅黑;"><strong>Handler</strong><strong>发送消息</strong></span></p> 
<p><span style="font-family:微软雅黑;">有了handler之后，我们就可以使用&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#post(java.lang.Runnable)" target="_blank" rel="external"><strong>post(Runnable)</strong></a>,&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#postAtTime(java.lang.Runnable, long)" target="_blank" rel="external"><strong>postAtTime(Runnable, long)</strong></a>,&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#postDelayed(java.lang.Runnable, long)" target="_blank" rel="external"><strong>postDelayed(Runnable, long)</strong></a>,&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#sendEmptyMessage(int)" target="_blank" rel="external"><strong>sendEmptyMessage(int)</strong></a>,<a href="http://developer.android.com/reference/android/os/Handler.html#sendMessage(android.os.Message)" target="_blank" rel="external"><strong>sendMessage(Message)</strong></a>,&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#sendMessageAtTime(android.os.Message, long)" target="_blank" rel="external"><strong>sendMessageAtTime(Message, long)</strong></a>和&nbsp;<a href="http://developer.android.com/reference/android/os/Handler.html#sendMessageDelayed(android.os.Message, long)" target="_blank" rel="external"><strong>sendMessageDelayed(Message, long)</strong></a>这些方法向MQ上发送消息了。光看这些API你可能会觉得handler能发两种消息，一种是Runnable对象，一种是message对象，这是直观的理解，但其实post发出的Runnable对象最后都被封装成message对象了，见源码：</span></p> 
<pre>
<span style="font-family:微软雅黑;">&nbsp;&nbsp;&nbsp; // 此方法用于向关联的MQ上发送Runnable对象，它的run方法将在handler关联的looper线程中执行
&nbsp;&nbsp;&nbsp; public final boolean post(Runnable r)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 注意getPostMessage(r)将runnable封装成message
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp; sendMessageDelayed(getPostMessage(r), 0);

&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; private final Message getPostMessage(Runnable r) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message m = Message.obtain();&nbsp; //得到空的message
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m.callback = r;&nbsp; //将runnable设为message的callback，
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return m;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; public boolean sendMessageAtTime(Message msg, long uptimeMillis)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; boolean sent = false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MessageQueue queue = mQueue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (queue != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg.target = this;&nbsp; // message的target必须设为该handler！
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sent = queue.enqueueMessage(msg, uptimeMillis);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RuntimeException e = new RuntimeException(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this + " sendMessageAtTime() called with no mQueue");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Log.w("Looper", e.getMessage(), e);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return sent;
&nbsp;&nbsp;&nbsp; }
</span></pre> 
<p><span style="font-family:微软雅黑;">其他方法就不罗列了，总之通过handler发出的message有如下特点：</span></p> 
<p><span style="font-family:微软雅黑;">1.message.target为该handler对象，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码</span></p> 
<pre>
<span style="font-family:微软雅黑;">msg.target.dispatchMessage(msg);</span></pre> 
<p><span style="font-family:微软雅黑;">2.post发出的message，其callback为Runnable对象</span></p> 
<p><span style="font-family:微软雅黑;"><strong>Handler</strong><strong>处理消息</strong></span></p> 
<p><span style="font-family:微软雅黑;">说完了消息的发送，再来看下handler如何处理消息。消息的处理是通过核心方法<a href="http://developer.android.com/reference/android/os/Handler.html#dispatchMessage(android.os.Message)" target="_blank" rel="external"><strong>dispatchMessage</strong></a>(<a href="http://developer.android.com/reference/android/os/Message.html" target="_blank" rel="external"><strong>Message</strong></a>&nbsp;msg)与钩子方法<a href="http://developer.android.com/reference/android/os/Handler.html#handleMessage(android.os.Message)" target="_blank" rel="external"><strong>handleMessage</strong></a>(<a href="http://developer.android.com/reference/android/os/Message.html" target="_blank" rel="external"><strong>Message</strong></a>&nbsp;msg)完成的，见源码</span></p> 
<pre>
<span style="font-family:微软雅黑;">&nbsp;&nbsp;&nbsp; // 处理消息，该方法由looper调用

&nbsp;&nbsp;&nbsp; public void dispatchMessage(Message msg) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (msg.callback != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果message设置了callback，即runnable消息，处理callback！
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handleCallback(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果handler本身设置了callback，则执行callback
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mCallback != null) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865 */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (mCallback.handleMessage(msg)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 如果message没有callback，则调用handler的钩子方法handleMessage
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handleMessage(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // 处理runnable消息
&nbsp;&nbsp;&nbsp; private final void handleCallback(Message message) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message.callback.run(); &nbsp;//直接调用run方法！
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; // 由子类实现的钩子方法
&nbsp;&nbsp;&nbsp; public void handleMessage(Message msg) {
&nbsp;&nbsp;&nbsp; }
</span></pre> 
<p><span style="font-family:微软雅黑;">可以看到，除了<a href="http://developer.android.com/reference/android/os/Handler.html#handleMessage(android.os.Message)" target="_blank" rel="external"><strong>handleMessage</strong></a>(<a href="http://developer.android.com/reference/android/os/Message.html" target="_blank" rel="external"><strong>Message</strong></a>&nbsp;msg)和Runnable对象的run方法由开发者实现外（实现具体逻辑），handler的内部工作机制对开发者是透明的。这正是handler API设计的精妙之处！</span></p> 
<p><span style="font-family:微软雅黑;"><strong>Handler</strong><strong>的用处</strong></span></p> 
<p><span style="font-family:微软雅黑;">我在小标题中将handler描述为“异步处理大师”，这归功于Handler拥有下面两个重要的特点：</span></p> 
<p><span style="font-family:微软雅黑;">1.handler可以在<strong>任意线程发送消息</strong>，这些消息会被添加到关联的MQ上。</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/b8b55800-51e7-4358-b53f-18f8af40472d_.png"><img src="/upload/images/b8b55800-51e7-4358-b53f-18f8af40472d_.png" style="; ;" width="100%" height=""></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p> 
<p><span style="font-family:微软雅黑;">2.handler是在它<strong>关联的</strong><strong>looper</strong><strong>线程中处理消息</strong>的。</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/8abf5242-cdca-41cb-bef0-c5bccfe5affd_.png"><img src="/upload/images/8abf5242-cdca-41cb-bef0-c5bccfe5affd_.png" style="; ;" width="100%" height=""></a></span></p> 
<p><span style="font-family:微软雅黑;">这就解决了android最经典的不能在其他非主线程中更新UI的问题。<strong>android</strong><strong>的主线程也是一个</strong><strong>looper</strong><strong>线程</strong>(looper在android中运用很广)，我们在其中创建的handler默认将关联主线程MQ。因此，利用handler的一个solution就是在activity中创建handler并将其引用传递给worker thread，worker thread执行完任务后使用handler发送消息通知activity更新UI。(过程如图)</span></p> 
<p><span style="font-family:微软雅黑;"><a href="/upload/images/2c5d0d35-3efb-4277-87c7-e773f0181883_.png"><img src="/upload/images/2c5d0d35-3efb-4277-87c7-e773f0181883_.png" style="; ;" width="100%" height=""></a></span></p> 
<p><span style="font-family:微软雅黑;">下面给出sample代码，仅供参考：</span></p> 
<div> 
 <p><span style="font-family:微软雅黑;">View Code</span></p> 
</div> 
<pre>
<span style="font-family:微软雅黑;">public class SampleTask implements Runnable {

&nbsp;&nbsp;&nbsp; private static final String TAG = SampleTask.class.getSimpleName();
&nbsp;&nbsp;&nbsp; Handler handler;
&nbsp;&nbsp;&nbsp; public SampleTask(Handler handler) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.handler = handler;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; @Override
&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp; // 模拟执行某项任务，下载等
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(5000);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 任务完成后通知activity更新UI
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message msg = prepareMessage("task completed!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // message将被添加到主线程的MQ中
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handler.sendMessage(msg);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Log.d(TAG, "interrupted!");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; private Message prepareMessage(String str) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Message result = handler.obtainMessage();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bundle data = new Bundle();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data.putString("message", str);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result.setData(data);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return result;
&nbsp;&nbsp;&nbsp; }
}
</span></pre> 
<p><span style="font-family:微软雅黑;">当然，handler能做的远远不仅如此，由于它能post Runnable对象，它还能与Looper配合实现经典的Pipeline Thread(流水线线程)模式。请参考此文<a href="http://mindtherobot.com/blog/159/android-guts-intro-to-loopers-and-handlers/" target="_blank" rel="external"><strong>《</strong><strong>Android Guts: Intro to Loopers and Handlers</strong><strong>》</strong></a></span></p> 
<h1><span style="font-family:微软雅黑;">封装任务 Message</span></h1> 
<p><span style="font-family:微软雅黑;">在整个消息处理机制中，message又叫task，封装了任务携带的信息和处理该任务的handler。message的用法比较简单，这里不做总结了。但是有这么几点需要注意（待补充）：</span></p> 
<p><span style="font-family:微软雅黑;">1.尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。</span></p> 
<p><span style="font-family:微软雅黑;">2.如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存</span></p> 
<p><span style="font-family:微软雅黑;">3.擅用message.what来标识信息，以便用不同方式处理message。</span></p> 
<p>&nbsp;</p>
                
                </div>

                <div class="panel-body">
                    <div>
                        <a id="looked" href="#"><span class="glyphicon glyphicon-eye-open"></span> 247 已阅</a>
                        &nbsp;&nbsp;
                        <a id="likes" href="javascript:like('/like?artid=112')" target="_blank" rel="external">
                            <span class="glyphicon glyphicon-heart-empty"></span> 21 喜爱
                        </a>
                        &nbsp;&nbsp;
                        <a class="comment-btn" href="javascript:onComment('/comment','android的消息处理机制（图+源码分析）——Looper,Handler,Message','112')" target="_blank" rel="external"><span class="glyphicon glyphicon-comment"></span> 给我留言</a>
                    </div>
                </div>
                <div class="panel-body">
                    <div class="text-left">
                        <a href="/article/2014-08-06/-330028847.html" title="上一篇">
                            &laquo;多线程编程学习笔记
                        </a>
                    </div>
                    <div class="text-right">
                        <a href="/article/2014-10-08/1365264606.html" title="下一篇">
                            HTTP学习笔记&raquo;
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div class="col-md-3 column">

            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h3 class="panel-title"><span class="glyphicon glyphicon-bullhorn"></span>&nbsp; 最近更新</h3>
                </div>

                <ul id="last3" class="list-group">
                    <li class="list-group-item">
                        <div class="list-group-item-heading text-left">
                            <h5><a href="/article/2017-03-12/which-knowledgeAndGTD-app-to-use.html">知识、任务管理软件个人测评</a></h5>
                        </div>
                        <div class="list-group-item-text text-right">
                            <em>2017-03-12 20:19</em>
                        </div>
                    </li>
                    <li class="list-group-item">
                        <div class="list-group-item-heading text-left">
                            <h5><a href="/article/2017-01-02/dubbo-study-record.html">Dubbo入门学习笔记</a></h5>
                        </div>
                        <div class="list-group-item-text text-right">
                            <em>2017-01-02 22:57</em>
                        </div>
                    </li>
                    <li class="list-group-item">
                        <div class="list-group-item-heading text-left">
                            <h5><a href="/article/2017-01-02/zookeeper-study-record.html">ZooKeeper配置和学习笔记</a></h5>
                        </div>
                        <div class="list-group-item-text text-right">
                            <em>2017-01-02 17:21</em>
                        </div>
                    </li>

                    <li class="list-group-item text-center">
                        <a href="/list">more</a>
                    </li>
                </ul>
            </div>

            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h5 class="text-left"><span class="glyphicon glyphicon-search"></span> &nbsp;搜索文章</h5>
                </div>
                <div class="panel-body">
                    <form role="form" method="post" action="/search">
                        <div class="form-group">
                            <input class="form-control" type="text" name="key" value="输入关键字搜索博客..." onfocus="this.value=''" onblur="this.value='输入关键字搜索博客...'">
                        </div>
                    </form>
                </div>
            </div>

            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h3 class="panel-title"><span class="glyphicon glyphicon-tags"></span> &nbsp;标签</h3>
                </div>

                <ul id="categories" class="list-group">
                    <li class="list-group-item"><a href="/list?cid=2">Android(12)</a></li>
                    <li class="list-group-item"><a href="/list?cid=11">Hadoop和云计算(10)</a></li>
                    <li class="list-group-item"><a href="/list?cid=12">iOS相关(2)</a></li>
                    <li class="list-group-item"><a href="/list?cid=5">JavaEE(12)</a></li>
                    <li class="list-group-item"><a href="/list?cid=3">JavaSE(3)</a></li>
                    <li class="list-group-item"><a href="/list?cid=9">个人心得(6)</a></li>
                    <li class="list-group-item"><a href="/list?cid=7">前端(4)</a></li>
                    <li class="list-group-item"><a href="/list?cid=6">基础知识(6)</a></li>
                    <li class="list-group-item"><a href="/list?cid=10">数据库(1)</a></li>
                    <li class="list-group-item"><a href="/list?cid=8">框架相关(16)</a></li>
                    <li class="list-group-item"><a href="/list?cid=4">项目相关(5)</a></li>
                </ul>
            </div>

            <div class="panel panel-primary">
                <div class="panel-heading">
                    <h3 class="panel-title"><span class="glyphicon glyphicon-link"></span> &nbsp;友情链接</h3>
                </div>
                <ul class="list-group">
                    <li class="list-group-item"><a href="https://www.zning.net.cn" target="_blank" rel="external">张宁网</a></li>
                    <li class="list-group-item"><a href="https://cloudups.github.io" target="_blank" rel="external">凌云阁</a></li>
                    <li class="list-group-item"><a href="https://noahzu.github.io" target="_blank" rel="external">Android资源开发小栈</a></li>
                    <li class="list-group-item"><a href="https://heinika.github.io/" target="_blank" rel="external">陈利津</a></li>
                    <li class="list-group-item"><a href="http://www.itfenghui.com/" title="SEO" target="_blank" rel="external">SEO</a></li>
                </ul>
            </div>
        </div>
    </div>
</div>

<footer class="panel-footer">
    <div class="container">
        <div class="row clearfix text-center">
            <a href="/s/">短网址</a>&nbsp;&nbsp;
            <a href="/WorkUpload/">作业提交系统</a>&nbsp;&nbsp;
            <!--<a href="/uShare/">uShare</a>&nbsp;&nbsp;-->
            <!--<a href="/smartor/">Smartor</a>&nbsp;&nbsp;-->
            <!--<a href="/PlaneWar/">飞机大战</a>-->
        </div>
        <div class="row clearfix text-center">
            <div class="copyright">
                Copyright &copy;2016.Coselding &nbsp; All rights reserved.<a href="http://www.miitbeian.gov.cn" target="_blank" rel="external">鲁ICP备15036981号-2</a>
            </div>

            <div class="netsupervisor-div">
                <a class="netsupervisor-a" target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=37021002000115">
                    <img src="/images/beian.png" class="netsupervisor-image">
                    <p class="netsupervisor-text">鲁公网安备
                        37021002000115号</p>
                </a>
            </div>
        </div>
    </div>
</footer>
</body>
<script type="text/javascript" src="/js/scripts.js"></script>
<script type="text/javascript">
    $(function(){//网页加载完成执行
        refreshLookedAndLikes('/refresh?artid=112');
        refreshLast3Articles('/last3','');
        refreshCategories('/categories','');
    });
</script>
</html></div></div><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script>var cloudTieConfig = {
  url: document.location.href,
  productKey: "8c4e8416431747c595ded338559ffe2e",
  target: "cloud-tie-wrapper"
};</script><script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016-12-05/校招之路/">校招之路</a></li><li class="post-list-item"><a class="post-list-link" href="/2016-12-05/Solr6.5.1集群部署和后台管理/">Solr 6.5.1集群部署和后台管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016-12-05/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hello/">Hello</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/个人心得/">个人心得</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/个人心得/" style="font-size: 15px;">个人心得</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/校招/" style="font-size: 15px;">校招</a> <a href="/tags/hello/" style="font-size: 15px;">hello</a> <a href="/tags/init/" style="font-size: 15px;">init</a> <a href="/tags/搜索引擎/" style="font-size: 15px;">搜索引擎</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/solr/" style="font-size: 15px;">solr</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zning.net.cn" title="张宁网" target="_blank">张宁网</a><ul></ul><a href="https://cloudups.github.io" title="凌云阁" target="_blank">凌云阁</a><ul></ul><a href="https://noahzu.github.io" title="Android资源开发小栈" target="_blank">Android资源开发小栈</a><ul></ul><a href="https://heinika.github.io/" title="陈利津" target="_blank">陈利津</a><ul></ul><a href="http://www.itfenghui.com/" title="SEO" target="_blank">SEO</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Coselding.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5f2780e77f78ddb4e621d840e6d71d90";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>