<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coselding</title>
  <subtitle>非淡泊无以明志，非宁静无以致远。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.coselding.cn/"/>
  <updated>2017-09-03T13:44:48.000Z</updated>
  <id>http://www.coselding.cn/</id>
  
  <author>
    <name>林宇强</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JStorm实时计算框架学习</title>
    <link href="http://www.coselding.cn/2017/09/03/JStorm%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%20%E2%80%94%E2%80%94%20%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.coselding.cn/2017/09/03/JStorm实时计算框架学习 —— 博客/</id>
    <published>2017-09-03T13:44:48.000Z</published>
    <updated>2017-09-03T13:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>这是一个JStorm使用教程，不包含环境搭建教程，直接在公司现有集群上跑任务，关于JStorm集群环境搭建，后续研究完会考虑额外写一篇博客。</li>
<li>你如果想了解JStorm是什么，有多牛逼什么什么的，请看最后的参考博客链接，里面有各种版本的介绍，我就不在这里总结这种东西了，我相信这些东西你第一次接触的时候会看，等学了JStorm之后也不会再去看这些东西了。。。</li>
</ul>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>JStorm和MapReduce的一些对比<br><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/compare-table.png" alt="compare-table.png"></li>
</ul>
<h3 id="一些关键概念"><a href="#一些关键概念" class="headerlink" title="一些关键概念"></a>一些关键概念</h3><ol>
<li>nimbus：主控节点运行Nimbus守护进程，类似于Hadoop中的ResourceManager，负责在集群中分发代码，对节点分配任务，并监视主机故障。</li>
<li>supervisor：每个工作节点运行Supervisor守护进程，负责监听工作节点上已经分配的主机作业，启动和停止Nimbus已经分配的工作进程，类似于Hadoop中的NodeManager。<br>supervisor会定时从zookeeper获取拓补信息topologies、任务分配信息assignments及各类心跳信息，以此为依据进行任务分配。<br>在supervisor同步时，会根据新的任务分配情况来启动新的worker或者关闭旧的worker并进行负载均衡。</li>
<li>worker：Worker是具体处理Spout/Bolt逻辑的进程，根据提交的拓扑中conf.setNumWorkers(3);定义分配每个拓扑对应的worker数量，Storm会在每个Worker上均匀分配任务，一个Worker只能执行一个topology，但是可以执行其中的多个任务线程。</li>
<li>task：任务是指Worker中每个Spout/Bolt线程，每个Spout和Bolt在集群中会执行许多任务，每个任务对应一个线程执行，可以通过TopologyBuilder类的setSpout()和setBolt()方法来设置每个Spout或者Bolt的并行度。</li>
<li>Executor：Task接收到任务就是在Executor中执行的，可以理解为执行Task专门的一个线程。</li>
<li>topology：Storm中Topology的概念类似于Hadoop中的MapReduce Job，是一个用来编排、容纳一组计算逻辑组件（Spout、Bolt）的对象（Hadoop MapReduce中一个Job包含一组Map Task、Reduce Task），这一组计算组件可以按照DAG图的方式编排起来（通过选择Stream Groupings来控制数据流分发流向），从而组合成一个计算逻辑更加负责的对象，那就是Topology。一个Topology运行以后就不能停止，它会无限地运行下去，除非手动干预（显式执行bin/storm kill ）或意外故障（如停机、整个Storm集群挂掉）让它终止。</li>
<li>spout：Storm中Spout是一个Topology的消息生产的源头，Spout应该是一个持续不断生产消息的组件，例如，它可以是一个Socket Server在监听外部Client连接并发送消息，可以是一个消息队列（MQ）的消费者、可以是用来接收Flume Agent的Sink所发送消息的服务，等等。Spout生产的消息在Storm中被抽象为Tuple，在整个Topology的多个计算组件之间都是根据需要抽象构建的Tuple消息来进行连接，从而形成流。</li>
<li>bolt：Storm中消息的处理逻辑被封装到Bolt组件中，任何处理逻辑都可以在Bolt里面执行，处理过程和普通计算应用程序没什么区别，只是需要根据Storm的计算语义来合理设置一下组件之间消息流的声明、分发、连接即可。Bolt可以接收来自一个或多个Spout的Tuple消息，也可以来自多个其它Bolt的Tuple消息，也可能是Spout和其它Bolt组合发送的Tuple消息。</li>
<li>tuple：JStorm中信息传输的单位，Storm程序是无限执行下去的，数据流是无止境的，但是每次驱动程序执行的只是一个数据流单位，就是Tuple，Spout的一次nextTuple以及Bolt的一次execute的执行操作的都是一个Tuple。Tuple只要是任意可序列化对象即可。</li>
</ol>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Topology生命周期"><a href="#Topology生命周期" class="headerlink" title="Topology生命周期"></a>Topology生命周期</h3><ol>
<li>上传代码并做校验（/nimbus/inbox）；</li>
<li>建立本地目录（/stormdist/topology-id/）；</li>
<li>建立zookeeper上的心跳目录；</li>
<li>计算topology的工作量（parallelism hint），分配task-id并写入zookeeper；</li>
<li>把task分配给supervisor执行；</li>
<li>在supervisor中定时检查是否有新的task，下载新代码、删除老代码，剩下的工作交个小弟worker；</li>
<li>在worker中把task拿到，看里面有哪些spout/Bolt，然后计算需要给哪些task发消息并建立连接；</li>
<li>在nimbus将topology终止的时候会将zookeeper上的相关信息删除；<br><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/topology-lifecycle.png" alt="topology-lifecycle.png"></li>
</ol>
<h3 id="Spout生命周期"><a href="#Spout生命周期" class="headerlink" title="Spout生命周期"></a>Spout生命周期</h3><h4 id="提交时"><a href="#提交时" class="headerlink" title="提交时"></a>提交时</h4><ol>
<li>构造方法：初始化构造参数，其中包含的必须都是可序列化的</li>
<li>getComponentConfiguration：获取该类特殊的配置参数，只和该组件相关的配置，通常<code>return null</code></li>
<li>declareOutputFields：获取该组件会输出的流、字段列表，其后续的其他组件订阅相应的流或者字段需要和这里对应，否则会出错</li>
<li>将内存中的该实例序列化为字节码文件。</li>
</ol>
<h4 id="在Worker节点中执行"><a href="#在Worker节点中执行" class="headerlink" title="在Worker节点中执行"></a>在Worker节点中执行</h4><ol>
<li>将传输过来的字节码文件反序列化为类实例</li>
<li>open：初始化这个组件类实例，可以加载消息队列消费端、JDBC链接池等非可序列化对象</li>
<li>activate：该实例设置为活跃状态（有数据流驱动时）调用，过段时间暂时没有数据流驱动就会睡眠</li>
<li>nextTuple：循环调用，可在这里从数据源获取数据emit到下一个节点，JStorm就会自动循环调用执行下去</li>
<li>ack：往后emit的一个Tuple在acker节点察觉成功了，回调通知Spout</li>
<li>fail：往后emit的一个Tuple在acker节点察觉失败或者超时了，回调通知Spout</li>
<li>deactivate：没数据流驱动达到一段时间，进入睡眠前调用</li>
<li>close：程序停止时调用，释放资源</li>
</ol>
<h3 id="Bolt生命周期"><a href="#Bolt生命周期" class="headerlink" title="Bolt生命周期"></a>Bolt生命周期</h3><h4 id="提交时-1"><a href="#提交时-1" class="headerlink" title="提交时"></a>提交时</h4><ol>
<li>构造方法：初始化构造参数，其中包含的必须都是可序列化的</li>
<li>getComponentConfiguration：获取该类特殊的配置参数，只和该组件相关的配置，通常<code>return null</code></li>
<li>declareOutputFields：获取该组件会输出的流、字段列表，其后续的其他组件订阅相应的流或者字段需要和这里对应，否则会出错</li>
<li>将内存中的该实例序列化为字节码文件。</li>
</ol>
<h4 id="在Worker节点中执行-1"><a href="#在Worker节点中执行-1" class="headerlink" title="在Worker节点中执行"></a>在Worker节点中执行</h4><ol>
<li>将传输过来的字节码文件反序列化为类实例</li>
<li>prepare：初始化这个组件类实例，可以加载配置，数据处理类初始化，数据输出对象初始化</li>
<li>execute：循环调用，可在这里从上个节点获取Tuple，进行相应处理之后emit到下一个节点，JStorm就会自动循环调用执行下去</li>
<li>cleanup：程序停止时调用，释放资源</li>
</ol>
<h2 id="数据流向控制"><a href="#数据流向控制" class="headerlink" title="数据流向控制"></a>数据流向控制</h2><p><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/jstorm-grouping.png" alt="jstorm-grouping.png"></p>
<ol>
<li>ShuffleGrouping：对符合条件的目标Worker，其中可能的多个Task，随机分配Task来接收和处理该Tuple</li>
<li>FieldsGrouping：会按照指定的field值进行分配，可以保证相同field对应值的Tuple分配到相同一个Task中执行 —— 可以想象成拿指定的field的值hash取模决定哪个Task（具体算法没研究）</li>
<li>除了这两个其他暂时没用到，也感觉剩下的比较用不到，等用了再更</li>
<li>具体的流的聚合和分发，参考这篇博客，例子很详细：<a href="http://shiyanjun.cn/archives/977.html" target="_blank" rel="external">JStorm流的汇聚和分发</a></li>
</ol>
<h2 id="数据流传输过程"><a href="#数据流传输过程" class="headerlink" title="数据流传输过程"></a>数据流传输过程</h2><ol>
<li>Spout中的数据源取出一份数据（无限循环取出），作为一个Tuple，emit到下一个节点</li>
<li>根据Spout中declareOutputFields定义的字段和流，查阅后继订阅该节点或者流的Bolt，Tuple会被发送到每个订阅节点或者流的后继节点当中</li>
<li>后继订阅的Bolt节点接收到该Tuple，使用<code>tuple.getValueByField</code>通过上一节点declareOutputFields的字段名获取相应的字段值，也可以根据fields的声明顺序使用<code>tuple.getValue</code>通过下标获取相应的值</li>
<li>拿到相应的数据之后，进行相关逻辑处理，之后emit到下一个节点当中，以此类推，直到最终节点将数据输出到mysql、ES、HDFS等存储系统当中</li>
<li>emit时可以指定相应的streamId来指定当前的数据要传输到的哪个streamId当中（该组件的declareOutputFields需要声明所需的所有streamId），在Topology构建时后继节点指定该streamId来订阅相应的数据。</li>
</ol>
<h2 id="编程例子讲解"><a href="#编程例子讲解" class="headerlink" title="编程例子讲解"></a>编程例子讲解</h2><ul>
<li>这个例子是一个单词计数程序，通过一组字符串数组中随机获取一个档次作为数据源往后输出，在后续节点统计各个单词被获取的总次数。</li>
<li>包括RandomSentenceSpout、SplitBolt、CountBolt三个节点，各个节点并行度都为1，是一个最简单的单条链式的拓扑，如下<br><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/jstorm-example.jpg" alt="jstorm-example.jpg"></li>
</ul>
<h3 id="RandomSentenceSpout"><a href="#RandomSentenceSpout" class="headerlink" title="RandomSentenceSpout"></a>RandomSentenceSpout</h3><ul>
<li>表示数据源，这里用从数组随机获取一个元素作为模拟数据源获取，日常开发通常是从MQ中获取相应数据进行数据流驱动。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * RandomSentenceSpout实现了IRichSpout接口</div><div class="line"> * Spout需要实现的接口可以是：</div><div class="line"> *    1,IRichSpout：最基本的Spout,继承自ISpout, IComponent,沒有任何特殊方法（一般用这个）</div><div class="line"> *    2,IControlSpout:继承自IComponent,包括open，close，activate，deactivate，nextTuple，ack(Object msgId)，fail等方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomSentenceSpout</span> <span class="keyword">implements</span> <span class="title">IRichSpout</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4058847280819269954L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(RandomSentenceSpout.class);</div><div class="line">    <span class="comment">//可以理解为JStorm的数据传输管道，通过这个对象将这个组件的数据传输到下一个组件当中</span></div><div class="line">    <span class="keyword">private</span> SpoutOutputCollector _collector;</div><div class="line">    <span class="comment">//随机生成对象</span></div><div class="line">    <span class="keyword">private</span> Random _rand;</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Spout初始化的时候调用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context, SpoutOutputCollector collector)</span> </span>&#123;</div><div class="line">        _collector = collector;</div><div class="line">        _rand = <span class="keyword">new</span> Random();</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 系统框架会不断调用</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextTuple</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//模拟数据源</span></div><div class="line">        String[] sentences = <span class="keyword">new</span> String[]&#123;<span class="string">"Hello world! This is my first programme of JStorm"</span>,</div><div class="line">                <span class="string">"Hello JStorm,Nice to meet you!"</span>, <span class="string">"Hi JStorm, do you have a really good proformance"</span>,</div><div class="line">                <span class="string">"Goodbye JStorm,see you tomorrow"</span>&#125;;</div><div class="line">        <span class="comment">//随机取出字符串</span></div><div class="line">        String sentence = sentences[_rand.nextInt(sentences.length)];</div><div class="line">        <span class="comment">//将得到的字符串输出到下一个组件</span></div><div class="line">        <span class="comment">//！！！这里Values中值填充顺序要和下面declareOutputFields中字段声明顺序一致</span></div><div class="line">        _collector.emit(<span class="keyword">new</span> Values(sentence), Time.currentTimeSecs());</div><div class="line">        Utils.sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ack</span><span class="params">(Object arg0)</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"ACK!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"ACTIVE!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deactivate</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Object arg0)</span> </span>&#123;</div><div class="line">        logger.debug(<span class="string">"FAILED!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 声明框架有哪些输出的字段</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        <span class="comment">//下一个组件通过word这个关键字拿到这个组件往后输出的单词sentence</span></div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getComponentConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SplitBolt"><a href="#SplitBolt" class="headerlink" title="SplitBolt"></a>SplitBolt</h3><ul>
<li>将获取的字符串通过空白符分割，并转为小写之后输出到下一个节点。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * IBasicBolt:继承自IComponent,包括prepare,execut,cleanup等方法</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7104767103420386784L</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(SplitBolt.class);</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * cleanup方法在bolt被关闭的时候调用， 它应该清理所有被打开的资源。（基本只能在local mode使用）</div><div class="line">     * 但是集群不保证这个方法一定会被执行。比如执行task的机器down掉了，那么根本就没有办法来调用那个方法。</div><div class="line">     * cleanup设计的时候是被用来在local mode的时候才被调用(也就是说在一个进程里面模拟整个storm集群),</div><div class="line">     * 并且你想在关闭一些topology的时候避免资源泄漏。</div><div class="line">     * （非 Javadoc）</div><div class="line">     * <span class="doctag">@see</span> backtype.storm.topology.base.BaseBasicBolt#cleanup()</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接收消息之后被调用的方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line">        <span class="comment">//以下两个方式获取前驱节点发送过来的sentence，一个根据fieldName，一个根据字段声明顺序</span></div><div class="line"><span class="comment">//        String sentence = input.getValueByField("word");</span></div><div class="line">        String sentence = input.getString(<span class="number">0</span>);</div><div class="line">        String[] words = sentence.split(<span class="string">"[,|\\s+]"</span>);</div><div class="line">        <span class="keyword">for</span> (String word : words) &#123;</div><div class="line">            word = word.trim();</div><div class="line">            <span class="comment">//将非空单词输出到下一个节点</span></div><div class="line">            <span class="keyword">if</span> (!word.isEmpty()) &#123;</div><div class="line">                word = word.toLowerCase();</div><div class="line">                collector.emit(<span class="keyword">new</span> Values(word));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * prepare方法在worker初始化task的时候调用.</div><div class="line">     *</div><div class="line">     * prepare方法提供给bolt一个Outputcollector用来发射tuple。</div><div class="line">     * Bolt可以在任何时候发射tuple — 在prepare, execute或者cleanup方法里面, 或者甚至在另一个线程里面异步发射。</div><div class="line">     * 这里prepare方法只是简单地把OutputCollector作为一个类字段保存下来给后面execute方法 使用。</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stromConf, TopologyContext context)</span> </span>&#123;</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * declearOutputFields方法仅在有新的topology提交到服务器,</div><div class="line">     * 用来决定输出内容流的格式(相当于定义spout/bolt之间传输stream的name:value格式),</div><div class="line">     * 在topology执行的过程中并不会被调用.</div><div class="line">     * （非 Javadoc）</div><div class="line">     * <span class="doctag">@see</span> backtype.storm.topology.IComponent#declareOutputFields(backtype.storm.topology.OutputFieldsDeclarer)</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CountBolt"><a href="#CountBolt" class="headerlink" title="CountBolt"></a>CountBolt</h3><ul>
<li>这个组件接收到的每个值都是单个单词，通过一个内存Map统计各个单词总数</li>
<li>后台设置一个异步线程10s一次输出当前Map中的各个单词总数</li>
<li>日常开发通常在这个终端节点将实时计算得到的结果输出到HDFS、mysql、HBase、ElasticSearch等存储系统当中<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountBolt</span> <span class="keyword">extends</span> <span class="title">BaseBasicBolt</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; counters;</div><div class="line">    <span class="keyword">private</span> String component;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = Logger.getLogger(CountBolt.class);</div><div class="line">    <span class="comment">//异步输出结果集的子线程</span></div><div class="line">    <span class="keyword">private</span> AsyncLoopThread statThread;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * On create</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(Map stormConf, TopologyContext context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.counters = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</div><div class="line">        <span class="keyword">this</span>.name = context.getThisComponentId();</div><div class="line">        <span class="keyword">this</span>.id = context.getThisTaskId();</div><div class="line">        <span class="comment">//异步循环输出结果集</span></div><div class="line">        <span class="keyword">this</span>.statThread = <span class="keyword">new</span> AsyncLoopThread(<span class="keyword">new</span> statRunnable());</div><div class="line"></div><div class="line">        LOG.info(stormConf.get(<span class="string">"abc"</span>) + <span class="string">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span>);</div><div class="line">        component = context.getThisComponentId();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareOutputFields</span><span class="params">(OutputFieldsDeclarer declarer)</span> </span>&#123;</div><div class="line">        declarer.declare(<span class="keyword">new</span> Fields(<span class="string">"word"</span>, <span class="string">"count"</span>));</div><div class="line">        <span class="comment">// declarer.declareStream("coord-"+"word-counter", new Fields("epoch","ebagNum"));</span></div><div class="line">        <span class="comment">// LOG.info("set stream coord-"+component);</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//接收消息之后被调用的方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Tuple input, BasicOutputCollector collector)</span> </span>&#123;</div><div class="line"><span class="comment">//        String str = input.getString(0);</span></div><div class="line">        String str = input.getStringByField(<span class="string">"word"</span>);</div><div class="line">        <span class="keyword">if</span> (!counters.containsKey(str)) &#123;</div><div class="line">            <span class="comment">//单词计数</span></div><div class="line">            counters.put(str, <span class="number">1</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//单词计数</span></div><div class="line">            Integer c = counters.get(str) + <span class="number">1</span>;</div><div class="line">            counters.put(str, c);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 异步输出结果集的死循环子线程</div><div class="line">     */</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">statRunnable</span> <span class="keyword">extends</span> <span class="title">RunnableCallback</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">10000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">                LOG.info(<span class="string">"\n-- Word Counter ["</span> + name + <span class="string">"-"</span> + id + <span class="string">"] --"</span>);</div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : counters.entrySet()) &#123;</div><div class="line">                    LOG.info(entry.getKey() + <span class="string">": "</span> + entry.getValue());</div><div class="line">                &#125;</div><div class="line">                LOG.info(<span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="WordCountTopology主入口，拓扑构建"><a href="#WordCountTopology主入口，拓扑构建" class="headerlink" title="WordCountTopology主入口，拓扑构建"></a>WordCountTopology主入口，拓扑构建</h3><ul>
<li>这里通过setSpout和setBolt将上面的三个节点连接成线 —— 即最开始说明的链式拓扑图</li>
<li>JStorm提交执行相关执行参数统一写入一个Properties或Yaml配置文件中，命令行执行第一个参数是该配置文件的路径<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountTopology</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOG = LoggerFactory.getLogger(WordCountTopology.class);</div><div class="line"></div><div class="line">    <span class="comment">//装载配置文件配置参数</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map conf = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</div><div class="line">            System.err.println(<span class="string">"Please input configuration file"</span>);</div><div class="line">            System.exit(-<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//加载配置文件配置到内存</span></div><div class="line">        LoadConf(args[<span class="number">0</span>]);</div><div class="line">        <span class="comment">//构建JStorm拓扑</span></div><div class="line">        TopologyBuilder builder = setupBuilder();</div><div class="line">        System.out.println(<span class="string">"Topology准备提交"</span>);</div><div class="line">        <span class="comment">//提交任务到集群</span></div><div class="line">        submitTopology(builder);</div><div class="line">        System.out.println(<span class="string">"Topology提交完成"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//!!!!这里通过setSpout和setBolt设置各个节点之间的连接关系，</span></div><div class="line">    <span class="comment">// 是这里把所有各自独立的节点用线连接起来，构建成一张具体的任务执行拓扑图</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TopologyBuilder <span class="title">setupBuilder</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 设置spout和bolt,完整参数为</div><div class="line">         * 1,spout的id(即name)</div><div class="line">         * 2,spout对象</div><div class="line">         * 3,executor数量即并发数，也就是设置多少个executor来执行spout/bolt(此项没有默认null)</div><div class="line">         */</div><div class="line">        <span class="comment">//setSpout，声明Spout名称Id为sentence-spout，并行度1</span></div><div class="line">        builder.setSpout(<span class="string">"sentence-spout"</span>, <span class="keyword">new</span> RandomSentenceSpout(), <span class="number">1</span>);</div><div class="line">        <span class="comment">//setBolt:SplitBolt的grouping策略是上层随机分发，CountBolt的grouping策略是按照上层字段分发</span></div><div class="line">        <span class="comment">//如果想要从多个Bolt获取数据，可以继续设置grouping</span></div><div class="line">        <span class="comment">//声明Bolt名称Id为split-bolt，并行度1</span></div><div class="line">        builder.setBolt(<span class="string">"split-bolt"</span>, <span class="keyword">new</span> SplitBolt(), <span class="number">1</span>)</div><div class="line">                <span class="comment">//设置该Bolt的数据源为sentence-spout的输出</span></div><div class="line">                .shuffleGrouping(<span class="string">"sentence-spout"</span>);</div><div class="line">        <span class="comment">//声明Bolt名称Id为count-bolt，并行度1</span></div><div class="line">        builder.setBolt(<span class="string">"count-bolt"</span>, <span class="keyword">new</span> CountBolt(), <span class="number">1</span>)</div><div class="line">                <span class="comment">//设置该Bolt的数据源为sentence-spout和split-bolt的输出</span></div><div class="line">                <span class="comment">//fieldsGrouping保证相同word对应的值发送到同一个Task节点，这是单词计数业务需要</span></div><div class="line">                .fieldsGrouping(<span class="string">"split-bolt"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>))</div><div class="line">                .fieldsGrouping(<span class="string">"sentence-spout"</span>, <span class="keyword">new</span> Fields(<span class="string">"word"</span>));</div><div class="line">        <span class="keyword">return</span> builder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//提交任务到JStorm集群</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">submitTopology</span><span class="params">(TopologyBuilder builder)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (local_mode(conf)) &#123;<span class="comment">//本地模式，需要有本地JStorm环境支持</span></div><div class="line">                LocalCluster cluster = <span class="keyword">new</span> LocalCluster();</div><div class="line">                cluster.submitTopology(</div><div class="line">                        String.valueOf(conf.get(<span class="string">"topology.name"</span>)), conf,</div><div class="line">                        builder.createTopology());</div><div class="line"></div><div class="line">                Thread.sleep(<span class="number">200000</span>);</div><div class="line">                cluster.shutdown();</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                StormSubmitter.submitTopology(</div><div class="line">                        String.valueOf(conf.get(<span class="string">"topology.name"</span>)), conf,</div><div class="line">                        builder.createTopology());</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            LOG.error(e.getMessage(), e.getCause());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//加载Properties配置文件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadProperty</span><span class="params">(String prop)</span> </span>&#123;</div><div class="line">        Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = <span class="keyword">new</span> FileInputStream(prop);</div><div class="line">            properties.load(stream);</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"No such file "</span> + prop);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        conf.putAll(properties);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//加载Yaml配置文件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadYaml</span><span class="params">(String confPath)</span> </span>&#123;</div><div class="line">        Yaml yaml = <span class="keyword">new</span> Yaml();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = <span class="keyword">new</span> FileInputStream(confPath);</div><div class="line">            conf = (Map) yaml.load(stream);</div><div class="line">            <span class="keyword">if</span> (conf == <span class="keyword">null</span> || conf.isEmpty() == <span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to read config file"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            System.out.println(<span class="string">"No such file "</span> + confPath);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No config file"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to read config file"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//根据后缀名选择加载配置文件方案</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadConf</span><span class="params">(String arg)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (arg.endsWith(<span class="string">"yaml"</span>)) &#123;</div><div class="line">            LoadYaml(arg);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            LoadProperty(arg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">local_mode</span><span class="params">(Map conf)</span> </span>&#123;</div><div class="line">        String mode = (String) conf.get(Config.STORM_CLUSTER_MODE);</div><div class="line">        <span class="keyword">if</span> (mode != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (mode.equals(<span class="string">"local"</span>)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="批量用法"><a href="#批量用法" class="headerlink" title="批量用法"></a>批量用法</h2><p>基本的用法是每次处理一个tuple，但是这种效率比较低，很多情况下是可以批量获取消息然后一起处理，批量用法对这种方式提供了支持。打开代码可以很明显地发现jstorm和storm的有着不小的区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// storm 中的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBatchSpout</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Map conf, TopologyContext context)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emitBatch</span><span class="params">(<span class="keyword">long</span> batchId, TridentCollector collector)</span></span>;<span class="comment">// 批次发射tuple</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ack</span><span class="params">(<span class="keyword">long</span> batchId)</span></span>; <span class="comment">// 成功处理批次</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Map <span class="title">getComponentConfiguration</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">Fields <span class="title">getOutputFields</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// jstorm中的定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBatchSpout</span> <span class="keyword">extends</span> <span class="title">IBasicBolt</span>, <span class="title">ICommitter</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外如果用批次的话就需要改用BatchTopologyBuilder来构建拓扑结构，在IBatchSpout中主要实现的接口如下：</p>
<ol>
<li>execute：虽然和IBolt中名字、参数一致，但是增加了一些默认逻辑<blockquote>
<ul>
<li>入参的input.getValue(0)表示批次（BatchId）。</li>
<li>发送消息时collector.emit(new Values(batchId, value))，发送的列表第一个字段表示批次（BatchId）。</li>
</ul>
</blockquote>
</li>
<li>commit：批次成功时调用，常见的是修改offset。</li>
<li>revert：批次失败时调用，可以在这里根据offset取出批次数据进行重试。</li>
</ol>
<h2 id="Ack机制"><a href="#Ack机制" class="headerlink" title="Ack机制"></a>Ack机制</h2><ul>
<li>为保证无数据丢失，Storm/JStorm使用了非常漂亮的可靠性处理机制，如图当定义Topology时指定Acker，JStorm除了Topology本身任务外，还会启动一组称为Acker的特殊任务，负责跟踪Topolgogy DAG中的每个消息。每当发现一个DAG被成功处理完成，Acker就向创建根消息的Spout任务发送一个Ack信号。Topology中Acker任务的并行度默认parallelism hint=1，当系统中有大量的消息时，应该适当提高Acker任务的并行度。</li>
<li>Acker按照Tuple Tree的方式跟踪消息。当Spout发送一个消息的时候，它就通知对应的Acker一个新的根消息产生了，这时Acker就会创建一个新的Tuple Tree。当Acker发现这棵树被完全处理之后，他就会通知对应的Spout任务。</li>
<li>Acker任务保存了数据结构<code>Map&lt;MessageID,Map&lt; TaskID, Value&gt;&gt;</code>，其中MessageID是Spout根消息ID，TaskID是Spout任务ID，Value表示一个64bit的长整型数字，是树中所有消息的随机ID的异或结果。通过TaskID，Acker知道当消息树处理完成后通知哪个Spout任务，通过MessageID，Acker知道属于Spout任务的哪个消息被成功处理完成。Value表示了整棵树的的状态，无论这棵树多大，只需要这个固定大小的数字就可以跟踪整棵树。当消息被创建和被应答的时候都会有相同的MessageID发送过来做异或。当Acker发现一棵树的Value值为0的时候，表明这棵树已经被成功处理完成。</li>
<li>举例说明具体流程，以下为拓扑：<br><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/ack-example.jpg" alt="ack-example.jpg"></li>
<li>Acker数据的变化过程：（算法）<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Step1：A发送T0给B后：</div><div class="line">产生一个随机数r0，树种存R0：R0=r0</div><div class="line">&lt;id0,&lt;taskA,R0&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step2.B接收到T0并成功处理后向C发送T1，向D发送T2：</div><div class="line">接收到上级传过来的R0，自己传给两个下家，产生两个随机数代表下家存入树中：R1=R0^r1^r2=r0^r1^r2</div><div class="line">&lt;id0,&lt;taskA,R0^R1&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r0^r0^r1^r2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r1^r2&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step3.C接收到T1并成功处理后：</div><div class="line">接收到上家传过来的r1，没有下家：R2=r1</div><div class="line">&lt;id0,&lt;taskA,r1^r2^R2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r1^r2^r1&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r2&gt;&gt;</div><div class="line"><span class="comment"># ---------</span></div><div class="line">Step4.D接收到T2并成功处理后：</div><div class="line">接收到上家传过来的r2，没有下家：R3=r2</div><div class="line">&lt;id0,&lt;taskA,r2^R3&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,r2^r2&gt;&gt;</div><div class="line">=&lt;id0,&lt;taskA,0&gt;&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当结果为0时Acker可以通知taskA根消息id0的消息树已被成功处理完成，调用Spout的ack方法通知，若超时发现消息树中值不为0，调用Spout中的fail。</p>
<ul>
<li>整体节点间通信：<br><img src="/2017/09/03/JStorm实时计算框架学习 —— 博客/jstorm-ack.png" alt="jstorm-ack.png"></li>
</ul>
<blockquote>
<ul>
<li>需要指出的是，Acker并不是必须的，当实际业务可以容忍数据丢失情况下可以不用Acker，对数据丢失零容忍的业务必须打开Acker，另外当系统的消息规模较大是可适当增加Acker的并行度。</li>
</ul>
</blockquote>
<h2 id="JStorm事务"><a href="#JStorm事务" class="headerlink" title="JStorm事务"></a>JStorm事务</h2><p>事务拓扑并不是新的东西，只是在原始的ISpout、IBolt上做了一层封装。在事务拓扑中以并行（processing）和顺序（commiting）混合的方式来完成任务，使用Transactional Topology可以保证每个消息只会成功处理一次。不过需要注意的是，在Spout需要保证能够根据BatchId进行多次重试，在<a href="https://github.com/alibaba/jstorm/blob/master/example/sequence-split-merge/src/main/java/com/alipay/dw/jstorm/transcation/TransactionalGlobalCount.java" target="_blank" rel="external">这里</a>有一个基本的例子，<a href="http://ifeve.com/getting-started-of-storm8/" target="_blank" rel="external">这里</a>有一个不错的讲解。</p>
<h2 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h2><pre><code>这次一种更高级的抽象（甚至不需要知道底层是怎么map-reduce的），所面向的不再是spout和bolt，而是stream。主要涉及到下面几种接口：
</code></pre><ol>
<li>在本地完成的操作<blockquote>
<ul>
<li>Function：自定义操作。</li>
<li>Filters：自定义过滤。</li>
<li>partitionAggregate：对同批次的数据进行local combiner操作。</li>
<li>project：只保留stream中指定的field。</li>
<li>stateQuery、partitionPersist：查询和持久化。</li>
</ul>
</blockquote>
</li>
<li>决定Tuple如何分发到下一个处理环节<blockquote>
<ul>
<li>shuffle：随机。</li>
<li>broadcast：广播。</li>
<li>partitionBy：以某一个特定的field进行hash，分到某一个分区，这样该field位置相同的都会放到同一个分区。</li>
<li>global：所有tuple发到指定的分区。</li>
<li>batchGlobal：同一批的tuple被放到相同的分区（不同批次不同分区）。</li>
<li>partition：用户自定义的分区策略。</li>
</ul>
</blockquote>
</li>
<li>不同partition处理结果的汇聚操作<blockquote>
<ul>
<li>aggregate：只针对同一批次的数据。</li>
<li>persistentAggregate：针对所有批次进行汇聚，并将中间状态持久化。</li>
</ul>
</blockquote>
</li>
<li>对stream中的tuple进行重新分组，后续的操作将会对每一个分组独立进行（类似sql中的group by）<blockquote>
<ul>
<li>groupBy</li>
</ul>
</blockquote>
</li>
<li>将多个Stream融合成一个<blockquote>
<ul>
<li>merge：多个流进行简单的合并。</li>
<li>join：多个流按照某个KEY进行UNION操作（只能针对同一个批次的数据）。</li>
</ul>
</blockquote>
</li>
</ol>
<p>在<a href="http://gitlab.alibaba-inc.com/aloha/aloha-utility/blob/master/metaspout/src/main/java/com/alibaba/aloha/meta/example/TestTridentTopology.java#L11" target="_blank" rel="external">这里</a>有一个jstorm中使用Trident的简单例子。</p>
<h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><ol>
<li><p>节点故障</p>
<ul>
<li>Nimbus故障。Nimbus本身无状态，所以Nimbus故障不会影响正在正常运行任务，另外Nimbus HA保证Nimbus故障后可以及时被备份Nimbus接管。</li>
<li>Supervisors节点故障。Supervisor故障后，Nimbus会将故障节点上的任务迁移到其他可用节点上继续运行，但是Supervisor故障需要外部监控并及时手动重启。</li>
<li>Worker故障。Worker健康状况监控由Supervisor负责，当Woker出现故障时，Supervisor会及时在本机重试重启。</li>
<li>Zookeeper节点故障。Zookeeper本身具有很好的故障恢复机制，能保证至少半数以上节点在线就可正常运行，及时修复故障节点即可。</li>
</ul>
</li>
<li><p>任务失败</p>
<ul>
<li>Spout失败。消息不能被及时被Pull到系统中，造成外部大量消息不能被及时处理，而外部大量计算资源空闲。</li>
<li>Bolt失败。消息不能被处理，Acker持有的所有与该Bolt相关的消息反馈值都不能回归到0，最后因为超时最终Spout的fail将被调用。</li>
<li>Acker失败。Acker持有的所有反馈信息不管成功与否都不能及时反馈到Spout，最后同样因为超时Spout的fail将被调用。</li>
<li>任务失败后，需要Nimbus及时监控到并重新分配失败任务。</li>
</ul>
</li>
</ol>
<h2 id="JStorm使用感受"><a href="#JStorm使用感受" class="headerlink" title="JStorm使用感受"></a>JStorm使用感受</h2><ol>
<li>JStorm各个节点之间是松耦合的，各个节点之间的通信只和Tuple数据流结构相关，其他处理逻辑各自独立</li>
<li>JStorm不处理数据的存储服务，计算结果自行存储到HDFS、HBase、Mysql、ElasticSearch等存储系统当中</li>
<li>JStorm的拓扑节点设计中，应该把延时操作分发到多个节点当中执行，每个节点只处理各自单一的功能逻辑，如上面的例子，我把单词分割和单词计数分成两个Bolt来实现，这才是流式计算的特点，让数据流动起来，而不是在一个节点完成所有工作，也保证了程序可用性更强</li>
<li>JStorm各个节点内部的处理逻辑非常开放，想怎么处理都行，只要最终往后输出相应的Tuple即可，编程时非常自由，不像MapReduce，很多操作都在MR模型中得到限制</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.cnblogs.com/hzorac/p/5570723.html" target="_blank" rel="external">ACK机制过程详解和故障恢复过程</a></li>
<li><a href="http://www.jstorm.io/" target="_blank" rel="external">官网文档</a></li>
<li><a href="http://www.cnblogs.com/antispam/p/4182210.html" target="_blank" rel="external">JSTORM使用笔记</a></li>
<li><a href="https://github.com/alibaba/jstorm" target="_blank" rel="external">JStorm开源地址</a></li>
<li><a href="http://shiyanjun.cn/archives/977.html" target="_blank" rel="external">JStorm流的汇聚和分发</a></li>
<li><a href="http://www.cnblogs.com/panfeng412/archive/2012/06/04/storm-common-patterns-of-stream-join.html" target="_blank" rel="external">Storm常见模式——流聚合（类似并发包中的栅栏）</a></li>
<li><a href="http://ifeve.com/getting-started-with-storm-5/" target="_blank" rel="external">锚定anchors的使用</a></li>
<li><a href="http://ifeve.com/getting-started-with-storm-2/" target="_blank" rel="external">并发编程网Storm入门</a></li>
<li></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;这是一个JStorm使用教程，不包含环境搭建教程，直接在公司现有集群上跑任务，关于JStorm集群环境搭建，后续研究完会考虑额外写一篇博客。&lt;/li&gt;
&lt;li&gt;你如果想了解JStorm是什么，有多牛逼什么什么的，请看最后的参考博客链接，
    
    </summary>
    
      <category term="实时计算" scheme="http://www.coselding.cn/categories/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="实时计算" scheme="http://www.coselding.cn/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/"/>
    
      <category term="java" scheme="http://www.coselding.cn/tags/java/"/>
    
      <category term="JStorm" scheme="http://www.coselding.cn/tags/JStorm/"/>
    
      <category term="流式计算" scheme="http://www.coselding.cn/tags/%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>Solr 6.5.1集群部署和后台管理</title>
    <link href="http://www.coselding.cn/2017/05/25/Solr6.5.1%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E5%92%8C%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86/"/>
    <id>http://www.coselding.cn/2017/05/25/Solr6.5.1集群部署和后台管理/</id>
    <published>2017-05-25T11:54:48.000Z</published>
    <updated>2017-05-25T11:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>两年前用过solr5.1版本的，当时只是简单入个门，拿来在项目里建个全文索引，然后再query，其他什么也没做，还是傻傻地自己去配Tomcat，这次做毕设因为需求而重拾solr，基于作死折腾的原则，肯定要用最新版的啦~，然后。。。还是很顺利踩到坑了，schema相关配置变了。。。配置变了。。。置变了。。。变了。。。了。。。不过还是很快解决了，当然这次打算把集群高可用相关也折腾折腾、还有和mysql之间的配合和索引同步，所以新写一篇看起来不那么low的博客出来（之前写过一篇弱文。。。）</li>
</ul>
</blockquote>
<h2 id="下载和初始化启动"><a href="#下载和初始化启动" class="headerlink" title="下载和初始化启动"></a>下载和初始化启动</h2><p><strong>官网下载6.5.1版本的solr，解压</strong></p>
<h5 id="目录说明："><a href="#目录说明：" class="headerlink" title="目录说明："></a>目录说明：</h5><ul>
<li>bin：启动脚本</li>
<li>contrib：第三方贡献拓展jar包，包括一些第三方分词器</li>
<li>dist：一些最终生成的jar包，主要是solrj客户端jar包</li>
<li>docs：文档</li>
<li>example：一些样例，example-DIH目录下的是一些solr索引core样例</li>
<li>server：solr服务端工作目录，自带集成jetty插件方式启动solr服务器</li>
<li><ul>
<li>solr：solr搜索引擎工作目录，即solr/home</li>
</ul>
</li>
<li><ul>
<li>solr-webapp：solr后台管理页面webapp</li>
</ul>
</li>
<li><ul>
<li>start.jar：服务端启动jar包</li>
</ul>
</li>
</ul>
<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><ol>
<li>contrib/analysis-extras/lucene-libs：这个目录下是第三方分词器jar，将其拷贝到server/solr-webapp/webapp/WEB-INF/lib下供webapp使用</li>
<li><p>dist/solrj-lib：这里是solrj客户端的依赖jar包，使用maven的话用如下坐标即可</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.solr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>solr-solrj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>example/example-DIH/solr：该目录下自带了初始的五个索引库core，将其拷贝到server/solr目录下，solr服务端启动才会自动引入core到系统中（solr.xml不要复制）</p>
</li>
<li>server/solr：步骤3拷贝过来的五个core中有conf一系列配置文件可以配置这个core相关参数，后面专门细讲</li>
</ol>
<h5 id="索引库core配置"><a href="#索引库core配置" class="headerlink" title="索引库core配置"></a>索引库core配置</h5><p>到配置好的server/solr目录下，找到db目录为例，db/conf目录下一堆的配置文件，主要配置的为如下：</p>
<ul>
<li>db/lib：存放该core需要的额外jar，比如第三方分词器，在该目录下的分词器中的类可以在schema配置时直接全限定类名引入</li>
<li>db/conf/managed-schema：schema配置文件，该文件为系统REST API配置时系统的合成文件，不建议手动修改</li>
<li>db/conf/schema.xml：我自己把managed-schema复制一份重命名的，用于手动配置schema</li>
<li>db/conf/solrconfig.xml：该core的总配置文件</li>
</ul>
<p><strong>说明</strong></p>
<blockquote>
<ul>
<li>系统生成和手动编辑可能产生重叠，系统生成的编辑可能会删除注释或者其他帮助理解域、域类型的关键性的自定义内容。你可能希望通过源码控制标记（配置）文件的版本，或者同时限制手动编辑。<br>Solrconfig.xml允许Solr schema被定义为“被管理的索引模式”：只能通过Schema API修改schema。</li>
<li>managed-schema是solr开始才有的schema配置文件，它是用来避免API方式配置schema和手动修改schema配置文件之间的冲突（比如说重复字段名），因此这个文件不建议手动修改</li>
<li>可以把managed-schema复制一份schema.xml，然后在这个文件手动配置schema</li>
<li>这两个schema配置文件solr系统如何识别呢？答案是两个配置是不能同时生效的，系统默认使用managed-schema，支持REST API方式动态配置schema，适合有动态配置schema、field、fieldType之类需求的就使用这个配置，什么都不改即可。</li>
<li>若项目没有动态修改schema的需求，那可以使用schema.xml进行配置，在其中可以很方便根据schema配置语法进行个性化自定义，方便编码，若要schema.xml生效，需要按照如下步骤修改db/conf/solrconfig.xml的配置：</li>
</ul>
</blockquote>
<ol>
<li><p>找到如下配置(6.5.1其实默认没有这个配置，自己直接添加就行)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">schemaFactory</span> <span class="attr">class</span>=<span class="string">"ManagedIndexSchemaFactory"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"mutable"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"managedSchemaResourceName"</span>&gt;</span>managed-schema<span class="tag">&lt;/<span class="name">str</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">schemaFactory</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>替换成：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">schemaFactory</span> <span class="attr">class</span>=<span class="string">"ClassicIndexSchemaFactory"</span>/&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="Schema手动配置Field和FieldType"><a href="#Schema手动配置Field和FieldType" class="headerlink" title="Schema手动配置Field和FieldType"></a>Schema手动配置Field和FieldType</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 配置一个新field，设定类型 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"text_smart"</span> <span class="attr">type</span>=<span class="string">"text_smart"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 配置一个新的类型，指定分词器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_smart"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span> <span class="attr">positionIncrementGap</span>=<span class="string">"0"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"title"</span> <span class="attr">type</span>=<span class="string">"text_smart"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"text_all"</span> <span class="attr">type</span>=<span class="string">"text_smart"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"filename"</span> <span class="attr">type</span>=<span class="string">"text_smart"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"filecontent"</span> <span class="attr">type</span>=<span class="string">"text_smart"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 为多个field指定一个共同的别名，通过这个别名进行query就能够同时对所有field进行搜索 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"title"</span> <span class="attr">dest</span>=<span class="string">"text_all"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"text_smart"</span> <span class="attr">dest</span>=<span class="string">"text_all"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"filename"</span> <span class="attr">dest</span>=<span class="string">"text_all"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"filecontent"</span> <span class="attr">dest</span>=<span class="string">"text_all"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">copyField</span> <span class="attr">source</span>=<span class="string">"id"</span> <span class="attr">dest</span>=<span class="string">"text_all"</span>/&gt;</span></div></pre></td></tr></table></figure>
<h5 id="启动solr"><a href="#启动solr" class="headerlink" title="启动solr"></a>启动solr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/solr start</div></pre></td></tr></table></figure>
<p>启动如下：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-start.png" alt="image"><br>浏览器访问<a href="http://localhost:8983/" target="_blank" rel="external">http://localhost:8983/</a>，如下：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-admin.png" alt="image"></p>
<h5 id="关闭solr"><a href="#关闭solr" class="headerlink" title="关闭solr"></a>关闭solr</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/solr stop</div></pre></td></tr></table></figure>
<p>关闭如下：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-stop.png" alt="image"></p>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h5 id="Solr集群架构图"><a href="#Solr集群架构图" class="headerlink" title="Solr集群架构图"></a>Solr集群架构图</h5><p><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-cloud-struct.png" alt="image"></p>
<ul>
<li>图的上半部分是物理结构，一看就清楚，需要关注的是每个机器节点都可以有多个core，这个和下面的逻辑结构有比较大的联系。</li>
<li>下半部分逻辑结构：一个Collection就是一个完整的索引集，可以理解为一个索引文件，Shard1和Shard2就是该索引集的多个分片，就是说把完整的一个索引文件分成了多个，类似数据库分库分表，不过你在访问的时候只需要访问Collection即可，内部分片和索引所在的分片位置不需要关心，这样对不同个分片的访问就可以分流到不同机器上就行处理，也避免了单个索引文件无限膨胀的可能。</li>
<li>再往上就是副本，每个Shard都可以有多个副本，类比数据库读写分离，写操作由Master节点接收，并自动同步到Slave节点，当一个Master节点宕机，就会自动选举一个Slave节点重新承担Master的功能，这里的每个副本就如图所示，对应每个Solr节点的一个Core，这样逻辑和物理之间的联系就建立起来了。</li>
</ul>
<h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><ul>
<li>SolrCloud集群由ZooKeeper进行协调，集群中所有节点使用ZooKeeper中共有的配置文件，这样就能保证各个节点之间的配置统一。</li>
<li>SolrCloud节点宕机、Master选举等都通过ZooKeeper的分布式协调实现，所以说SolrJ的访问地址也是ZooKeeper的地址。</li>
</ul>
<h5 id="SolrCloud集群部署"><a href="#SolrCloud集群部署" class="headerlink" title="SolrCloud集群部署"></a>SolrCloud集群部署</h5><blockquote>
<ul>
<li><p>这里比较重要了，由于Solr的版本间兼容性较差，又因为我这是当前最新版，因此在集群部署过程中遇到很多坑，主要是查的资料各种版本都有，还分成tomcat和jetty两种部署方式，搞得我在试验各种方案的过程中浪费了很多时间，好在最后让我找到了一个比较可靠的博客，很详细地用最简单的jetty方式部署，其实从各方面性能看，jetty不比tomcat差，而且现在都流行直接nginx反向代理和负载均衡以及微服务，我反而更喜欢jetty了。。。</p>
</li>
<li><p>先贴教程:<a href="http://www.zhangrenhua.com/2016/06/17/Solr6.0.1%E6%A6%82%E5%BF%B5%E5%92%8C%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" target="_blank" rel="external">Solr6.0.1概念和集群部署</a></p>
</li>
</ul>
</blockquote>
<ol>
<li>ZooKeeper集群部署，这在我之前的博客有，需要的自行查看，我就直接那部署好的ZooKeeper来用而已：<a href="http://www.jianshu.com/p/5e012efb2d82" target="_blank" rel="external">ZooKeeper配置和学习笔记</a></li>
<li>官网下载solr-6.5.1.tgz，解压并到该目录下</li>
<li>上传配置文件到ZooKeeper（之后整个集群所有机器就是共用这套配置文件了）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/solr zk -z localhost:2181/solr -upconfig -n solr <span class="_">-d</span> example/example-DIH/solr/solr</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参数说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-upconfig      表示把你的配置文件上传到ZooKeeper集群</div><div class="line">-n configName  指定这个配置的名称，solr管理页面会用到</div><div class="line"><span class="_">-d</span> confdir     要上传的配置文件在本地的地址，默认使用解压的example/example-DIH/solr/solr即可，若有配置需求的，可实现修改相应的配置，再上传到ZooKeeper（配置方法同上面的单节点模式）</div><div class="line">-z zkHost      Zookeeper集群地址</div></pre></td></tr></table></figure></p>
<ol>
<li>把刚才解压的整个solr-6.5.1目录额外复制两份（伪分布式，你若有多台机器可考虑真实分布式部署）</li>
<li>启动solr节点服务：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/solr start -c -m 1g -z localhost:2181/solr -p 8983</div></pre></td></tr></table></figure>
</li>
</ol>
<p>参数说明：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-c：cloud模式启动</div><div class="line">-m：最大内存使用</div><div class="line">-z：zookeeper集群地址</div><div class="line">-p：启动服务端口</div></pre></td></tr></table></figure></p>
<ol>
<li><p>相同方式启动另外两个节点：（端口号错开）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">solr-2/bin/solr start -c -m 1g -z localhost:2181/solr -p 8984</div><div class="line">solr-2/bin/solr start -c -m 1g -z localhost:2181/solr -p 8985</div></pre></td></tr></table></figure>
</li>
<li><p>浏览器访问：<a href="http://localhost:8983/solr/#/" target="_blank" rel="external">http://localhost:8983/solr/#/</a></p>
</li>
<li><p>如图创建Collection：<img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr6.0.1-collections-addCollection.png" alt="image"></p>
<blockquote>
<ul>
<li>配置参数说明：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">name： 待创建Collection的名称</div><div class="line">config <span class="built_in">set</span>： collection在zookeeper中的配置目录</div><div class="line">numShards： 分片的数量</div><div class="line">replicationFactor： 复制副本的数量</div><div class="line">maxShardsPerNode：默认值为1，注意三个数值：numShards、replicationFactor、liveSolrNode，一个正常的solrCloud集群不容许同一个liveSolrNode上部署同一个shard的多个replic，因此当maxShardsPerNode=1时，numShards*replicationFactor&gt;liveSolrNode时，报错。因此正确时因满足以下条件：</div><div class="line">numShards*replicationFactor&lt;liveSolrNode*maxShardsPerNode</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p>查看各个节点和分片的关系图：<img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-collection-graph.png" alt="image"></p>
<blockquote>
<ul>
<li>至此，SolrCloud集群部署完成。</li>
<li>可以看到solr2这个Collection有shard1、shard2、shard3三个分片，每个分片有两个副本，一个Master、一个Slave，黑点为当前处于Master的副本节点。</li>
<li>这时候我们随便打开一个solr节点的目录server/solr，如下：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-node-date.png" alt="image"></li>
<li>可知，刚才管理界面创建的Collection节点的分片以core的形式存在于每个节点的core列表目录下，进入其中一个文件夹查看：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-node-date-dir.png" alt="image"></li>
<li>只有core.properties和data，上面的单节点模式每个core目录下还有lib和conf的，但是这里没有，下面图示说明：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/Solr-Cloud-Core.png" alt="image"></li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="客户端访问操作"><a href="#客户端访问操作" class="headerlink" title="客户端访问操作"></a>客户端访问操作</h2><h5 id="单节点访问"><a href="#单节点访问" class="headerlink" title="单节点访问"></a>单节点访问</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Solrj客户端工具类，实现对Solr服务的创建索引和查找操作</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> linyuqiang 2017/05/10</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolrClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Solr本地地址</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String url = <span class="string">"http://localhost:8983/solr/db"</span>;</div><div class="line">    <span class="comment">//查询字符串key</span></div><div class="line">    <span class="keyword">private</span> String searchKey = <span class="string">"text_all"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> highlighting = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">private</span> String highlightingPre = <span class="string">"&lt;em&gt;"</span>;</div><div class="line">    <span class="keyword">private</span> String highlightingPost = <span class="string">"&lt;/em&gt;"</span>;</div><div class="line">    <span class="keyword">private</span> String highlightingField = <span class="string">"content"</span>;</div><div class="line">    <span class="comment">// Solr客户端对象</span></div><div class="line">    <span class="keyword">private</span> HttpSolrClient client;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> SolrClient <span class="title">open</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 1.创建SolrServer对象，以下这两个是线程安全的SolrServer实现类</span></div><div class="line">        <span class="comment">// CommonsHttpSolrServer 基于Http协议进行C/S数据交互</span></div><div class="line">        <span class="comment">// EmbeddedSolrServer</span></div><div class="line">        <span class="comment">// 内嵌式，只要设定好solr的home目录即可实现和solr的交互，不需要开启solr的服务器，本地交互</span></div><div class="line">        client = <span class="keyword">new</span> HttpSolrClient(url);</div><div class="line">        client.setSoTimeout(<span class="number">10000</span>); <span class="comment">// socket read timeout</span></div><div class="line">        client.setConnectionTimeout(<span class="number">1000</span>);</div><div class="line">        client.setDefaultMaxConnectionsPerHost(<span class="number">100</span>);</div><div class="line">        client.setMaxTotalConnections(<span class="number">100</span>);</div><div class="line">        client.setFollowRedirects(<span class="keyword">false</span>); <span class="comment">// defaults to false</span></div><div class="line">        <span class="comment">// allowCompression defaults to false.</span></div><div class="line">        <span class="comment">// Server side must support gzip or deflate for this to have any effect.</span></div><div class="line">        client.setAllowCompression(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 查找,分页查询</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> qString 查找字符串</div><div class="line">     * <span class="doctag">@return</span> 返回查询结果列表</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;SolrjMessage&gt; <span class="title">search</span><span class="params">(String qString, Integer pageNum, Integer pageSiez)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            SolrQuery query = <span class="keyword">new</span> SolrQuery(searchKey + <span class="string">":"</span> + qString);<span class="comment">// 查询字符串</span></div><div class="line">            query.setStart((pageNum - <span class="number">1</span>) * pageSiez);<span class="comment">// 设置查询开始下标</span></div><div class="line">            query.setRows(pageSiez);<span class="comment">// 查询行数</span></div><div class="line"></div><div class="line">            <span class="comment">//高亮配置</span></div><div class="line">            query.setHighlight(highlighting);</div><div class="line">            query.setHighlightSimplePre(highlightingPre);</div><div class="line">            query.setHighlightSimplePost(highlightingPost);</div><div class="line">            query.addHighlightField(highlightingField);</div><div class="line"></div><div class="line">            QueryResponse response = client.query(query);<span class="comment">// 获取查询返回对象</span></div><div class="line"></div><div class="line">            SolrDocumentList docs = response.getResults();<span class="comment">// 获取查询得到的所有Document</span></div><div class="line">            <span class="comment">//查询高亮信息</span></div><div class="line">            Map&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; highlightings = response.getHighlighting();</div><div class="line">            List&lt;SolrjMessage&gt; list = <span class="keyword">new</span> ArrayList&lt;SolrjMessage&gt;();</div><div class="line">            <span class="keyword">for</span> (SolrDocument doc : docs) &#123;</div><div class="line">                <span class="comment">// 获取每个Document的详细信息</span></div><div class="line">                SolrjMessage message = <span class="keyword">new</span> SolrjMessage();</div><div class="line">                message.setId((String) doc.getFieldValue(<span class="string">"id"</span>));</div><div class="line">                message.setUrl((String) doc.getFieldValue(<span class="string">"url"</span>));</div><div class="line"></div><div class="line">                <span class="comment">//高亮信息</span></div><div class="line">                List&lt;String&gt; hights = highlightings.get(message.getId() + <span class="string">""</span>).get(highlightingField);</div><div class="line">                StringBuilder highlighting = <span class="keyword">new</span> StringBuilder();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hights.size(); i++) &#123;</div><div class="line">                    highlighting.append(hights.get(i)).append(<span class="string">" "</span>);</div><div class="line">                &#125;</div><div class="line">                message.setHighlighting(highlighting.toString());</div><div class="line"></div><div class="line">                list.add(message);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//其他查询信息</span></div><div class="line">            NamedList responseHeader = response.getResponseHeader();</div><div class="line">            SimpleOrderedMap params = (SimpleOrderedMap) responseHeader.get(<span class="string">"params"</span>);</div><div class="line">            NamedList&lt;Object&gt; responseResponse = response.getResponse();</div><div class="line">            SolrDocumentList responseBean = (SolrDocumentList) responseResponse.get(<span class="string">"response"</span>);</div><div class="line"></div><div class="line">            <span class="keyword">int</span> qTime = response.getQTime();</div><div class="line">            <span class="keyword">int</span> status = response.getStatus();</div><div class="line">            Object q = params.get(<span class="string">"q"</span>);</div><div class="line">            Object fq = params.get(<span class="string">"fq"</span>);</div><div class="line">            Object numFound = responseBean.getNumFound();</div><div class="line">            Object start = responseBean.getStart();</div><div class="line">            <span class="keyword">return</span> list;</div><div class="line">        &#125; <span class="keyword">catch</span> (SolrServerException e) &#123;</div><div class="line">            logger.error(<span class="string">"solr服务异常"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"solr服务异常"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.error(<span class="string">"solr服务IO异常"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"solr服务IO异常"</span>, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Solr创建索引</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> message 创建索引的文件</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> SolrClient <span class="title">createIndex</span><span class="params">(SolrjMessage message)</span> </span>&#123;</div><div class="line">        SolrInputDocument doc = <span class="keyword">new</span> SolrInputDocument();</div><div class="line">        doc.addField(<span class="string">"id"</span>, message.getId());</div><div class="line">        doc.addField(<span class="string">"url"</span>, message.getUrl());</div><div class="line">        doc.addField(<span class="string">"content"</span>, message.getContent());</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            client.add(doc);</div><div class="line">            client.commit();</div><div class="line">        &#125; <span class="keyword">catch</span> (SolrServerException e) &#123;</div><div class="line">            logger.error(<span class="string">"solr服务异常"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"solr服务异常"</span>, e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.error(<span class="string">"solr服务IO异常"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"solr服务IO异常"</span>, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SolrServerException </span>&#123;</div><div class="line">        UpdateResponse response = client.deleteByQuery(<span class="string">"docName:testCatcher"</span>);</div><div class="line">        client.commit();</div><div class="line">        <span class="keyword">int</span> status = response.getStatus();</div><div class="line">        System.out.println(<span class="string">"status = "</span> + status);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="集群访问"><a href="#集群访问" class="headerlink" title="集群访问"></a>集群访问</h5><ul>
<li>client对象的初始化方式改变，其他创建索引、删除索引、搜索的代码都和单节点一样。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * ZooKeeper地址</div><div class="line">    */</div><div class="line">   <span class="keyword">private</span> String zookeeperUrl = <span class="string">"&#123;zookeeperHost&#125;:2181/solr"</span>;</div><div class="line">   <span class="comment">//查询字符串key</span></div><div class="line">   <span class="keyword">private</span> String searchKey = <span class="string">"name"</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> highlighting = <span class="keyword">true</span>;</div><div class="line">   <span class="keyword">private</span> String highlightingPre = <span class="string">"&lt;em&gt;"</span>;</div><div class="line">   <span class="keyword">private</span> String highlightingPost = <span class="string">"&lt;/em&gt;"</span>;</div><div class="line">   <span class="keyword">private</span> String highlightingField = <span class="string">"content"</span>;</div><div class="line">   <span class="comment">// Solr客户端对象</span></div><div class="line">   <span class="keyword">private</span> CloudSolrClient client;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> CloudSolrClient1 <span class="title">open</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="comment">// 1.创建SolrServer对象，以下这两个是线程安全的SolrServer实现类</span></div><div class="line">       <span class="comment">// CommonsHttpSolrServer 基于Http协议进行C/S数据交互</span></div><div class="line">       <span class="comment">// EmbeddedSolrServer</span></div><div class="line">       <span class="comment">// 内嵌式，只要设定好solr的home目录即可实现和solr的交互，不需要开启solr的服务器，本地交互</span></div><div class="line">       client = <span class="keyword">new</span> CloudSolrClient(zookeeperUrl);</div><div class="line">       client.setSoTimeout(<span class="number">10000</span>); <span class="comment">// socket read timeout</span></div><div class="line">       <span class="comment">//指定Collection名称</span></div><div class="line">       client.setDefaultCollection(<span class="string">"solr"</span>);</div><div class="line">       client.setZkClientTimeout(<span class="number">30000</span>);</div><div class="line">       client.setZkConnectTimeout(<span class="number">30000</span>);</div><div class="line">       client.setSoTimeout(<span class="number">30000</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="管理界面使用说明"><a href="#管理界面使用说明" class="headerlink" title="管理界面使用说明"></a>管理界面使用说明</h2><ul>
<li><p>Collection管理界面，可以添加、删除、查看、别名Collection<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/Collection-manager.png" alt="Collection-manager.png"></p>
</li>
<li><p>选中其中一个Collection可以进行操作的菜单栏<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-overview.png" alt="solr-6.5.1-overview.png"></p>
</li>
<li><p>分词器测试页面，可以对自己配置的分词器手动输入字符串进行分词结果测试<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-analysis.png" alt="solr-6.5.1-analysis.png"></p>
</li>
<li><p>手动输入document的测试页面，使用不多<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-document.png" alt="solr-6.5.1-document.png"></p>
</li>
<li><p>查看当前Collection的配置文件列表，使用不多<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-files.png" alt="solr-6.5.1-files.png"></p>
</li>
<li><p>搜索查询测试页面，支持分页、排序、高亮、过滤等查询参数的配置，执行按钮点击之后可以在右边页面查看查询的结果信息<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-query.png" alt="solr-6.5.1-query.png"></p>
</li>
<li><p>Schema管理页面，可以增加、删除、查看三种类型的Field<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-schema.png" alt="solr-6.5.1-schema.png"></p>
</li>
<li><p>选中其中一个Core可以进行操作的菜单栏<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-core.png" alt="solr-6.5.1-core.png"></p>
</li>
</ul>
<h2 id="数据库索引同步"><a href="#数据库索引同步" class="headerlink" title="数据库索引同步"></a>数据库索引同步</h2><ol>
<li>solrconfig.xml配置数据导入加载类：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"/dataimport"</span> <span class="attr">class</span>=<span class="string">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span></div><div class="line">      		<span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span>solr-data-config.xml<span class="tag">&lt;/<span class="name">str</span>&gt;</span></div><div class="line">    	<span class="tag">&lt;/<span class="name">lst</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li>要放在<code>&lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot;&gt;</code>之前</li>
</ul>
<ol>
<li>相同目录下创建solr-data-config.xml配置数据库连接信息：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">name</span>=<span class="string">"source1"</span> <span class="attr">type</span>=<span class="string">"JdbcDataSource"</span> <span class="attr">driver</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/doc_searcher"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">""</span> <span class="attr">batchSize</span>=<span class="string">"-1"</span> /&gt;</span>  </div><div class="line">　　<span class="tag">&lt;<span class="name">document</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">pk</span>=<span class="string">"id"</span>  <span class="attr">dataSource</span>=<span class="string">"source1"</span>   </span></div><div class="line">                <span class="attr">query</span>=<span class="string">"select * from  test"</span>  </div><div class="line">                 <span class="attr">deltaImportQuery</span>=<span class="string">"select * from test where id='$&#123;dih.delta.id&#125;'"</span>  </div><div class="line">                <span class="attr">deltaQuery</span>=<span class="string">"select id from test where create_time &amp;gt; '$&#123;dataimporter.last_index_time&#125;'"</span>&gt;  </div><div class="line">　　　       <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">name</span>=<span class="string">"id"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span>  </div><div class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">name</span>=<span class="string">"createTime"</span>/&gt;</span>  </div><div class="line">　　　  <span class="tag">&lt;/<span class="name">entity</span>&gt;</span>  </div><div class="line">　　<span class="tag">&lt;/<span class="name">document</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>很简单，照抄小改就行，用jdbc四要素进行连接，delta相关参数是增量导入用的，solr内部维护好上次导入的id和时间戳，这次增量导入就根据内部维护的时间戳进行对比，把变化的部分重新导入到solr。</li>
<li>需要注意的是<field>标签的name属性要在solr的该core的schema进行相应的配置，保证这些field是存在的才能正常运行。</field></li>
</ul>
<ol>
<li><code>server/solr-webapp/webapp/WEB-INF/lib</code>放入mysql的jdbc驱动包</li>
<li>清空该Core中的所有数据，或者新建一个全新的Core</li>
<li>到solr管理页面导入数据即可：<br><img src="/2017/05/25/Solr6.5.1集群部署和后台管理/solr-6.5.1-dataimport.png" alt="solr-6.5.1-dataimport.png"></li>
</ol>
</blockquote>
<h5 id="其他用到的命令"><a href="#其他用到的命令" class="headerlink" title="其他用到的命令"></a>其他用到的命令</h5><ul>
<li><p>本地配置同步到ZooKeeper：（一个个文件同步）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./server/scripts/cloud-scripts/zkcli.sh -zkhost localhost:2181 -cmd putfile /solr/configs/solr/solrconfig.xml  example/example-DIH/solr/solr/conf/solrconfig.xml</div></pre></td></tr></table></figure>
</li>
<li><p>重新加载solr集群的节点配置：（同步ZooKeeper之后免重启集群，重新加载配置信息）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8983/solr/admin/collections?action=RELOAD&amp;name=solr</div></pre></td></tr></table></figure>
</li>
<li><p>从数据源导入数据到Solr</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8983/solr/solr2/dataimport?<span class="built_in">command</span>=full-import&amp;commit=ture</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><a href="http://www.cnblogs.com/Lxiaojiang/p/6297281.html" target="_blank" rel="external">Solr6 Schema.xml配置</a></li>
<li><a href="https://my.oschina.net/infowangxin/blog/898335" target="_blank" rel="external">Solr6.5 集群搭建、数据库数据导入solr、分词器配置</a></li>
<li><a href="http://www.zhangrenhua.com/2016/06/17/Solr6.0.1%E6%A6%82%E5%BF%B5%E5%92%8C%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" target="_blank" rel="external">Solr6.0.1概念和集群部署</a></li>
<li><a href="http://www.zhangrenhua.com/2016/06/18/Solr6%20as%20JDBC%20Data%20Source/" target="_blank" rel="external">Solr6 as JDBC Data Source</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/solr/Configuration+APIs" target="_blank" rel="external">一些Solr的RESTful API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;两年前用过solr5.1版本的，当时只是简单入个门，拿来在项目里建个全文索引，然后再query，其他什么也没做，还是傻傻地自己去配Tomcat，这次做毕设因为需求而重拾solr，基于作死折腾的原则，肯定要用最新版的啦~，然后。。。还是很
    
    </summary>
    
      <category term="微服务" scheme="http://www.coselding.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="java" scheme="http://www.coselding.cn/tags/java/"/>
    
      <category term="搜索引擎" scheme="http://www.coselding.cn/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="solr" scheme="http://www.coselding.cn/tags/solr/"/>
    
      <category term="lucene" scheme="http://www.coselding.cn/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>maven多套环境配置文件和junit冲突问题解决方案</title>
    <link href="http://www.coselding.cn/2017/05/04/maven%E5%A4%9A%E5%A5%97%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8Cjunit%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://www.coselding.cn/2017/05/04/maven多套环境配置文件和junit冲突问题解决方案/</id>
    <published>2017-05-04T14:36:38.000Z</published>
    <updated>2017-05-04T14:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><p>日常的企业级开发，开发一个项目往往需要配置多份的配置文件，比如开发需要一套、测试阶段需要一套、正式上线又有一套（比如JDBC连接的数据库，在不同环境肯定连接不同的库），但是maven给我们提供了filter功能可以很便捷地实现，关于maven的filter功能，不是重点，也实在太简单，需要的自行百度。。。</p>
<h3 id="这里简单说明一下多filter的情况："><a href="#这里简单说明一下多filter的情况：" class="headerlink" title="这里简单说明一下多filter的情况："></a>这里简单说明一下多filter的情况：</h3><ol>
<li><p>这里是多个filter配置文件，每个文件配置了对应环境下的jdbc连接配置：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-f3a567b8e32be19c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="maven-filters.png"></p>
</li>
<li><p>这里是项目配置文件，用${}的方式引用filter文件中的相应配置<br><img src="http://upload-images.jianshu.io/upload_images/3932187-cebfa246a0fd32e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="common.png"></p>
</li>
<li><p>接下来是maven配置文件<br><img src="http://upload-images.jianshu.io/upload_images/3932187-111783c444c3cc4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pom.png"><br><img src="http://upload-images.jianshu.io/upload_images/3932187-1bc0f75ee8b28285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="profiles.png"></p>
</li>
</ol>
<ul>
<li>这样，maven在打包时，只需要指定相应的<code>mvn clean install -Ptest</code>这样的参数，就能直接指定对应的环境配置参数替换项目配置文件中的${}参数，达到动态替换配置的目的。</li>
</ul>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul>
<li><code>-Ptest</code>参数是在maven的<code>compile</code>生命周期时触发的，它会将对应环境的filter文件中参数替换掉项目resources目录下的<code>.xml</code>或者<code>.properties</code>配置文件中的${}包括的对应参数，只要你运行的代码触发可maven的compile周期，项目资源文件就能被正确替换，程序正确执行进行</li>
<li>但是！！！如果你只是简单地进行单元测试，如下所示：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-f9517c8a22682259.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="spring-junit.png"></li>
</ul>
<p>当你在<code>findById</code>上直接右键单元测试时，由于并没有触发maven的<code>compile</code>周期，导致<code>common.properties</code>文件中的<code>${jdbc.url}</code>系列的参数没有被替换，可想而知，这样的单元测试注定无法正确执行的。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>临时把<code>common.properties</code>中的jdbc配置替换成当前所需环境的相应参数，等之后要部署上线记得回来重新把它改回去。</li>
<li>手动修改项目<code>target/classes</code>目录下的<code>common.properties</code>，这样的好处是，项目的源文件不会被修改，但是项目每次重新打包都得手动替换一次。</li>
</ol>
<ul>
<li>以上两种方案都不够优雅，有没有一劳永逸的方案呢？网上找了很多，没发现这方面的相应对策，然后我采取的方案是：右键单元测试的时候，在单元测试启动前插入一段代码，对target/classes中相应的资源文件进行替换，这样，在单元测试执行时加载的资源文件就是替换完成的了，程序正确执行~ </li>
<li>那如何在单元测试前插入代码呢？单元测试的启动是IDE有相应实现的（因为在idea中右键就直接启动了单元测试），但是天无绝人之路啊，我发现：<code>@RunWith(SpringJUnit4ClassRunner.class)</code>这个怎么看都像是单元测试的启动类，于是乎点开了它的源码，发现其中有两个带有before字样的method，如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-e4f5d621aeb57b1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before-test-method.png"><br><img src="http://upload-images.jianshu.io/upload_images/3932187-e5af684d33fdc061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before-test-class.png"></li>
</ul>
<p>显而易见，应该是class之前执行参数替换喽~ 所以我就继承<code>SpringJUnit4ClassRunner</code>这个类，复写其<code>withBeforeClasses</code>方法，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义SpringJUnit4ClassRunner，在Spring单元测试之前将maven的filter环境配置替换工程的配置文件，实现maven一键式单元测试的目的</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> linyuqiang</div><div class="line"> * <span class="doctag">@version</span> 1.0.0 2017/3/14</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WDSpringJUnit4ClassRunner</span> <span class="keyword">extends</span> <span class="title">SpringJUnit4ClassRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WDSpringJUnit4ClassRunner</span><span class="params">(Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> InitializationError </span>&#123;</div><div class="line">        <span class="keyword">super</span>(clazz);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Statement <span class="title">withBeforeClasses</span><span class="params">(Statement statement)</span> </span>&#123;</div><div class="line">        ConfigFilesCatcher configFilesCatcher = <span class="keyword">new</span> ConfigFilesCatcher(<span class="keyword">new</span> WDTestConfiguration());</div><div class="line">        <span class="comment">//获取filter文件</span></div><div class="line">        File filterFile = configFilesCatcher.getFilterFile();</div><div class="line">        FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fis = <span class="keyword">new</span> FileInputStream(filterFile);</div><div class="line">            Properties properties = <span class="keyword">new</span> Properties();</div><div class="line">            <span class="comment">//filter中的键值对</span></div><div class="line">            properties.load(fis);</div><div class="line"></div><div class="line">            <span class="comment">//遍历类路径下的所有配置文件</span></div><div class="line">            List&lt;File&gt; classpathFiles = configFilesCatcher.getClasspathFiles();</div><div class="line">            <span class="keyword">for</span> (File file : classpathFiles) &#123;</div><div class="line">                FileInputStream is = <span class="keyword">null</span>;</div><div class="line">                FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    is = <span class="keyword">new</span> FileInputStream(file);</div><div class="line">                    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">                    IOUtils.copy(is, baos);</div><div class="line">                    <span class="comment">//将该配置文件中含有filter中的元素子串替换</span></div><div class="line">                    String content = <span class="keyword">new</span> String(baos.toByteArray());</div><div class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) &#123;</div><div class="line">                        String key = <span class="string">"$&#123;"</span> + entry.getKey() + <span class="string">"&#125;"</span>;</div><div class="line">                        <span class="keyword">if</span> (content.contains(key)) &#123;</div><div class="line">                            content = content.replace(key, (CharSequence) entry.getValue());</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//配置文件替换完毕回写</span></div><div class="line">                    fos = <span class="keyword">new</span> FileOutputStream(file);</div><div class="line">                    fos.write(content.getBytes());</div><div class="line">                    logger.info(<span class="string">"&#123;&#125;文件配置替换成功"</span>, file.getName());</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    logger.warn(<span class="string">"&#123;&#125; 文件的filter替换失败"</span>, file.getName());</div><div class="line">                    <span class="comment">//不影响下一个文件</span></div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    closeIs(is);</div><div class="line">                    closeOs(fos);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">            logger.warn(<span class="string">"filter文件不存在"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"filter文件不存在"</span>,e);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            logger.warn(<span class="string">"filter文件加载失败"</span>, e);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"filter文件加载失败"</span>,e);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            closeIs(fis);</div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"filter文件配置替换完毕"</span>);</div><div class="line">        <span class="comment">//执行SpringJUnit4ClassRunner原本逻辑</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.withBeforeClasses(statement);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeIs</span><span class="params">(InputStream is)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                is.close();</div><div class="line">                is = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOs</span><span class="params">(OutputStream os)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                os.close();</div><div class="line">                os = <span class="keyword">null</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后这是参数替换的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 单元测试替换文件列表获取器</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> linyuqiang</div><div class="line"> * <span class="doctag">@version</span> 1.0.0 2017/3/14</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigFilesCatcher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line">    <span class="keyword">private</span> WDTestConfiguration configuration;</div><div class="line">    <span class="keyword">private</span> String projectPath;<span class="comment">//项目绝对路径</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigFilesCatcher</span><span class="params">(WDTestConfiguration configuration)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.configuration = configuration;</div><div class="line">        <span class="keyword">this</span>.projectPath = getProjectPath();</div><div class="line">        logger.info(<span class="string">"文件获取器初始化成功，项目绝对路径为：&#123;&#125;"</span>, <span class="keyword">this</span>.projectPath);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取filter文件</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getFilterFile</span><span class="params">()</span> </span>&#123;</div><div class="line">        File file = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (configuration.isAbsolute()) &#123;</div><div class="line">            file = <span class="keyword">new</span> File(configuration.getFilterPath());</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            file = <span class="keyword">new</span> File(projectPath + <span class="string">"/src/main/filters/"</span> + configuration.getFilterFile());</div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"filter文件获取成功：&#123;&#125;"</span>, file.getAbsolutePath());</div><div class="line">        <span class="keyword">return</span> file;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getProjectPath</span><span class="params">()</span> </span>&#123;</div><div class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getClassLoader().getResource(<span class="string">""</span>).getFile());</div><div class="line">        <span class="keyword">while</span> (file != <span class="keyword">null</span> &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getName().equals(<span class="string">"target"</span>)) &#123;</div><div class="line">            file = file.getParentFile();</div><div class="line">            <span class="keyword">if</span> (file.getName() != <span class="keyword">null</span> &amp;&amp; file.getName().equals(<span class="string">"target"</span>)) &#123;</div><div class="line">                file = file.getParentFile();</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"项目绝对路径获取成功"</span>);</div><div class="line">        <span class="keyword">return</span> FilePathDecodeUtil.pathDecode(file.getAbsolutePath());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取类路径下的所有配置文件列表</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;File&gt; <span class="title">getClasspathFiles</span><span class="params">()</span> </span>&#123;</div><div class="line">        String classes = projectPath + <span class="string">"/target/classes"</span>;</div><div class="line">        String testClasses = projectPath + <span class="string">"/target/test-classes"</span>;</div><div class="line">        List&lt;File&gt; classesFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        findFiles(<span class="keyword">new</span> File(classes), classesFiles);</div><div class="line">        findFiles(<span class="keyword">new</span> File(testClasses), classesFiles);</div><div class="line">        logger.info(<span class="string">"类路径下配置文件列表获取成功：&#123;&#125;"</span>, classesFiles);</div><div class="line">        <span class="keyword">return</span> classesFiles;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//递归遍历类路径下的所有class外的配置文件</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findFiles</span><span class="params">(File file, List&lt;File&gt; files)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</div><div class="line">            File[] fs = file.listFiles();</div><div class="line">            <span class="keyword">for</span> (File f : fs) &#123;</div><div class="line">                findFiles(f, files);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".xml"</span>) || file.getName().endsWith(<span class="string">".properties"</span>)) &#123;</div><div class="line">                files.add(file);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码本身很简单，读取filters文件夹下的对应环境filter文件，对target目录下的资源文件(<code>.xml</code>或<code>.properties</code>)进行单纯地字符串正则替换的逻辑。<br>剩下的就是直接使用该Runner类进行单元测试即可，它就会在单元测试启动前期替换资源文件中的参数，再执行你的单元测试逻辑，如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-a98e821ad7b0afd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="junit-wdspring.png"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>哈哈哈，代码本身很简单，这边有意思的是在<code>@RunWith</code>这边插入预处理代码，就是提供一个思路，主要是网上居然没有这方面的解决方案，如果有大神有更好的思路，不妨来交流交流~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;情景&quot;&gt;&lt;a href=&quot;#情景&quot; class=&quot;headerlink&quot; title=&quot;情景&quot;&gt;&lt;/a&gt;情景&lt;/h3&gt;&lt;p&gt;日常的企业级开发，开发一个项目往往需要配置多份的配置文件，比如开发需要一套、测试阶段需要一套、正式上线又有一套（比如JDBC连接的数据库，在
    
    </summary>
    
      <category term="Java" scheme="http://www.coselding.cn/categories/Java/"/>
    
    
      <category term="maven" scheme="http://www.coselding.cn/tags/maven/"/>
    
      <category term="junit" scheme="http://www.coselding.cn/tags/junit/"/>
    
      <category term="filter" scheme="http://www.coselding.cn/tags/filter/"/>
    
      <category term="spring-test" scheme="http://www.coselding.cn/tags/spring-test/"/>
    
  </entry>
  
  <entry>
    <title>Quartz调度系统入门和调度高可用实现方案</title>
    <link href="http://www.coselding.cn/2017/05/04/Quartz%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8%E5%92%8C%E8%B0%83%E5%BA%A6%E9%AB%98%E5%8F%AF%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <id>http://www.coselding.cn/2017/05/04/Quartz调度系统入门和调度高可用实现方案/</id>
    <published>2017-05-04T07:58:38.000Z</published>
    <updated>2017-05-04T07:58:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong> 版本：2.2.1 </strong></p>
<h3 id="Hello-world："><a href="#Hello-world：" class="headerlink" title="Hello world："></a>Hello world：</h3><ul>
<li><p>调度器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</div><div class="line"> scheduler.start();</div></pre></td></tr></table></figure>
</li>
<li><p>任务详情：任务体实现<code>Job</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">JobDetail job = JobBuilder.newJob(MakeHtml.class)</div><div class="line">                .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</div><div class="line">                .build();</div></pre></td></tr></table></figure>
</li>
<li><p>触发器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Trigger trigger = TriggerBuilder.newTrigger()</div><div class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>)</div><div class="line">                .startNow()</div><div class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/2 * * * * ?"</span>))</div><div class="line">                .build();</div></pre></td></tr></table></figure>
</li>
<li><p>执行调度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">scheduler.scheduleJob(job, trigger);</div><div class="line">``` </div><div class="line"></div><div class="line">- 数据传输、参数传输：</div><div class="line">```java</div><div class="line"><span class="comment">//传入</span></div><div class="line">job.getJobDataMap().put(<span class="string">"FAVORITE_COLOR"</span>, <span class="string">"red"</span>);</div><div class="line"><span class="comment">//在执行线程获得</span></div><div class="line">jobExecutionContext.getJobDetail().getJobDataMap();</div><div class="line"><span class="comment">//在该Map中嵌套传输Map可实现对象引用的传输，即实现实时对象参数传输，需要保证线程安全。</span></div></pre></td></tr></table></figure>
</li>
<li><p>多任务对象管理：<br><code>Scheduler</code>对象中保存了JobKey、TriggerKey等和对应的Job、Trigger的映射关系，可以通过该Map进行同对象复用和检索。</p>
</li>
</ul>
<h3 id="配置：classpath下的quartz-properties"><a href="#配置：classpath下的quartz-properties" class="headerlink" title="配置：classpath下的quartz.properties"></a>配置：classpath下的<code>quartz.properties</code></h3><ul>
<li>设置任务线程池大小：org.quartz.threadPool.threadCount=4<br>详细的配置参数列表说明在这：<a href="http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/" target="_blank" rel="external">http://www.quartz-scheduler.org/documentation/quartz-2.1.x/configuration/</a></li>
</ul>
<h3 id="触发器类型：ScheduleBuilder接口"><a href="#触发器类型：ScheduleBuilder接口" class="headerlink" title="触发器类型：ScheduleBuilder接口"></a>触发器类型：<code>ScheduleBuilder</code>接口</h3><ol>
<li>CalendarIntervalScheduleBuilder：<blockquote>
<ul>
<li>通过指定对应日期的定时执行触发器</li>
</ul>
</blockquote>
</li>
<li>CronScheduleBuilder：<blockquote>
<ul>
<li>cron表达式实现的定时执行</li>
</ul>
</blockquote>
</li>
<li>DailyTimeIntervalScheduleBuilder：<blockquote>
<ul>
<li>根据时间定时执行</li>
</ul>
</blockquote>
</li>
<li>SimpleScheduleBuilder<blockquote>
<ul>
<li>简单循环执行，设定执行次数，开始结束时间等</li>
</ul>
</blockquote>
</li>
</ol>
<h3 id="注解："><a href="#注解：" class="headerlink" title="注解："></a>注解：</h3><ul>
<li><p>@PersistJobDataAfterExecution：执行完成把状态持久化保存</p>
<blockquote>
<ul>
<li>目前发现没这个注解，JobDataMap中的数据依然还是在数据库中保存着，不明所以，可能这个注解的作用是在每次执行调度刷新一次数据保持数据库中的数据是最新的值吧。。。</li>
</ul>
</blockquote>
</li>
<li><p>@DisallowConcurrentExecution：Job对象多实例禁止并发执行</p>
<blockquote>
<ul>
<li>就是当这个调度作业还没执行完成的时候，下一次的调度又到了，如果注解了表示不会再申请一个线程让两个Job并发执行，需要等上一次作业执行完成才串行的执行。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="任务本身发生异常"><a href="#任务本身发生异常" class="headerlink" title="任务本身发生异常"></a>任务本身发生异常</h2><ol>
<li><p>再次尝试执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">JobExecutionException e2 =</div><div class="line">        		<span class="keyword">new</span> JobExecutionException(e);</div><div class="line">        	<span class="comment">// this job will refire immediately</span></div><div class="line">        	e2.refireImmediately();</div></pre></td></tr></table></figure>
</li>
<li><p>不再执行，所有该job的调度全部停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">JobExecutionException e2 =</div><div class="line">        		<span class="keyword">new</span> JobExecutionException(e);</div><div class="line">        	<span class="comment">// Quartz will automatically unschedule</span></div><div class="line">        	<span class="comment">// all triggers associated with this job</span></div><div class="line">        	<span class="comment">// so that it does not run again</span></div><div class="line">        	e2.setUnscheduleAllTriggers(<span class="keyword">true</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><ul>
<li>没难度，就是在各种事件或者生命周期过程中进行回调。</li>
<li><code>scheduler.getListenerManager()</code>添加各式各样的监听器，主要有三种：<code>JobListener</code>、<code>TriggerListener</code>、<code>SchedulerListener</code>。</li>
<li>支持通过JobKey和TriggerKey定向对某个Job或Trigger进行专属监听。</li>
<li><p><code>JobListener</code>：</p>
<blockquote>
<ul>
<li><code>getName</code>：获取监听器名字</li>
<li><code>jobToBeExecuted</code>：job执行前</li>
<li><code>jobExecutionVetoed</code>：job执行被触发器拒绝</li>
<li><code>jobWasExecuted</code>：job执行完</li>
</ul>
</blockquote>
</li>
<li><p><code>TriggerListener</code>：</p>
<blockquote>
<ul>
<li><code>getName</code>：获取监听器名字</li>
<li><code>triggerFired</code>：触发器触发</li>
<li><code>vetoJobExecution</code>：触发器执行拒绝Job，返回true就是拒绝</li>
<li><code>triggerMisfired</code>：触发器发现MisFire</li>
<li><code>triggerComplete</code>：触发器触发完成</li>
</ul>
</blockquote>
</li>
<li><p><code>SchedulerListener</code>：</p>
<blockquote>
<ul>
<li><code>jobScheduled</code>：job调度完</li>
<li><code>jobUnscheduled</code>：作业没被调度</li>
<li><code>triggerFinalized</code>：有调度器被完全停止调度时</li>
<li><code>triggerPaused</code>：单个触发器暂停</li>
<li><code>triggersPaused</code>：全部触发器暂停</li>
<li><code>triggerResumed</code>：单个触发器唤醒</li>
<li><code>triggersResumed</code>：全部触发器唤醒</li>
<li><code>jobAdded</code>：job添加</li>
<li><code>jobDeleted</code>：job删除</li>
<li><code>jobPaused</code>：单个job暂停</li>
<li><code>jobsPaused</code>：全部job暂停</li>
<li><code>jobResumed</code>：单个job唤醒</li>
<li><code>jobsResumed</code>：全部job唤醒</li>
<li><code>schedulerError</code>：调度出错</li>
<li><code>schedulerInStandbyMode</code>：调度器正处于standby模式</li>
<li><code>schedulerStarted</code>：调度器启动完成</li>
<li><code>schedulerStarting</code>：调度器正在启动</li>
<li><code>schedulerShutdown</code>：调度器关闭完成</li>
<li><code>schedulerShuttingdown</code>：调度器正在关闭</li>
<li><code>schedulingDataCleared</code>：调度器数据清除完成</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><ul>
<li>RAMJobStore：将工作中的作业Job和调度触发器Trigger都存储在内存中，宕机都没了。</li>
<li>JobStoreX：将Job和Trigger都存储在数据库中，实例重启会自动扫描数据库恢复数据，可进行集群配置，详细请看下面的集群配置。</li>
</ul>
<h3 id="Misfire处理规则"><a href="#Misfire处理规则" class="headerlink" title="Misfire处理规则"></a>Misfire处理规则</h3><blockquote>
<ul>
<li>指的是不小心没调度时，对错过的调度次数如何处理的规则策略选择，情形如下：<blockquote>
<ol>
<li>比如调度器休眠了</li>
<li>quartz集群全体宕机了再重启之后扫描表中数据得知之前的调度错失了就是这种情况</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<p><strong>策略选择</strong>（指的是CronTrigger，而SimpleTrigger有其对应的策略，在这里不做探讨）：</p>
<ul>
<li>withMisfireHandlingInstructionDoNothing<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">——不触发立即执行</div><div class="line">——等待下次Cron触发频率到达时刻开始按照Cron频率依次执行</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<ul>
<li>这是网上的说法，表达是正确的，我经过代码测试的结果是，调度刻度依然不变，就是很干脆地把错过的那些调度直接不管了</li>
<li>调度刻度：指的是作业放入调度器之后通过cron表达式计算出的之后的每个需要调度的时间点组成的一段点线段，就如刻度尺上面的刻度，到达刻度点时就触发调度。</li>
</ul>
<ul>
<li>withMisfireHandlingInstructionIgnoreMisfires<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">——以错过的第一个频率时间立刻开始执行</div><div class="line">——重做错过的所有频率周期后</div><div class="line">——当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>这是网上说法，意思很明了，就是指错过的那些调度都会全部重新执行一遍，但是需要注意的是，如果错过的调度数量很多，这一大堆的调度也是在发现misfire的之后的短时间内一次性全部完成的，然后接着按照调度刻度进行执行。这时候在调度任务内部获取的两个时间：fireTime和scheduleFireTime，fireTime指的是misfire发现之后重新调度的实际时间，scheduleFireTime指的是调度刻度上的基准时间，比如我有个本来应该在12:12:12执行的作业，但是发生misfire或者failover了，重启之后根据策略把错过的任务重新执行，这时候这个任务的实际调度时间可能为12:20:20，所有你如果有些任务的执行是需要依赖于标准的调度时间的（比如每隔一小时dump数据库的数据一次，应该获取的时间戳是scheduleFireTime而不是fireTime），这点要注意。</li>
</ul>
<ul>
<li>withMisfireHandlingInstructionFireAndProceed<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">——以当前时间为触发频率立刻触发一次执行</div><div class="line">——然后按照Cron频率依次执行</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>这是网上说法，说的是可能misfire错过了一堆任务，这里只在发现misfire的时候补偿性地调度一次该任务，接下来还是按照调度刻度执行。</li>
<li>特别注意！！！网上有的说法是调度刻度会在这种策略下平移，如下：16:00要执行的调度，结果misfire了，到16:15才恢复，网上的说法是16:15会调度一次，然后刻度往后移，下一次调度会在17:15发生，但是！！！我的代码测试结果却是：16:15确实会调用一次，这是策略控制结果，下一次的调度时间是17:00，调度刻度并没有变！！！所以说这个策略和第二个策略其实是类似的，只不过第二个策略是把错过的全部调度一次，这个是只调度一次，而且是用恢复的这一瞬间作为scheduleFireTime。</li>
</ul>
</blockquote>
<p><strong>SimpleTrigger</strong>有一堆的另外的MisFire机制，这里先不做讨论，以后有机会再更新，如下：<br><code>withMisfireHandlingInstructionFireNow</code>、<code>withMisfireHandlingInstructionIgnoreMisfires</code>、<code>withMisfireHandlingInstructionNextWithExistingCount</code>、<code>withMisfireHandlingInstructionNowWithExistingCount</code>、<code>withMisfireHandlingInstructionNextWithRemainingCount</code>、<code>withMisfireHandlingInstructionNowWithRemainingCount</code>、<code>MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT</code></p>
<h3 id="执行中Job可获取的时间"><a href="#执行中Job可获取的时间" class="headerlink" title="执行中Job可获取的时间"></a>执行中Job可获取的时间</h3><p>这些时间是在某一次的调度作业的作业执行过程中可以获取到的时间戳。</p>
<ul>
<li><code>PreviousFireTime</code>：当前调度的上一次调度的时间戳。</li>
<li><code>ScheduledFireTime</code>：当前调度的基准调度刻度中的时间戳，就是任务一开始调度就算出来的未来一系列的调度刻度。</li>
<li><code>FireTime</code>：当前调度的实际调度时间戳，通常和ScheduledFireTime一致，但是如果发生misFire或者Fail-Over就可能和ScheduledFireTime不一致。</li>
<li><code>NextFireTime</code>：下一次调度的基准刻度时间。</li>
</ul>
<h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul>
<li>集群通过故障切换和负载平衡的功能，能给调度器带来高可用性和伸缩性。目前集群只能工作在JDBC-JobStore（JobStore TX或者JobStoreCMT）方式下，从本质上来说，是使集群上的每一个节点通过共享同一个数据库来工作的（Quartz通过启动两个维护线程来维护数据库状态实现集群管理，一个是检测节点状态线程，一个是恢复任务线程）。</li>
<li>负载平衡是自动完成的，集群的每个节点会尽快触发任务。当一个触发器的触发时间到达时，第一个节点将会获得任务（通过锁定），成为执行任务的节点。</li>
<li>故障切换的发生是在当一个节点正在执行一个或者多个任务失败的时候。当一个节点失败了，其他的节点会检测到并且标 识在失败节点上正在进行的数据库中的任务。任何被标记为可恢复（任务详细信息的”requests recovery”属性）的任务都会被其他的节点重新执行。没有标记可恢复的任务只会被释放出来，将会在下次相关触发器触发时执行。</li>
</ul>
<h4 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h4><ul>
<li>简单来说就是多个quartz节点共同访问同一个数据库来保证各个节点的调度信息同步，后台有守护线程实时同步节点内存和数据库中的信息同步</li>
<li>一个节点宕机，mysql数据没丢失，重启后从mysql读取恢复内存信息还原宕机前状态</li>
<li>一个被调度的任务由哪个节点执行调度？所有节点去抢mysql表中一个分布式锁（悲观），谁抢到了就谁执行当前任务</li>
<li>宕机切换：我测试在一台机器上启动4个quartz实例模拟集群，其中把一个抢到锁的实例kill掉，quartz会自动切换另一个实例继续执行剩下的调度</li>
<li><p><strong>quartz能够保证一个作业在cron表达式作用下的一次调度不重不漏，以及宕机调度任务重新分配，但是当一个Job被quartz正确调度了，在Job内部逻辑过程中出错抛异常了、或者此时宕机了，那这个Job在quartz系统中其实是已执行状态，因为的确正确调度了，只不过调度执行的Job本身内部出错了，quartz对Job内部异常也有相应的方案，上面有说，但是在作业平台调度系统设计过程中觉得quartz本身提供的job异常机制不够可靠，对此进行了这方面的高可用拓展，详细请看Jobs作业平台的调度系统设计方案</strong></p>
</li>
<li><p>配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#集群名称和id</span></div><div class="line">org.quartz.scheduler.instanceName = MyClusteredScheduler</div><div class="line">org.quartz.scheduler.instanceId = AUTO</div><div class="line"><span class="comment">#线程池</span></div><div class="line">org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool</div><div class="line">org.quartz.threadPool.threadCount = 25</div><div class="line">org.quartz.threadPool.threadPriority = 5</div><div class="line"><span class="comment">#misfire检测时间</span></div><div class="line">org.quartz.jobStore.misfireThreshold = 60000</div><div class="line"><span class="comment">#jobStore配置和数据表前缀等基础配置</span></div><div class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</div><div class="line">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.oracle.OracleDelegate</div><div class="line">org.quartz.jobStore.useProperties = <span class="literal">false</span></div><div class="line">org.quartz.jobStore.dataSource = myDS</div><div class="line">org.quartz.jobStore.tablePrefix = QRTZ</div><div class="line"><span class="comment">#集群模式和集群节点间活性检测临界时间</span></div><div class="line">org.quartz.jobStore.isClustered = <span class="literal">true</span></div><div class="line">org.quartz.jobStore.clusterCheckinInterval = 20000</div><div class="line"><span class="comment">#database jdbs配置</span></div><div class="line">org.quartz.dataSource.myDS.driver = oracle.jdbc.driver.OracleDriver</div><div class="line">org.quartz.dataSource.myDS.URL = jdbc:oracle:thin:@cluster:1521:dev</div><div class="line">org.quartz.dataSource.myDS.user = quartz</div><div class="line">org.quartz.dataSource.myDS.password = quartz</div><div class="line">org.quartz.dataSource.myDS.maxConnections = 5</div><div class="line">org.quartz.dataSource.myDS.validationQuery=select 0 from dual</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Fail-Over容灾机制"><a href="#Fail-Over容灾机制" class="headerlink" title="Fail-Over容灾机制"></a>Fail-Over容灾机制</h2><blockquote>
<ul>
<li>系统崩溃、某个节点宕机的情况下，其他节点自动主备替换的机制，整个机制了高可用Hadoop的主备切换思路也是类似的，主宕机就备挣锁选举。</li>
<li><code>Fail-Over</code>机制工作在集群环境中，执行recovery工作的线程类叫做<code>ClusterManager</code>，该线程类同样是在调度器初始化时就开启运行了。这个线程类在运行期间每<code>15s</code>进行一次<code>check in</code>操作，所谓check in，就是在数据库的<code>QRTZ2_SCHEDULER_STATE</code>表中更新该调度器对应的<code>LAST_CHECKIN_TIME</code>字段为当前时间，并且查看其他调度器实例的该字段有没有发生停止更新的情况，如果检查到有调度器的check in time比当前时间要早约15s（视具体的执行预配置情况而定），那么就判定该调度实例需要<code>recover</code>，随后会启动该调度器的<code>recovery机制</code>，获取<code>目标调度器实例正在触发的trigger</code>，并针对每一个trigger临时添加一各对应的<code>仅执行一次的simpletrigger</code>。等到调度流程扫描trigger时，这些trigger会被触发，这样就成功的把这些未完整执行的调度以一种特殊trigger的形式纳入了普通的调度流程中，只要调度流程在正常运行，这些被recover的trigger就会很快被触发并执行。<br>就是这个机制，使用了SimpleTrigger导致了上面的fireTime和scheduleFireTime可能不同的情况。</li>
</ul>
</blockquote>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul>
<li>Quartz集群自动支持节点间任务调度的负载均衡。</li>
<li>由于自身实现调度集群分布式锁、节点数据同步，因此部署好Quartz集群之后就自然而然实现了宕机自动节点切换，服务器压力大直接横向拓展也能迅速应对短时间内的业务爆发。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Quartz自身提供了对任务调度本身的不重不漏的高可用保证，但是一个任务确实被Quartz正确调度之后呢，Quartz系统中的记录已经标记为这个任务执行完成了，但是这个任务在执行过程中出错了，怎么办？</p>
<ul>
<li>Quartz自身提供了两套策略：</li>
</ul>
<ol>
<li>任务失败不再重试</li>
<li>任务失败自行重试<blockquote>
<ul>
<li>这两套方案粒度太粗了，或者说任务自动重试再次失败呢？还要接着重试吗？总而言之就是在我做的统计作业平台对调度要求不重不漏（其实允许重，但是不允许漏），并且要支持在重试次数上限下的失败重试，并且需要对作业平台中的作业调度失败原因做出不同的错误处理策略。</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="我的方案："><a href="#我的方案：" class="headerlink" title="我的方案："></a>我的方案：</h4><ul>
<li>任务调度高可用 —— 依然依靠Quartz集群提供</li>
<li>任务调度了，在任务执行过程中出错，这段处理逻辑中的出错处理，我来控制，策略如下：</li>
</ul>
<ol>
<li>任务失败自动重试，到达重试上线设置失败</li>
<li>开机重启扫描任务列表，把<code>正在调度</code>状态的作业进行开机恢复</li>
<li>任务调度前后记录start和end状态位日志（Quartz监听器实现），后台定时扫描start和end的对应关系，对不对应的任务进行恢复，这步执行概率极低，是在极端情况下的调度任务丢失采取的最后的保障措施</li>
</ol>
<ul>
<li>下面详细说明我的任务调度高可用方案实现过程</li>
</ul>
<h4 id="一个Job的整个执行过程分解"><a href="#一个Job的整个执行过程分解" class="headerlink" title="一个Job的整个执行过程分解"></a>一个Job的整个执行过程分解</h4><ul>
<li>(1). 记录start日志</li>
<li>(2). 调度记录表插入记录之前的数据准备</li>
<li>(3). 调度记录表查询本次调度记录，状态ready</li>
<li>(4). 准备本次作业流调度执行需要的相关数据，并设置状态位scheduling</li>
<li>(5). 调用作业流执行的dubbo服务，延时操作，等待调度结果</li>
<li><p>(6). </p>
<blockquote>
<ul>
<li>成功：状态位success</li>
<li>失败：设置为retrying，等待守护线程扫描之后重试</li>
<li>不支持的调度：直接设置fail，告警</li>
</ul>
</blockquote>
</li>
<li><p>(7). 记录日志end</p>
</li>
</ul>
<h4 id="quartz系统在Jobs平台下的高可用保证的改造方案"><a href="#quartz系统在Jobs平台下的高可用保证的改造方案" class="headerlink" title="quartz系统在Jobs平台下的高可用保证的改造方案"></a>quartz系统在Jobs平台下的高可用保证的改造方案</h4><ol>
<li><p>系统启动：守护线程调度(jobs-schedule-daemon)、恢复线程调度(jobs-schedule-recovery)这两个是系统分组中的调度</p>
<blockquote>
<ul>
<li>jobs-schedule-daemon负责三分钟扫描一次调度记录表中的retrying状态的记录，并将其添加新的调度来重新执行，添加的调度在jobs-retry分组，该线程后台死循环重复执行</li>
<li>jobs-schedule-recovery是宕机恢复调度，在系统宕机重启之后自动扫描调度记录表中的ready和scheduling两种状态的记录，将其重新执行调度，分组为jobs-recovery，之后恢复线程结束</li>
</ul>
</blockquote>
</li>
<li><p>之后按照各个作业调度器cron表达式正确调度</p>
</li>
<li>作业各个状态高可用保证：<blockquote>
<ul>
<li>步骤(3)：ready状态，宕机重启会进行恢复</li>
<li>步骤(4)：scheduling状态，宕机重启会进行恢复</li>
<li>步骤(5)：retrying状态，守护线程每隔3分钟扫描一次进行重试调度</li>
<li>步骤(6)：success和fail状态，属于最终状态，已完成</li>
</ul>
</blockquote>
</li>
</ol>
<ul>
<li>以上的步骤基于调度记录表对应调度记录存在的情况下保证高可用</li>
</ul>
<ol>
<li>步骤(1)和(2)是在没有MySQL表记录的情况下，要保证高可用计划通过前后的start和end日志对称对比来实现宕机作业恢复，该步骤除了mysql连接以外都是内存计算，宕机可能性极地，并且这几个步骤没有mysql表中对应的一条记录为依托，因此只能依靠任务调度前后的start和end状态日志进行任务丢失恢复。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>Quartz学习：<a href="http://blog.csdn.net/bubei/article/details/2108778" target="_blank" rel="external">http://blog.csdn.net/bubei/article/details/2108778</a></li>
<li>Quartz快速入门：<a href="http://www.blogjava.net/baoyaer/articles/155645.html" target="_blank" rel="external">http://www.blogjava.net/baoyaer/articles/155645.html</a></li>
<li>Quartz官方文档：<a href="http://www.quartz-scheduler.org/documentation/" target="_blank" rel="external">http://www.quartz-scheduler.org/documentation/</a></li>
<li>Quartz官方API：<a href="http://www.quartz-scheduler.org/api/2.1.7/index.html" target="_blank" rel="external">http://www.quartz-scheduler.org/api/2.1.7/index.html</a></li>
<li>集群配置：<a href="http://blog.csdn.net/tayanxunhua/article/details/19345733" target="_blank" rel="external">http://blog.csdn.net/tayanxunhua/article/details/19345733</a></li>
<li>Quartz分布式解决方案：<a href="http://www.tuicool.com/articles/B3qeUrB" target="_blank" rel="external">http://www.tuicool.com/articles/B3qeUrB</a></li>
<li>Quartz集群配置（MySQL数据源）：<a href="http://blog.csdn.net/l1028386804/article/details/49129603" target="_blank" rel="external">http://blog.csdn.net/l1028386804/article/details/49129603</a><br>-</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 版本：2.2.1 &lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;Hello-world：&quot;&gt;&lt;a href=&quot;#Hello-world：&quot; class=&quot;headerlink&quot; title=&quot;Hello world：&quot;&gt;&lt;/a&gt;Hello world：&lt;/h
    
    </summary>
    
      <category term="Java" scheme="http://www.coselding.cn/categories/Java/"/>
    
    
      <category term="调度" scheme="http://www.coselding.cn/tags/%E8%B0%83%E5%BA%A6/"/>
    
      <category term="quartz" scheme="http://www.coselding.cn/tags/quartz/"/>
    
      <category term="分布式调度" scheme="http://www.coselding.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swagger-maven-plugin-环境配置踩坑记录</title>
    <link href="http://www.coselding.cn/2017/04/16/Swagger-maven-plugin-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.coselding.cn/2017/04/16/Swagger-maven-plugin-环境配置踩坑记录/</id>
    <published>2017-04-15T16:36:38.000Z</published>
    <updated>2017-04-15T16:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h2><p>按照该有的教程都配置完成了，swagger页面也正常显示，但是呢，页面里面一个API也没有，关键是我明明按照该有的步骤配置好了相关的注解了，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-38819161460a436f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="api-list-empty.png"></p>
<p>列表里面一条也木有啊。。。</p>
<h2 id="Swagger环境搭建"><a href="#Swagger环境搭建" class="headerlink" title="Swagger环境搭建"></a>Swagger环境搭建</h2><ul>
<li><p>强行插入一下，不说说环境搭建你可能都对我说的东西一脸蒙蔽哈哈哈~</p>
</li>
<li><p>Swagger是一个很方便的合成API文档的工具，有了它，你只要专心做API接口就行了，接口文档Swagger帮你完成，毕竟写完代码之后一想到还要给App或者H5团队一个个讲自己的接口该怎么用，实在是很心累，有了Swagger，只要你的接口开发完毕，部署到测试服务器，只要把swagger页面链接扔给他们就行了~ 多爽~</p>
</li>
</ul>
<h5 id="我这里使用maven的插件方式在项目中接入Swagger，项目使用SpringMVC"><a href="#我这里使用maven的插件方式在项目中接入Swagger，项目使用SpringMVC" class="headerlink" title="我这里使用maven的插件方式在项目中接入Swagger，项目使用SpringMVC"></a>我这里使用maven的插件方式在项目中接入Swagger，项目使用SpringMVC</h5><ol>
<li><p>maven依赖，列出swagger使用的相关依赖，其他Spring和SpringMVC的自己添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- AOP合成字节码的实现框架 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="comment">&lt;!-- Spring AOP模块 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="comment">&lt;!-- JSON处理框架 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="comment">&lt;!-- Swagger依赖 --&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.swagger<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></div><div class="line">              <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.ws.rs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr311-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">              <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>然后是maven插件配置，顺便把jetty和打包插件也列出</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>doc-searcher-web<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">resource</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- jetty插件 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">connectors</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">connector</span> <span class="attr">implementation</span>=<span class="string">"org.mortbay.jetty.nio.SelectChannelConnector"</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">maxIdleTime</span>&gt;</span>60000<span class="tag">&lt;/<span class="name">maxIdleTime</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/doc-searcher-web<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">systemProperties</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">systemProperty</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">name</span>&gt;</span>org.mortbay.jetty.Request.maxFormContentSize<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">value</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;/<span class="name">systemProperty</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;/<span class="name">systemProperties</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- maven编译插件 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- maven资源插件，作用于maven的resources目录下 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- maven war包打包插件 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">warName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">warName</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">           <span class="comment">&lt;!-- 重点：swagger插件 --&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.kongchen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">apiSources</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">apiSource</span>&gt;</span></div><div class="line">                       	<span class="comment">&lt;!-- 支持springMVC --&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">springmvc</span>&gt;</span>true<span class="tag">&lt;/<span class="name">springmvc</span>&gt;</span></div><div class="line">                          <span class="comment">&lt;!-- 你的web项目Controller包名 --&gt;</span> <span class="tag">&lt;<span class="name">locations</span>&gt;</span>cn.coselding.docsearcher.web.controller<span class="tag">&lt;/<span class="name">locations</span>&gt;</span></div><div class="line">                          <span class="comment">&lt;!-- 协议 --&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">schemes</span>&gt;</span>http<span class="tag">&lt;/<span class="name">schemes</span>&gt;</span></div><div class="line">                           <span class="comment">&lt;!-- 所在主机，可以为空 --&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">host</span>&gt;</span>localhost:8080<span class="tag">&lt;/<span class="name">host</span>&gt;</span></div><div class="line">                           <span class="comment">&lt;!-- web项目Context Path --&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">basePath</span>&gt;</span>/doc-searcher-web<span class="tag">&lt;/<span class="name">basePath</span>&gt;</span></div><div class="line">                           <span class="comment">&lt;!-- 必须！要在主页显示你的API的整体信息的，相当于是标题 --&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">info</span>&gt;</span></div><div class="line">                               <span class="tag">&lt;<span class="name">title</span>&gt;</span>文档搜索器<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">                               <span class="tag">&lt;<span class="name">version</span>&gt;</span>v1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                               <span class="tag">&lt;<span class="name">description</span>&gt;</span></div><div class="line">                                   文档搜索器-API</div><div class="line">                               <span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;/<span class="name">info</span>&gt;</span></div><div class="line">                          <span class="comment">&lt;!-- 模板位置，支持classpath:类型路径 --&gt;</span> <span class="tag">&lt;<span class="name">templatePath</span>&gt;</span>classpath:/template/markdown.hbs<span class="tag">&lt;/<span class="name">templatePath</span>&gt;</span></div><div class="line">                          <span class="comment">&lt;!-- 编译期扫描controller之后合成的API文档输出位置 --&gt;</span> <span class="tag">&lt;<span class="name">outputPath</span>&gt;</span>$&#123;project.basedir&#125;/src/main/webapp/swagger-ui/document.md<span class="tag">&lt;/<span class="name">outputPath</span>&gt;</span></div><div class="line">                          <span class="comment">&lt;!-- web目录下的js、css等资源位置 --&gt;</span> <span class="tag">&lt;<span class="name">swaggerDirectory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/webapp/swagger-ui/<span class="tag">&lt;/<span class="name">swaggerDirectory</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;/<span class="name">apiSource</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;/<span class="name">apiSources</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">               <span class="comment">&lt;!-- 这里很重要，简单说就是配置在maven的compile生命周期执行时触发swagger插件的generate命令 --&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">executions</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;<span class="name">goals</span>&gt;</span></div><div class="line">                           <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></div><div class="line">                       <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></div><div class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>很好理解，在maven的compile生命周期触发的时候触发swagger的generate命令，当然你直接使用插件的generate手动执行也可以，执行完成之后会在webapp/swagger-ui/目录下生成swagger.json里面就列出了扫描到的所有接口信息。</p>
<ol>
<li><p>webapp目录下放入资源文件，是一些css、js、html之类的文件，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-e560747fb3bf1842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="webapp-resources.png"></p>
</li>
<li><p>classpath下放入一些模板资源文件，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-e812e4ee721adc84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classpath-resources.png"><br>以上这两个资源包是公司一个大佬@张章改过的，网上没找到，最后会给出几个博客，也能拿到相关的资源，不过是官方原生的。</p>
</li>
<li><p>SpringMVC配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></div><div class="line">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span> <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></div><div class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span></div><div class="line">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</div><div class="line">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd</div><div class="line">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd "&gt;</div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- Controller包扫描 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.coselding.docsearcher.web.controller"</span>/&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- springMVC注解驱动支持 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- 容器默认的DefaultServletHandler处理 所有静态内容与无RequestMapping处理的URL，不设置这个你在请求刚才的js、css文件就请求不到了 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></div><div class="line"></div><div class="line">	<span class="comment">&lt;!-- 声明swagger资源文件位置，表示这个路径下的SpringMVC的DispatcherServlet不拦截 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/swagger-ui/**"</span> <span class="attr">location</span>=<span class="string">"/swagger-ui/"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- SpringMVC设置AOP --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span> <span class="attr">proxy-target-class</span>=<span class="string">"false"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里主要就是配置这个AOP，它会在编译期拦截读取各个Controller的注解接口信息，提取关键数据，合成swagger.json文件，有了这个文件，剩下那些html就能渲染出相关的接口文档页面。</p>
<ol>
<li>上面那些是整体环境配置，接下来只要在Controller编写的时候加点注解，文档就帮你合成好啦~<br>注解使用：如下一个样例Controller：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> linyuqiang</div><div class="line"> * <span class="doctag">@version</span> 1.0.0 2017/4/4</div><div class="line"> */</div><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</div><div class="line"><span class="meta">@Api</span>(<span class="string">"文档搜索器API"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlCatcherController</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"测试1"</span>)</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/spider/&#123;id&#125;"</span>, method = RequestMethod.POST)</div><div class="line">    <span class="meta">@ResponseBody</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">spider</span><span class="params">(</span></span></div><div class="line">            @ApiParam(required = <span class="keyword">true</span>,name = <span class="string">"id"</span>,value = <span class="string">"测试id"</span>)</div><div class="line">            @<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> Integer id) &#123;</div><div class="line">        Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">        result.put(<span class="string">"result"</span>, <span class="string">"success"</span>);</div><div class="line">        result.put(<span class="string">"id"</span>, id);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li><code>@Api(&quot;文档搜索器API&quot;)</code>：这个是整个Controller的标题，Controller下的所有接口会被整理在同一个列表组下，组名组名就是这个。</li>
<li><code>@ApiOperation(&quot;测试1&quot;)</code>：这个是具体的一个接口的名称</li>
<li><code>@ApiParam(required = true,name = &quot;id&quot;,value = &quot;测试id&quot;)</code>：这个是接口参数的标注，<code>required</code>不用说，<code>name</code>标注作用的表单参数名称，和下面的id对应，<code>value</code>是文档页面上这个参数的描述</li>
</ul>
</blockquote>
<h5 id="之后，maven-jetty启动项目，访问页面http-localhost-8080-doc-searcher-web-swagger-ui-index-html，如下图所示："><a href="#之后，maven-jetty启动项目，访问页面http-localhost-8080-doc-searcher-web-swagger-ui-index-html，如下图所示：" class="headerlink" title="之后，maven jetty启动项目，访问页面http://localhost:8080/doc-searcher-web/swagger-ui/index.html，如下图所示："></a>之后，maven jetty启动项目，访问页面<code>http://localhost:8080/doc-searcher-web/swagger-ui/index.html</code>，如下图所示：</h5><p><img src="http://upload-images.jianshu.io/upload_images/3932187-a57328e01e93ce91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="swagger-show.png"></p>
<p>还能在参数那边输入对应的值，直接测试接口呢~</p>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><ol>
<li><p>如果你设置了SpringMVC拦截器，要注意，必须对webapp/swagger-ui/目录下的exclude，不然会报错~如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></div><div class="line">	<span class="comment">&lt;!-- Jobs鉴权拦截器 --&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**/*"</span>/&gt;</span></div><div class="line">           <span class="comment">&lt;!-- 排除对swagger-ui目录下的拦截 --&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/swagger-ui/**"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.weidian.jobs.web.interceptor.JobsAuthInterceptor"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>文首，我的Swagger页面居然没有API列表是为什么？如下是我之前的Controller方法注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ApiOperation</span>(<span class="string">"测试1"</span>)</div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/spider/&#123;id&#125;"</span>)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">spider</span><span class="params">(</span></span></div><div class="line">        @ApiParam(required = <span class="keyword">true</span>,name = <span class="string">"id"</span>,value = <span class="string">"测试id"</span>)</div><div class="line">        @<span class="title">PathVariable</span><span class="params">(<span class="string">"id"</span>)</span> Integer id) &#123;</div><div class="line">    Map&lt;String, Object&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    result.put(<span class="string">"result"</span>, <span class="string">"success"</span>);</div><div class="line">    result.put(<span class="string">"id"</span>, id);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>对，就是没<code>method = RequestMethod.POST</code>参数，你这边写了什么参数，Swagger就给你在API列表相应添加一条，没写就什么都没有，这个错误我犯了两次了，真不能忍啊！！！</p>
<h2 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h2><p>末尾，来几个搭建教程，里面就有相关的swagger资源包的下载地址啦~</p>
<ul>
<li><a href="http://blog.csdn.net/doctor_who2004/article/details/50816208" target="_blank" rel="external">利用Swagger Maven Plugin生成Rest API文档</a></li>
<li><a href="https://github.com/swagger-api/swagger-ui/" target="_blank" rel="external">swagger-ui开源地址</a></li>
<li><a href="https://github.com/kongchen/swagger-maven-plugin" target="_blank" rel="external">swagger-maven-plugin开源地址</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;症状&quot;&gt;&lt;a href=&quot;#症状&quot; class=&quot;headerlink&quot; title=&quot;症状&quot;&gt;&lt;/a&gt;症状&lt;/h2&gt;&lt;p&gt;按照该有的教程都配置完成了，swagger页面也正常显示，但是呢，页面里面一个API也没有，关键是我明明按照该有的步骤配置好了相关的注解了，
    
    </summary>
    
      <category term="Java" scheme="http://www.coselding.cn/categories/Java/"/>
    
    
      <category term="Swagger" scheme="http://www.coselding.cn/tags/Swagger/"/>
    
      <category term="自动化" scheme="http://www.coselding.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="RESTful" scheme="http://www.coselding.cn/tags/RESTful/"/>
    
      <category term="SpringMVC" scheme="http://www.coselding.cn/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>记毕设过程中遇到的一个InnoDB的坑</title>
    <link href="http://www.coselding.cn/2017/04/09/%E8%AE%B0%E6%AF%95%E8%AE%BE%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AAInnoDB%E7%9A%84%E5%9D%91/"/>
    <id>http://www.coselding.cn/2017/04/09/记毕设过程中遇到的一个InnoDB的坑/</id>
    <published>2017-04-09T10:22:48.000Z</published>
    <updated>2017-04-09T10:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="情景描述"><a href="#情景描述" class="headerlink" title="情景描述"></a>情景描述</h2><ul>
<li><p>我的毕设其中一个模块需要实现多线程爬虫，爬虫模块中的url容器打算使用mysql的一张表（表名叫<code>url_catcher</code>）来实现，里面涉及到url防重，子线程监控，url提取，路径计算方案等不是重点，不细讲。</p>
</li>
<li><p>重点来了，在这个并发环境下，最关键的一步自然就是多线程对同一条url的抢锁的实现，先说明我的原先的思路：通过对<code>url_catcher</code>中的一行<code>status</code>字段状态位进行<code>CAS</code>操作实现抢锁，贴代码：</p>
</li>
</ul>
<ol>
<li><p>Mybatis映射文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></div><div class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</div><div class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.coselding.docsearcher.catcher.dao.UrlCatcherDao"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTop1"</span> <span class="attr">resultType</span>=<span class="string">"UrlCatcher"</span>&gt;</span></div><div class="line">        select * from url_catcher where status=#&#123;status&#125; limit 0,1;</div><div class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"setStatus"</span>&gt;</span></div><div class="line">        update url_catcher set status= #&#123;newStatus&#125;,err_msg=#&#123;errMsg&#125; where id = #&#123;id&#125; and status= #&#123;oldStatus&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Dao只是个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UrlCatcherDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">UrlCatcher <span class="title">getTop1</span><span class="params">(@Param(<span class="string">"status"</span>)</span> Integer status)</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">setStatus</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Integer id,</span></div><div class="line">    			  @<span class="title">Param</span><span class="params">(<span class="string">"oldStatus"</span>)</span> Integer oldStatus,</div><div class="line">                  @<span class="title">Param</span><span class="params">(<span class="string">"newStatus"</span>)</span> Integer newStatus,</div><div class="line">                  @<span class="title">Param</span><span class="params">(<span class="string">"errMsg"</span>)</span> String errMsg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>url状态枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CatcherStatus &#123;</div><div class="line"></div><div class="line">   	NO_CATCH(<span class="number">0</span>, <span class="string">"还没爬取"</span>),</div><div class="line">   	CATCHING(<span class="number">1</span>, <span class="string">"正在爬取"</span>),</div><div class="line">   	CATCHED(<span class="number">2</span>, <span class="string">"爬取过了"</span>),</div><div class="line">   	FAILED(<span class="number">3</span>, <span class="string">"爬取失败"</span>);</div><div class="line"></div><div class="line">   	<span class="keyword">private</span> <span class="keyword">int</span> code;</div><div class="line">   	<span class="keyword">private</span> String description;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>抢锁关键Service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Transactional</span>(isolation = Isolation.REPEATABLE_READ)</div><div class="line">   <span class="function"><span class="keyword">public</span> UrlCatcher <span class="title">findTopAndLock</span><span class="params">()</span> </span>&#123;</div><div class="line">       UrlCatcher catcher = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</div><div class="line">       	<span class="comment">//(1)获取表中status为NO_CATCH的第一条记录，sql语句见上面的Mybatis映射文件</span></div><div class="line">           catcher = urlCatcherDao.getTop1(CatcherStatus.NO_CATCH.getCode());</div><div class="line">           System.out.println(<span class="string">"catcher = "</span> + catcher + <span class="string">",count = "</span> + count);</div><div class="line">           <span class="comment">//(2)爬虫停止</span></div><div class="line">           <span class="keyword">if</span> (catcher == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">break</span>;<span class="comment">//容器中没url了</span></div><div class="line">           &#125;</div><div class="line">           <span class="comment">//(3) 修改状态，确认锁定：将对应id的记录，如果状态为NO_CATCH就修改为CATCHING，否则不修改，返回值count为这条sql执行后对表中影响的行数</span></div><div class="line">           count = urlCatcherDao.setStatus(catcher.getId(), CatcherStatus.NO_CATCH.getCode(), CatcherStatus.CATCHING.getCode(), <span class="string">""</span>);</div><div class="line">           <span class="comment">//count小于等于0表示没抢到，接着循环抢下一个，抢到了就返回</span></div><div class="line">       &#125;</div><div class="line">       logger.info(<span class="string">"抢锁成功：catcher = &#123;&#125;"</span>, catcher);</div><div class="line">       <span class="keyword">return</span> catcher;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<ul>
<li>说明：</li>
</ul>
<ol>
<li>第一步：获取表中status为<strong><code>NO_CATCH</code></strong>的第一条记录，sql语句见上面的Mybatis映射文件，很好理解</li>
<li>第二步：获取的第一条记录catcher为空，表示表中没有可用url，退出循环返回，这不是重点，这是爬虫停止条件</li>
<li>第三步：对第一步获取的catcher对象id进行<code>CAS</code>抢锁（如果状态为<strong><code>NO_CATCH</code></strong>就修改为<strong><code>CATCHING</code></strong>，否则不修改，返回值count为这条sql执行后<code>对表中影响的行数</code>），这样的结果就是如果该线程抢到了，状态修改成功（即加锁），count&gt;0退出循环返回，否则就是被其他线程抢了，count=0继续外层while循环</li>
<li><code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code>设定该操作的事务隔离级别</li>
</ol>
</blockquote>
<ul>
<li>这样看似没什么问题啊，运行起来却是偶尔正常，偶尔不正常。。。如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-04fdd808c2a96bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="running-not-exist.png"></li>
</ul>
<p>死循环了吧~<br>看见id为1450了吗？我让这个死循环接着运行着，然后控制台sql查一下这条记录的status：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">status</span> <span class="keyword">from</span> url_catcher <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1450</span></div></pre></td></tr></table></figure></p>
<p>结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-d99e40b449a90b46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sql-result.png"></p>
<p>对比上面的枚举类，可以知道该url当前的状态为<code>CATCHING</code>，被哪个线程抢了我不管，但是已经被抢了，这样在抢锁逻辑中<code>urlCatcherDao.getTop1(CatcherStatus.NO_CATCH.getCode());</code>这句肯定不应该获取这条记录的，我们把死循环的程序停了，看看打的日志：<br>不在公司，屏幕比较小，没法完成截图，复制其中一行看看：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">catcher = UrlCatcher&#123;id=<span class="number">1450</span>, docId=<span class="number">1</span>, fullUrlPath=<span class="string">'http://hadoop.apache.org/docs/r2.6.5/hadoop-mapreduce-client/hadoop-mapreduce-client-hs/images/logos/'</span>, rootUrlPath=<span class="string">'http://hadoop.apache.org/docs/r2.6.5/hadoop-mapreduce-client/hadoop-mapreduce-client-hs'</span>, rootFilePath=<span class="string">'/Users/coselding/test1'</span>, parentPath=<span class="string">'/images/logos'</span>, filename=<span class="string">''</span>, createTime=<span class="number">1491723334618</span>, status=<span class="number">0</span>, errMsg=<span class="string">'null'</span>&#125;,count = <span class="number">0</span></div><div class="line"><span class="number">20</span></div></pre></td></tr></table></figure></p>
<p>看重点！！！id=1450,status=0（对应枚举<code>NO_CATCH</code>）<br>这尼玛，同样在运行中，死循环中查询出的1450记录status=0，而我用控制台sql得到的status=1，心中千万只草泥马奔腾而过！！！</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><ol>
<li>首先想到的自然是事务隔离级别，我就在草稿纸上画两个事务线程的可能的执行轨迹，不论怎么画，都想不到有怎样的轨迹能够达到这种执行结果！！！这些不是重点，不贴图了，然后我就不想理论的了，直接把<code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code>换着测试，一开始还挺顺利，换成<strong>SERIALIZABLE</strong>就不死循环了，但是因为没有理论支撑，我多执行了几次，然后死循环依然出现了，看来是锁粒度变大导致了死循环发生频率降低了，但是至少说明了我对这些事务隔离级别的理解还是对的，世界观没崩塌，还好还好~</li>
<li>然后还是查资料：mysql缓存？就算是缓存也有有效时间，不可能死循环</li>
<li>先查查事务隔离级别，找思路，直到找到了这几篇博客：</li>
</ol>
<ul>
<li><a href="http://blog.csdn.net/sunny5211/article/details/7896383" target="_blank" rel="external">Innodb事务隔离级别</a></li>
<li><a href="http://asialee.iteye.com/blog/2353254" target="_blank" rel="external">InnoDB中事务隔离级别和锁的关系</a></li>
<li><a href="http://lib.csdn.net/article/14/44826?knId=376" target="_blank" rel="external">Innodb中的事务隔离级别和锁的关系</a></li>
</ul>
<ol>
<li>重新回顾了一下<code>二段锁协议</code>，也了解了InnoDB的<code>行级锁</code>是<code>基于索引</code>的，没建立索引的字段无法触发行级锁，还有间隙锁，感觉自己了解的还是不够，之后还是得花时间好好补补</li>
<li>重点来了：InnoDB的乐观锁实现<code>MVCC</code>，规则如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-75a6af192194f447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="innoDB-MVCC.png"></li>
</ol>
<p>InnoDB基于事务版本号对select实现了<code>快照读</code>，insert、delete、update是<code>当前读</code>，简单说呢，就是select在并发环境下可能读取到的就是<code>历史纪录</code>（和死循环的现象吻合），具体详解可以参照<a href="http://lib.csdn.net/article/14/44826?knId=376" target="_blank" rel="external">Innodb中的事务隔离级别和锁的关系</a>，有了这个思路，我们来分析一下上面的死循环原因~</p>
<h2 id="原因过程分析"><a href="#原因过程分析" class="headerlink" title="原因过程分析"></a>原因过程分析</h2><p>还是id=1450作为例子，<code>初始创建版本号</code>createVersion为0，<code>删除版本号</code>deleteVersion为null</p>
<table>
<thead>
<tr>
<th>过程</th>
<th>事务线程1</th>
<th>事务线程2</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务开始</td>
<td>createVersion=0，deleteVersion=null</td>
<td>createVersion=0，deleteVersion=null</td>
</tr>
<tr>
<td>事务版本号</td>
<td>version=1</td>
<td>version=2</td>
</tr>
<tr>
<td>1</td>
<td>getTop1执行:createVersion&lt;version,deleteVersion=null</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>获取status=0</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>getTop1执行:createVersion&lt;version,deleteVersion=null</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>获取status=0</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>setStatus执行，update规则：<code>新纪录</code>（status=1，createVersion=2，deleteVersion=null），<code>原记录快照</code>（status=0，createVersion=0，deleteVersion=2）</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>抢锁成功，commit</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td>返回，该事务线程结束</td>
</tr>
<tr>
<td>8</td>
<td>setStatus抢锁失败</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>下次循环：getTop1执行:createVersion&lt;version,deleteVersion=null，查找到了刚才的<strong><code>原记录快照（status=0）</code></strong></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>setStatus抢锁失败，接着循环</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>该事务线程永远无法commit，version版本号永远不变，<code>永远查找到原记录快照</code>，status永远为0，陷入死循环</td>
</tr>
</tbody>
</table>
<ul>
<li>分析：由于两个事务线程需要按照上表的顺序交错进行才能出现死循环，因此和之前的结论：死循环偶尔出现是相吻合的</li>
<li>根本原因：外层循环中多次的getTop1执行时由于在同一个事务中，<code>事务版本号始终不变</code>，导致始终获取快照记录，导致死循环</li>
<li>解决方案：让getTop1和setStatus分离在不同事务中执行，即去掉<code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code></li>
</ul>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><ul>
<li><p>就去掉了个注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> UrlCatcher <span class="title">findTopAndLock</span><span class="params">()</span> </span>&#123;</div><div class="line">       UrlCatcher catcher = <span class="keyword">null</span>;</div><div class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">       <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</div><div class="line">           catcher = urlCatcherDao.getTop1(CatcherStatus.NO_CATCH.getCode());</div><div class="line">           System.out.println(<span class="string">"catcher = "</span> + catcher + <span class="string">",count = "</span> + count);</div><div class="line">           <span class="keyword">if</span> (catcher == <span class="keyword">null</span>) &#123;</div><div class="line">               <span class="keyword">break</span>;<span class="comment">//容器中没url了</span></div><div class="line">           &#125;</div><div class="line">           <span class="comment">//抢分布式锁：开始抢锁</span></div><div class="line">           <span class="comment">//修改状态，确认锁定</span></div><div class="line">           count = urlCatcherDao.setStatus(catcher.getId(), CatcherStatus.NO_CATCH.getCode(), CatcherStatus.CATCHING.getCode(), <span class="string">""</span>);</div><div class="line">           <span class="comment">//count小于等于0表示没抢到，接着循环抢下一个，抢到了就返回</span></div><div class="line">       &#125;</div><div class="line">       logger.info(<span class="string">"抢锁成功：catcher = &#123;&#125;"</span>, catcher);</div><div class="line">       <span class="keyword">return</span> catcher;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>由于我这个爬虫所处理的业务规模不会无限膨胀，再进行了优化，将抢锁操作转移到内存中执行，降低mysql压力，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlCatcherServiceImpl</span> <span class="keyword">implements</span> <span class="title">UrlCatcherService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> UrlCatcherDao urlCatcherDao;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Integer, Long&gt; urlLockMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, Long&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareLockMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        urlLockMap.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> UrlCatcher <span class="title">findTopAndLock</span><span class="params">()</span> </span>&#123;</div><div class="line">        UrlCatcher catcher = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        Long currentThreadId = Thread.currentThread().getId();</div><div class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</div><div class="line">            catcher = urlCatcherDao.getTop1(CatcherStatus.NO_CATCH.getCode());</div><div class="line">            logger.info(<span class="string">"catcher = "</span> + catcher + <span class="string">",count = "</span> + count);</div><div class="line">            <span class="keyword">if</span> (catcher == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;<span class="comment">//容器中没url了</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//抢分布式锁：开始抢锁</span></div><div class="line">            Long beforeThreadId = urlLockMap.putIfAbsent(catcher.getId(), currentThreadId);</div><div class="line">            <span class="keyword">if</span> (beforeThreadId == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//抢到了：之前该id为key没有映射关系</span></div><div class="line">                <span class="comment">//修改状态，确认锁定</span></div><div class="line">                count = urlCatcherDao.setStatus(catcher.getId(), CatcherStatus.NO_CATCH.getCode(), CatcherStatus.CATCHING.getCode(), <span class="string">""</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//没抢到：之前已经有映射关系了</span></div><div class="line">                count = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//count小于等于0表示没抢到，接着循环抢下一个，抢到了就返回</span></div><div class="line">        &#125;</div><div class="line">        logger.info(<span class="string">"抢锁成功：catcher = &#123;&#125;"</span>, catcher);</div><div class="line">        <span class="keyword">return</span> catcher;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>改成这样之后，我前前后后重新执行了不下几十遍，再也没有出现死循环，算是解决了，如果后期还出现问题的话我再来更新博客哈哈哈，在此只是提供一个解决问题的思路~</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>虽然最终解决方案只是去掉一个注解，但是这其中蕴含的原理却颇为深刻，专门花了时间记录一下，也让我意识到对MySQL的理解还远远不够，之后还是得重新把<code>《高性能MySQL》</code>重新拿来好好啃啃。</li>
<li>之前由于接触不多，总感觉数据库InnoDB、高并发对于自己比较遥远，或者说是没有丰富的实战经验，导致对其中可能出现的问题、如何排查、如何解决问题等有种恐惧加拖延症，这次花了半天时间排查这个问题，时间上算是损失惨重，但是也让我对自己更加自信，算是第一次在我手中解决了一个高并发环境下的问题哈哈哈哈</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;情景描述&quot;&gt;&lt;a href=&quot;#情景描述&quot; class=&quot;headerlink&quot; title=&quot;情景描述&quot;&gt;&lt;/a&gt;情景描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;我的毕设其中一个模块需要实现多线程爬虫，爬虫模块中的url容器打算使用mysql的一张表（表名叫&lt;code
    
    </summary>
    
      <category term="数据库" scheme="http://www.coselding.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="http://www.coselding.cn/tags/mysql/"/>
    
      <category term="InnoDB" scheme="http://www.coselding.cn/tags/InnoDB/"/>
    
      <category term="读写锁" scheme="http://www.coselding.cn/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
      <category term="事务" scheme="http://www.coselding.cn/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>知识、任务管理软件个人测评</title>
    <link href="http://www.coselding.cn/2017/03/12/%E7%9F%A5%E8%AF%86%E3%80%81%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E4%B8%AA%E4%BA%BA%E6%B5%8B%E8%AF%84/"/>
    <id>http://www.coselding.cn/2017/03/12/知识、任务管理软件个人测评/</id>
    <published>2017-03-12T12:19:48.000Z</published>
    <updated>2017-03-12T12:19:48.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>在这个浮躁的大数据爆发的时代，没有一个强大和手的知识管理软件是很难在大量的信息流中获取真正有用的东西的，作为一个极客，对自己的知识管理和任务管理自然也要做到极致，因此花了很多时间体验各种不同的App，来找出最适合自己的，然后要对它托付我的大量知识笔记了~</li>
<li>讲道理，以下的各个App都做的很精致，但是对于不同的使用者会有不同的使用体验，不同的使用者在日常生活总是有各自不同的需求，因此导致到最后选择使用不同的App，因此，在此，我仅以我自己日常的使用习惯和使用需求来评价这些软件，尽量以客观的方式评价各自的功能。</li>
<li>我个人对全平台有比较大的执念，因此下面的某些App没有支持全平台的我可能体验短时间就直接pass了，当然，windows平台勉强能够忽略，但是至少要是支持Mac、IOS、Android、Web四大平台的才能真正入我的眼（为什么？因为知识和事件本身就是非常琐碎的东西，当你要换手机换电脑的时候发现新手机平台上不支持之前的知识任务管理软件，这时候造成的问题就是，要么换手机要被限制，要么放弃之前积累的大量数据，这点是非常不合理的，选择全平台就是为了以后避免这种问题的发生）</li>
<li>这篇博客相当于给你一个参考，并不是为某个厂商做广告，适合我的不一定就是适合你的，重中之重就是你对知识管理和任务管理有什么需求，最适合的才是最好的~</li>
</ul>
<p>[TOC]</p>
<h2 id="知识管理软件"><a href="#知识管理软件" class="headerlink" title="知识管理软件"></a>知识管理软件</h2><h3 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h3><ul>
<li>全平台支持：Mac、IOS、Android、Windows、Web、Chrome插件都有</li>
<li>资费：免费版每月60M上传流量，付费版VIP98￥/年，高级VIP148￥/年</li>
<li>编辑器：支持拍照、附件、录音、手写、普通富文本编辑器</li>
<li>层次结构：划分为笔记本，笔记本下可以创建多个笔记，也就是说能够创建的层次结构只有最多两层</li>
<li>标签：支持对笔记标记标签，加快检索速度</li>
<li>时间提醒：支持笔记时间提醒</li>
<li>Todo：支持在笔记中添加todo标记，方便在笔记中进行事件管理</li>
<li>markdown：本身不支持Markdown，但是可以使用马克飞象使用Markdown编写笔记，需要另外付费</li>
<li>笔记放映：高级VIP功能，可以像PPT一样放映笔记，方便开会使用</li>
<li>分享：支持和印象笔记其他用户通过邮件分享</li>
<li>网页剪裁：Chrome插件支持，方便看到优秀博客快速收藏</li>
<li>导入：从印象笔记的.enex格式导入，html没试过</li>
<li>导出：导出.enex或html格式，这功能纯备份</li>
<li>夸设备使用：免费版支持2设备使用，付费班不限制</li>
<li>内链：支持</li>
</ul>
<blockquote>
<ul>
<li>总体评价：免费版每月60M上传几乎没法用，付费之后功能强大，特别是高级VIP放映功能，而且老牌，稳定，全平台支持良好，todo支持点赞</li>
<li>个人吐槽：Markdown需要额外支持，另外付费。。。层次划分最多两层，不满足我的需求，pass。。。不过这个老牌子有稳定的盈利模式，所以这款应该是比较靠谱的，希望以后能更新出一些我必须的功能。</li>
</ul>
</blockquote>
<h3 id="OneNote"><a href="#OneNote" class="headerlink" title="OneNote"></a>OneNote</h3><ul>
<li>全平台支持：微软家的兼容性我是不敢说啥的，你想要有的都有。。。</li>
<li>资费：免费，不免费我也能让他强行免费。。。</li>
<li>编辑器：word风格编辑器，功能肯定是很强大的</li>
<li>层次结构：笔记本——分区——页面三个层次划分</li>
<li>标签：不支持</li>
<li>时间提醒：没发现。。。</li>
<li>Todo：支持，和印象笔记差不多</li>
<li>markdown：微软家支持markdown就怪了。。。</li>
<li>笔记放映：说白了就是像word的全屏效果。。。</li>
<li>分享：邀请其他微软用户加入笔记</li>
<li>网页剪裁：也有Chrome插件，没耐心试，因为根本不想用。。。</li>
<li>导入：没发现啊</li>
<li>导出：导出PDF</li>
<li>夸设备使用：免费使用没这问题</li>
<li>内链：没试过</li>
</ul>
<blockquote>
<ul>
<li>总体评价：用起来和word差不多，让人有种不想用的感觉，服务器在国外，同步速度不行，编辑器强大和平台支持完全。</li>
<li>个人评价：没markdown我就不想用了，安装包还特大，真不能忍。。。不浪费时间在这货上了</li>
</ul>
</blockquote>
<h3 id="为知笔记"><a href="#为知笔记" class="headerlink" title="为知笔记"></a>为知笔记</h3><ul>
<li>全平台支持：Mac、IOS、Android、Windows、Linux都支持，还是很不错的</li>
<li>资费：100天免费，之后60￥/年，一刀切诟病很大，没有大背景总怕我心爱的笔记因为它倒闭而没了。。。</li>
<li>编辑器：九宫格、富文本、手写画、拍照、markdown等，也是很强大</li>
<li>层次结构：无限层次文件夹结构，这个我喜欢</li>
<li>标签：多层次标签</li>
<li>时间提醒：支持啊</li>
<li>Todo：和印象笔记类似，可以点击打勾</li>
<li>markdown：支持markdown，但是！只是个编辑器，不支持即时预览，需要点击切换成阅读模式才能看效果。。。但是，它家对Markdown语法支持比较全面，没像下面的有道云笔记，像被阉割一样让人不爽。</li>
<li>笔记放映：不支持，但是支持把笔记单独弹出窗口，之后全屏也和放映效果一样。</li>
<li>分享：支持链接分享和邮件分享，支持微信公众号保存，就是在公众号看到好文章直接可以一键保存到自己的笔记本，大厂都有的功能，很赞</li>
<li>网页剪裁：Chrome插件也支持，这里要说明的就是它这个网页剪裁也是很强大，或者说没有有道云笔记的渣剪裁效果我可能还不会突出说。。。试了就知道~从此信息收集这块无忧，也可以减少一些自己浏览器中的书签数量了。</li>
<li>导入：支持所有文件格式导入，类似于文件管理，右键导入——选择好要导入的文件即可</li>
<li>导出：导出PDF和html</li>
<li>夸设备使用：支持</li>
<li>内链：支持</li>
</ul>
<blockquote>
<ul>
<li>总体评价：</li>
</ul>
<ol>
<li>价格合理，价位对付费用户来说确实良心，但是对于免费用户来说只有100天试用期导致直接拒绝掉很多潜在用户，感觉这公司要跪。。。</li>
<li>功能确实强大，界面简洁，Material Design风格对于谷歌党还是有诱惑力的。</li>
<li>无限层次结构也很方便，很赞</li>
<li>markdown的支持有点作死，还有就是不支持放映，好处是对markdown语法支持较好，我还是忍了</li>
</ol>
<ul>
<li>个人评价：从笔记信息的收集到笔记整理、编辑、分类、检索、事件管理、时间管理等功能上都很符合我的使用需求，唯一怕的是这公司倒了，我的笔记又得再整理一次，先用着，等着其他家厂商会不会出现一些功能更新，或者看为知这个公司重新考虑一下它的商业模式。</li>
</ul>
</blockquote>
<h3 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a>有道云笔记</h3><ul>
<li>全平台支持：网易大厂，Mac、IOS、Android、Windows、微信、浏览器插件也都应有尽有</li>
<li>资费：免费用户3G云空间，VIP198/年有50G空间，所以说相当于是免费使用，因为记笔记3G够用了</li>
<li>编辑器：富文本编辑器、语音、手写画、拍照、markdown也都支持</li>
<li>层次结构：和为知笔记一样，支持无限层次文件夹结构，很方便国人使用习惯</li>
<li>标签：App端有标签，电脑端没有啊，反正没用过</li>
<li>时间提醒：不支持啊</li>
<li>Todo：不支持啊</li>
<li>markdown：虽然明面上支持markdown吧，但是表格啊、公式啊、[TOC]语法啦都不支持啊，你这markdown让人用的这么搁手是个什么意思</li>
<li>笔记放映：支持啊，而且免费</li>
<li>分享：像百度云那样的分享模式，某些情况下也是不错的</li>
<li>网页剪裁：Chrome插件有啊，但是啊，它的网页内容提取算法是不是那种不转正的实习生写的啊，提取出的内容简直乱七八糟</li>
<li>导入：也是支持文件导入，直接拖进去就行</li>
<li>导出：PDF和html导出</li>
<li>夸设备使用：支持</li>
<li>内链：支持</li>
</ul>
<blockquote>
<ul>
<li>总体评价：整体功能挺好，背靠网易大厂，暂时倒不了，可以安心使用，就是单纯做笔记可以用的很爽，但是如果你也可我一样是IT人士，整天要在众多的数据流中过滤出对自己有用的数据，并进行及时的归档，那它的功能就不太适合你了。</li>
<li>个人评价：首先，markdown不能完美支持直接pass，我在公司内部confluence写文档也是不支持markdown，但是我并不是忍受confluence而是自己专门花时间做了一个markdown转confluence格式的工具，然后自己任性地接着用markdown在公司内部写文档，我就是这么任性~再来，平时微信公众号、浏览器看大量博客，有道云笔记的信息收集功能拙计的话，根本没法长久使用下去啊。</li>
</ul>
</blockquote>
<h3 id="微云笔记"><a href="#微云笔记" class="headerlink" title="微云笔记"></a>微云笔记</h3><ul>
<li>全平台支持：QQ附属产品，你觉得会不会全平台，说白了是个网盘，只是在网盘中增加了云笔记的附属功能。</li>
<li>资费：免费啊</li>
<li>编辑器：富文本编辑器，没深入使用</li>
<li>层次结构：单层结构。。。</li>
<li>标签：没有啊</li>
<li>时间提醒：没有啊</li>
<li>Todo：支持。。</li>
<li>markdown：没有啊</li>
<li>笔记放映：没有啊</li>
<li>分享：微云能分享也和360网盘差不多下场</li>
<li>网页剪裁：没有啊</li>
<li>导入：木有啊</li>
<li>导出：米有啊</li>
<li>夸设备使用：肯定行啊</li>
<li>内链：不支持</li>
</ul>
<blockquote>
<ul>
<li>总体评价：总的来说就是个简单的云便签吧，对笔记功能需求不大的可以使用，不过只有这点需求的话，那用免费的有道云我觉得也比用这个好吧。。。</li>
<li>个人评价：单纯发现有笔记试了一下，最后默默关掉窗口。。。</li>
</ul>
</blockquote>
<h3 id="小米便签"><a href="#小米便签" class="headerlink" title="小米便签"></a>小米便签</h3><ul>
<li>全平台支持：支持你妹的全平台，雷总就是为了让你用一辈子小米手机才搞出这玩意儿~</li>
<li>资费：雷总只要你的手机钱。。。</li>
<li>编辑器：感觉和IOS便签一个风格</li>
<li>层次结构：两层啊，就是便签夹——便签</li>
<li>标签：木有啊</li>
<li>时间提醒：支持</li>
<li>Todo：支持</li>
<li>markdown：手机端的怎么可能</li>
<li>笔记放映：木有</li>
<li>分享：这么点小便签有分享的意义吗</li>
<li>网页剪裁：木有</li>
<li>导入：木有</li>
<li>导出：导出到txt。。</li>
<li>夸设备使用：MIUI间可以夸设备。。。</li>
<li>内链：木有</li>
</ul>
<blockquote>
<ul>
<li>总体评价：小米手机忠实用户可以使用啊，或者是笔记入门者也行，但是建议早日脱坑</li>
<li>个人评价：你用了它就会发现想换手机的时候又要有所顾忌。。。</li>
</ul>
</blockquote>
<h3 id="IOS便签"><a href="#IOS便签" class="headerlink" title="IOS便签"></a>IOS便签</h3><ul>
<li>全平台支持：IOS、Mac可以同步，这点比小米好多了，至少手机记录的电脑上看得到，前提是你得是苹果两件套</li>
<li>资费：都买了iPhone和mac了还收你钱吗？</li>
<li>编辑器：IOS之前的发布会是一直吹啦，也就那么回事</li>
<li>层次结构：两层结构</li>
<li>标签：不支持啊</li>
<li>时间提醒：支持啊</li>
<li>Todo：支持啊，IOS上还有个叫待办事件的App，说白了就是个Todo的软件</li>
<li>markdown：不支持</li>
<li>笔记放映：不支持</li>
<li>分享：你可以Command+A、Command+C、Command+V这样就能分享了</li>
<li>网页剪裁：不支持</li>
<li>导入：不支持</li>
<li>导出：不支持</li>
<li>夸设备使用：水果家的设备随便跨</li>
<li>内链：一个便签内链你妹啊</li>
</ul>
<blockquote>
<ul>
<li>总体评价：就用户忠实度而言，苹果的用户忠实度远大于小米，所以有些永远用iPhone的人就没有换手机导致的笔记丢失问题，但是功能一般啊，入门级。。。</li>
<li><p>个人评价：也就前段时间比较忙，没空好好整理之前的一大堆笔记才先用这个东西，现在整理完了就要抛弃它啦~</p>
</li>
<li><p>总之我力挺为知啊，希望你不要倒下，印象笔记的话，如果能更新点markdown和层次功能的话我也不拒绝投入你的怀抱，有道嘛，也是功能问题啦~</p>
</li>
</ul>
</blockquote>
<h2 id="任务管理软件"><a href="#任务管理软件" class="headerlink" title="任务管理软件"></a>任务管理软件</h2><ul>
<li>接下来就是任务管理了，就是所谓的TodoList，GTD时间管理。用这些辅助软件帮助记住一些任务列表，把大脑的内存空出来才能更加高效的工作啊~</li>
<li>我自己试用了多款App，不满意的很多，感觉没必要都列举出来分析，主要试用的有：<code>番茄Todo</code>、<code>What to do</code>、<code>MemoZy</code>、<code>Todolist</code>、<code>J.Todo</code>、<code>Any.do</code>，这些功能都很简单，就是简单的写入任务，然后在完成之后打勾，从待办事件中消除，但是他们都不支持全平台，对于我这种平时在电脑前工作的，不支持电脑版意味着我完成一件事都得打开手机一次用来标记，这显然是不合理而且浪费时间的，因此直接pass，如果你的情况和我不一样，可以考虑试试，因为他们功能更加纯粹。</li>
</ul>
<h3 id="OmniFocus"><a href="#OmniFocus" class="headerlink" title="OmniFocus"></a>OmniFocus</h3><ul>
<li>全平台支持：只支持mac和iOS。windows和android不支持啊，这是Omni公司的尿性，但是这款软件作为时间管理的至尊，真的是不得不说。</li>
<li>资费：$40一年</li>
<li>层次划分：文件夹——项目——动作三个层次，网上有说无限层次的，没看出来。。。</li>
<li>时间提醒：支持</li>
<li>重复事件：没发现啊</li>
<li>上下文：可以设定自己添加的任务所在哪个上下文，相当于是一个背景，或者说一个存储的位置，相当于多了一层的层次吧</li>
<li>日历：日历查看任务分布</li>
<li>检查：检查剩余事件等</li>
<li>评价：不支持Android啊，没深入使用，不过里面对GTD理念的支持非常到位，它主要是支持很多任务之间的依赖关系，先后顺序等的管理，这方面的功能做的很好，但是对于我来说最重要的功能还是层次划分、todo记录、重复事件和全平台这些最基本的要求，暂时先pass，说不定以后就回来使用它啦~</li>
</ul>
<h3 id="Doit-im"><a href="#Doit-im" class="headerlink" title="Doit.im"></a>Doit.im</h3><ul>
<li>全平台支持：mac、iOS、Android、Windows、Web</li>
<li>资费：Pro版本付费100$/年</li>
<li>层次划分：项目——事件——子任务三层次，对于todo够了</li>
<li>时间提醒：支持</li>
<li>重复事件：支持，这个功能必须有啊</li>
<li>邮件提醒：支持</li>
<li>优先级：支持</li>
<li>情景：支持</li>
<li>任务收集插件：支持，Android通知栏和mac托盘都有，支持快速命令收集任务，这点很赞，”^时间 #项目 @情境 内容”这种格式写入任务，它会自动弹出选项让你选，可以快速录入。</li>
<li>标签：支持</li>
<li>已完成、今日待办、下一步行动、日程、等待等各种根据任务列表进行信息提取归纳之后的列表：支持，这个可以很方便查看自己的庞大的任务列表中的最要紧的事情</li>
<li>评价：任务录入、整理、分类、提醒整个体系很完善，赞~~~</li>
</ul>
<h3 id="奇妙清单"><a href="#奇妙清单" class="headerlink" title="奇妙清单"></a>奇妙清单</h3><ul>
<li>全平台支持：mac、iOS、Android、Windows</li>
<li>层次划分：清单夹——任务——子任务三层次</li>
<li>时间提醒：支持</li>
<li>重复事件：不支持。。</li>
<li>邮件提醒：支持</li>
<li>任务收集插件：支持写入框点击时间快速录入，效果也是不错</li>
<li>没有任务整理列表，不能很清晰马上看明天的待执行列表</li>
<li>评价：总体来说其实和Doit.im不相上下，功能上也很相近，只是Doit.im的功能会多一点，还多了一些任务整理，这点上是奇妙清单不足的地方，不过整体上差不多，可以都使用看看</li>
</ul>
<h3 id="高效Todo"><a href="#高效Todo" class="headerlink" title="高效Todo"></a>高效Todo</h3><ul>
<li>全平台支持：这是唯一一款不支持全平台但是我拿出来讲的，但其实还好，支持iOS、Android和电脑端Web</li>
<li>资费：免费</li>
<li>层次结构：项目——任务——子任务三层次，但是有它独有的（重要——紧急）两个因素划分的四象限，这点倒是很有特点啊</li>
<li>时间提醒：必须支持</li>
<li>重复事件：不支持。。。</li>
<li>时间轴：就像QQ空间那样的时间轴，可以看以前做的事情，便于回顾</li>
<li>便签：相当于记事本，就是一些暂时和时间无关的事情，备忘一下</li>
<li>标签：支持对任务进行标签，这个可以加快检索</li>
<li>其他：还有一些多人协作之类的，没用的很深</li>
<li>评价：如果对电脑端没有执念的话，其实这款App还是很不错的，值得推荐，三个层次划分满足todo的大部分需求了，再多的层次一般需要记在云笔记中了。</li>
</ul>
<h3 id="番茄土豆"><a href="#番茄土豆" class="headerlink" title="番茄土豆"></a>番茄土豆</h3><ul>
<li>全平台支持：mac、iOS、Android、Windows、Chrome拓展都支持</li>
<li>资费：有VIP，比如备注啊、提醒时间等基本功能也要VIP才能用</li>
<li>层次结构：单层次。。。</li>
<li>时间提醒：要付费。。。</li>
<li>重复事件：不支持，我要写一些每月做一次的事情它不给支持啊。。。</li>
<li>特点：就只是个简单的添加事件，然后有个时钟倒计时，做完这件事再勾选，功能很纯粹，并且在此基础上给你一堆统计图表啊，比如今天干了多少活啊，哪个时间段做了最多事情，效率最高的时间段之类的，感觉有点华而不实，不是我的菜，pass</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个人的时间总是那么有限，但是当今社会中的信息流又如此巨大，因此唯有真正管理好自己的时间，在自己有限的人生当中尽量朝着最高效的最优路径走，才能更好地提高自己。</li>
<li>在我最近对自己以前的笔记的整理过程中，也发现了很多年轻时用word做的一大堆笔记，真的感觉当初的自己很傻，但是现在也没有精力重新整理那些笔记了，因为我发现，曾经的那些笔记对现在的我已经没有意义了，要么就是过时了，要么就是太基础了，讲这个想说明的就是在现在这个信息爆炸的时代，知识的更新迭代速度真的太快了，只有把自己的知识系统整理清晰，在需要的时候能够快速检索，才能让这些有用的知识在它的有效期发挥最大的价值。</li>
</ul>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>怎样打造高效的OmniFocus系统：<a href="http://www.mifengtd.cn/articles/omnifocus-gtd-system.html" target="_blank" rel="external">http://www.mifengtd.cn/articles/omnifocus-gtd-system.html</a><br>这是一个以前看到的用OmniFocus进行时间管理的一篇不错的文章，可以作为参考，构建自己的时间任务管理体系。</p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;在这个浮躁的大数据爆发的时代，没有一个强大和手的知识管理软件是很难在大量的信息流中获取真正有用的东西的，作为一个极客，对自己的知识管理和任务管理自然也要做到极致，因此花了很多时间体验各种不同的App，来找出最适合自己的，然后要对它托付我的大量知识笔记了~&lt;/li
    
    </summary>
    
      <category term="个人心得" scheme="http://www.coselding.cn/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="时间管理" scheme="http://www.coselding.cn/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="知识管理" scheme="http://www.coselding.cn/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
      <category term="doit.im" scheme="http://www.coselding.cn/tags/doit-im/"/>
    
      <category term="GTD" scheme="http://www.coselding.cn/tags/GTD/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo入门学习笔记</title>
    <link href="http://www.coselding.cn/2017/01/02/Dubbo%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.coselding.cn/2017/01/02/Dubbo入门学习笔记/</id>
    <published>2017-01-02T14:57:48.000Z</published>
    <updated>2017-01-02T14:57:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h3><p>Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种方式可以使各个层之间解耦合（或者最大限度地松耦合）。从服务模型的角度来看，Dubbo采用的是一种非常简单的模型，要么是提供方提供服务，要么是消费方消费服务，所以基于这一点可以抽象出服务提供方（Provider）和服务消费方（Consumer）两个角色。<br>简单说呢，Dubbo用起来就和EJB、WebService差不多，调用一个远程的服务（或者JavaBean）的时候在本地有一个接口，就像调用本地的方法一样去调用，它底层帮你实现好你的方法参数传输和远程服务运行结果传回之后的返回，就是RPC的一种封装啦~<br>当然，这个只是Dubbo的最基本的功能，它的特点是：</p>
<ol>
<li>它主要是使用高效的网络框架和序列化框架，让分布式服务之间调用效率更高。</li>
<li>采用<code>注册中心</code>管理众多的服务接口地址，当你想调用服务的时候只需要跟注册中心询问即可，不用像使用WebService一样每个服务都得记录好接口调用方式。</li>
<li><code>监控中心</code>：实现对服务方和调用方之间运行状态的监控，还能控制服务的优先级、权限、权重、上下线等，让整个庞大的分布式服务系统的维护和治理比较方便。</li>
<li>高可用：有个服务宕机了？注册中心就会从服务列表去掉该节点。还是调用到了？客户端会向注册中心请求另一台可用的服务节点重新调用。注册中心宕机？注册中心也能实现高可用（ZooKeeper）。</li>
<li>负载均衡：采用软负载均衡算法实现对多个相同服务的节点的请求负载均衡。</li>
<li>等等。。。很多高大上的，看官方文档吧，我也是文档中抄过来的~</li>
</ol>
<h3 id="一些参考站点或博客"><a href="#一些参考站点或博客" class="headerlink" title="一些参考站点或博客"></a>一些参考站点或博客</h3><blockquote>
<ul>
<li>官方用户指南：<a href="http://dubbo.io/User+Guide-zh.htm" target="_blank" rel="external">http://dubbo.io/User+Guide-zh.htm</a></li>
<li>官网(还有挺多东西，不一一列出了，自己点点就有)：<a href="http://dubbo.io/" target="_blank" rel="external">http://dubbo.io/</a></li>
<li>Dubbo开源地址：<a href="https://github.com/alibaba/dubbo/" target="_blank" rel="external">https://github.com/alibaba/dubbo/</a></li>
<li>Dubbo另一开源地址：<a href="https://github.com/dubbo/" target="_blank" rel="external">https://github.com/dubbo/</a><br>主要包括了Alibaba的Dubbo项目和当当网拓展之后的Dubbox项目，以及一些其他子项目和工具的代码，可以作为参考。</li>
<li>Dubbo架构设计详解：<a href="http://shiyanjun.cn/archives/325.html" target="_blank" rel="external">http://shiyanjun.cn/archives/325.html</a><br>一开始会有很多看不懂的，很正常，先整体过一遍，了解大致情况，等学的比较清楚了，再看一遍，会有额外收获，温故而知新，可以为师矣。</li>
<li>一个很详细的Dubbo学习笔记博客：<a href="http://blog.csdn.net/lipslive/article/details/46530361" target="_blank" rel="external">http://blog.csdn.net/lipslive/article/details/46530361</a></li>
<li>软负载均衡算法：<a href="http://www.cnblogs.com/xrq730/p/5154340.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/5154340.html</a></li>
</ul>
</blockquote>
<h4 id="注意"><a href="#注意" class="headerlink" title=" 注意 "></a><strong><em> 注意 </em></strong></h4><p>所有东西以官方用户指南为准：<a href="http://dubbo.io/User+Guide-zh.htm" target="_blank" rel="external">http://dubbo.io/User+Guide-zh.htm</a><br>其他第三方文章博客什么的可以参考辅助理解，但是由于阿里是国内公司，官方用户指南，特别是中文版都特别详细，真的没有很多必要去找一堆第三方的教程来看啦~</p>
<h3 id="Dubbo环境准备"><a href="#Dubbo环境准备" class="headerlink" title="Dubbo环境准备"></a>Dubbo环境准备</h3><p>Dubbo需要四大基本组件：Registry、Monitor、Provider、Consumer。<br><img src="http://upload-images.jianshu.io/upload_images/3932187-361ecb2025073656.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dubbo-architecture.jpg-version=1&amp;modificationDate=1330892870000.jpg"></p>
<ol>
<li><p>安装<strong>注册中心</strong>（Registry），我用ZooKeeper，具体参考我的<a href="http://www.jianshu.com/p/5e012efb2d82" target="_blank" rel="external">ZooKeeper教程博客</a>，安装好ZooKeeper之后注册中心就有了，先放着，等会用。</p>
</li>
<li><p>安装<strong>简单监控中心</strong>：simple-monitor。网上找<code>dubbo-monitor-simple-2.8.4-assembly.tar.gz</code>。</p>
<blockquote>
<ul>
<li>解压，找到conf文件夹下的dubbo.properties文件，下面简单介绍各个配置参数的意义：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 容器，就是说这个简单监控中心是在jetty和spring环境下运行的，依赖于注册中心，日志系统是log4j</span></div><div class="line">dubbo.container=<span class="built_in">log</span>4j,spring,registry,jetty</div><div class="line"><span class="comment"># 监控系统对整个Dubbo服务系统来说也是一个服务，这里指定了这个监控服务的名称</span></div><div class="line">dubbo.application.name=simple-monitor</div><div class="line"><span class="comment"># 服务的所有者，这是Dubbo的服务的功能，可以指定服务的负责人</span></div><div class="line">dubbo.application.owner=coselding</div><div class="line"><span class="comment"># 下面四个是指定注册中心地址的，分别为广播、zookeeper、redis、dubbo（自带）方式的注册中心，前面说了，我用的是Zookeeper（前面配好了），因此去掉zookeeper前面的#，配置zookeeper的ip和端口号。之后简单监控中心就能通过注册中心获取当前可用的服务列表及其状态，在页面向你汇报Dubbo中的服务运行情况。</span></div><div class="line"><span class="comment">#dubbo.registry.address=multicast://224.5.6.7:1234</span></div><div class="line">dubbo.registry.address=zookeeper://&#123;ip&#125;:&#123;port&#125;</div><div class="line"><span class="comment">#dubbo.registry.address=redis://127.0.0.1:6379</span></div><div class="line"><span class="comment">#dubbo.registry.address=dubbo://127.0.0.1:9090</span></div><div class="line"><span class="comment"># dubbo协议端口号，保持默认即可</span></div><div class="line">dubbo.protocol.port=7070</div><div class="line"><span class="comment"># jetty工作端口号，平时不是习惯8080吗？当然，这里为了不影响之后运行的tomcat，就不要占用8080端口啦。</span></div><div class="line">dubbo.jetty.port=8082</div><div class="line"><span class="comment"># 一个工作目录，在这个目录会保存一些监控中心的数据，比如调用曲线图等，这里指定一个存在的空目录即可</span></div><div class="line">dubbo.jetty.directory=<span class="variable">$&#123;user.home&#125;</span>/monitor</div><div class="line"><span class="comment"># 监控中心报表存放的目录，同上，一般默认即可</span></div><div class="line">dubbo.charts.directory=<span class="variable">$&#123;dubbo.jetty.directory&#125;</span>/charts</div><div class="line"><span class="comment"># 监控中心数据资料目录，同上，一般默认即可</span></div><div class="line">dubbo.statistics.directory=<span class="variable">$&#123;user.home&#125;</span>/monitor/statistics</div><div class="line"><span class="comment"># 监控中心日志文件路径</span></div><div class="line">dubbo.log4j.file=logs/dubbo-monitor-simple.log</div><div class="line"><span class="comment"># 监控中心日志记录级别</span></div><div class="line">dubbo.log4j.level=WARN</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>运行bin目录下的start.sh（unix系下）或start.bat（win下）即可。</li>
<li>浏览器访问：<code>http://{简单监控中心所在的主机ip}:8082</code>，端口号是刚才配置文件设置的8082，即可访问查看Dubbo服务集群中的应用和服务的简单情况。</li>
</ul>
</blockquote>
<ol>
<li>安装<strong>Dubbo管理控制台</strong>：<blockquote>
<ul>
<li>下载<code>dubbo-admin-2.8.4.war</code>，这个是Dubbo的管理控制台的webapp的war包，将其解压。</li>
<li>WEB-INF目录下的<code>dubbo.properties</code>文件配置Dubbo的信息，如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 配置注册中心地址，和简单监控中心一样，通过注册中心才能监控当前所有可用的服务。</span></div><div class="line">dubbo.registry.address=zookeeper://127.0.0.1:2181</div><div class="line"><span class="comment"># root账户的密码，网页进入控制台界面之前需要输入帐号密码</span></div><div class="line">dubbo.admin.root.password=root</div><div class="line"><span class="comment"># guest访客账户的密码</span></div><div class="line">dubbo.admin.guest.password=guest</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>将修改完配置的dubbo-admin的整个目录复制到tomcat的webapps目录下，重启tomcat，说白了dubbo-admin就是tomcat的一个webapp的形式存在。</li>
</ul>
</blockquote>
<h3 id="Dubbo注册中心"><a href="#Dubbo注册中心" class="headerlink" title="Dubbo注册中心"></a>Dubbo注册中心</h3><p>上面已经安装完成了zookeeper的注册中心了，这个注册中心主要就是负责dubbo的所有服务地址列表维护，并且可以通过在ZooKeeper节点中设置相应的值来实现对这个服务的权重、优先级、是否可用、路由、权限等的控制。<br>你可以先记住，之后在Dubbo的管理控制台对服务的一堆治理策略设置和调整，实际上就是修改了注册中心中的服务对应的配置数据（即修改了zookeeper中服务对应的节点的配置数据）。<br>之后<code>Consumer</code>从注册中心请求到服务的数据时就能根据这些配置数据进行相应的治理配置参数的代码执行生效。</p>
<h3 id="Dubbo样例服务开发"><a href="#Dubbo样例服务开发" class="headerlink" title="Dubbo样例服务开发"></a>Dubbo样例服务开发</h3><p>这里我用maven构建项目，在Spring环境中配置Provider和Consumer。<br>先说明使用的依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Spring所需依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- dubbo所需依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jboss.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>LATEST<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- ZooKeeper所需依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<ol>
<li><code>Provider</code>：<blockquote>
<ul>
<li>声明服务的接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyDemo</span> </span>&#123;</div><div class="line">    	<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li><p>对接口进行实现（这里是Provider，需要真的实现，之后在Consumer端调用接口之后实际就是在这里的实现代码执行所需逻辑的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> <span class="keyword">implements</span> <span class="title">IMyDemo</span> </span>&#123;</div><div class="line">    	<span class="meta">@Override</span></div><div class="line">    	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        	String hello = <span class="string">"hello "</span> + name;</div><div class="line">        	System.out.println(hello);</div><div class="line">        	<span class="keyword">return</span> hello;</div><div class="line">    	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Spring配置相应的Dubbo服务(provider.xml)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="comment">&lt;!-- 这里添加了dubbo的命名空间，之后Spring通过dubbo中扩展的配置解析生成对应的dubbo实例放到Spring的IoC容器中 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">       http://code.alibabatech.com/schema/dubbo</div><div class="line">       http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!-- 指定服务的应用名称，在dubbo中层次级别是先分为多个应用（可以理解为一个项目），在每个应用下有多个服务（可以理解为项目下具体的某个提供服务的服务类） --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里就是指定一个应用的名称，指定相同的应用名的服务在dubbo中都会被分配在同一个应用分支下 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 之前配置好的ZooKeeper服务器作为注册中心，这里指定好ZooKeeper的地址，此处的Dubbo才能连接上注册服务器，很好理解 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://119.29.153.56:2181"</span> <span class="attr">id</span>=<span class="string">"registry"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Dubbo的每个节点之间通信可以支持rmi、Http、Dubbo等一系列的协议，这里指定默认的dubbo协议，以及此处的服务Provider对外暴露的服务端口号 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 到这里，这个Provider节点就已经能连上注册服务器，并使用指定的协议进行通信了 --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里对外暴露刚才编写的接口，并指定IoC容器中接口的实现来为这个接口提供实际的服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.weidian.dubbo.IMyDemo"</span> <span class="attr">ref</span>=<span class="string">"myDemo"</span>/&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里是Spring原始的JavaBean声明方式，并放在IoC容器中 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDemo"</span> <span class="attr">class</span>=<span class="string">"com.weidian.dubbo.MyDemo"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>本地测试一下这个服务是否可用，这里还没用到Dubbo，只是先测试一下Spring容器是否有问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDubbo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        ApplicationContext providerContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"provider.xml"</span>);</div><div class="line">        IMyDemo demo = providerContext.getBean(IMyDemo.class);</div><div class="line">        System.out.println(demo.sayHello(<span class="string">"world"</span>));</div><div class="line">        Thread.sleep(<span class="number">60000</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>运行结果：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-5deebe99b3ee816d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="provider.png"></p>
</li>
</ul>
<p>Provider内部代码输出了一遍，返回到测试代码又输出了一遍，总共两遍hello world</p>
<ol>
<li><code>Consumer</code>：</li>
</ol>
<ul>
<li><p>编写和Provider服务的对应接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyDemo</span> </span>&#123;</div><div class="line">		<span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Spring配置远程的服务为本地的JavaBean（consumer.xml）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="comment">&lt;!-- 这里添加了dubbo的命名空间，之后Spring通过dubbo中扩展的配置解析生成对应的dubbo实例放到Spring的IoC容器中 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></div><div class="line">       http://www.springframework.org/schema/beans/spring-beans.xsd</div><div class="line">       http://code.alibabatech.com/schema/dubbo</div><div class="line">        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line">    <span class="comment">&lt;!-- 声明要连接的应用名称，要和Provider声明的指定的应用名一致 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 之前配置好的ZooKeeper服务器作为注册中心，这里指定好ZooKeeper的地址，此处的Dubbo才能连接上注册服务器，很好理解 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://119.29.153.56:2181"</span> <span class="attr">id</span>=<span class="string">"registry"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Dubbo的每个节点之间通信可以支持rmi、Http、Dubbo等一系列的协议，这里指定默认的dubbo协议，</span></div><div class="line">        以及此处的Consumer对外暴露的服务端口号，因为注册中心有服务节点列表更新是要实时推送到Consumer中的 </div><div class="line">        --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 到这里，这个Consumer节点就已经能连上注册服务器，并使用指定的协议进行通信了 --&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 接口指定Consumer端的那个服务接口，之后它就会通过这个接口的应用名和全限定名去注册中心</span></div><div class="line">        查找实际的服务Provider地址列表，再通过指定的dubbo协议进行通信，实现RPC，而在Consumer</div><div class="line">        本机端对Spring的IoC容器指定id，方便之后对这个远程JavaBean的引用调用 --&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoRemote"</span> <span class="attr">interface</span>=<span class="string">"com.weidian.dubbo.IMyDemo"</span> <span class="attr">protocol</span>=<span class="string">"dubbo"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>另外，也能绕过Registry直连Provider，如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">interface</span>=<span class="string">"com.weidian.dubbo.IMyDemo"</span> <span class="attr">version</span>=<span class="string">"1.0"</span> <span class="attr">id</span>=<span class="string">"myDemo"</span> <span class="attr">url</span>=<span class="string">"dubbo://127.0.0.1:20880/"</span>&gt;</span><span class="tag">&lt;/<span class="name">dubbo:reference</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>远程过程调用测试(前提是先把Provider的服务先运行起来再来运行这个Consumer（在两个端的测试代码尾部都添加了sleep代码的原因）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@org</span>.junit.<span class="function">Test</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetRemoteService</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">        ApplicationContext consumerContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</div><div class="line">        IMyDemo demoRemote = consumerContext.getBean(IMyDemo.class);</div><div class="line">        System.out.println(demoRemote.sayHello(<span class="string">"world"</span>));</div><div class="line">        Thread.sleep(<span class="number">30000</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>运行结果：<br>Provider：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-9a802855fd5586a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="remote-provider.png"></p>
</li>
</ul>
<p>启动Provider输出了两遍，Consumer调用时本地实现又输出了一遍，共三遍。<br>Consumer：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-6794e25eaf0c0327.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="consumer.png"><br>启动Consumer，远程返回输出了一遍。</p>
</blockquote>
<h3 id="Dubbo简单监控中心"><a href="#Dubbo简单监控中心" class="headerlink" title="Dubbo简单监控中心"></a>Dubbo简单监控中心</h3><p>简单介绍，其实用处不大，我觉得管理后台的功能已经把这个监控中心的功能覆盖了，仅仅只是拿来测试使用一下。</p>
<blockquote>
<ul>
<li><p>主界面：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-c8de1b541c1094cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="simple-monitor.png"></p>
</li>
<li><p>服务列表界面，显示所有服务以及它的Provider和Consumer情况：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-4ab87c1e40a1f97a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="simple-monitor-Service.png"></p>
</li>
</ul>
</blockquote>
<h3 id="Dubbo管理后台使用"><a href="#Dubbo管理后台使用" class="headerlink" title="Dubbo管理后台使用"></a>Dubbo管理后台使用</h3><p>之前Tomcat中配置好了dubbo-admin的webapp，现在只要打开tomcat，并输入相应的地址即可访问dubbo-admin的界面，如我的是<code>http://127.0.0.1:8080/dubbo-admin/</code>。<br>其实就是一个很常见的管理后台，可以控制每个服务、应用的状态、权重、路由控制、访问控制、负载均衡、各个应用的服务情况和消费情况等，不需要教程，直接上手使用即可，至于其中的一些可能有疑问的概念，下面的内容将一一说明。</p>
<h3 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h3><p>路由，顾名思义，就是通过配置去设定哪些Consumer节点的请求由哪些节点的Provider节点的服务来进行响应，可以在一定程度上控制负载分布。<br>知道这个概念，那剩下就是配置的问题了，明白怎么回事其实就很简单啦~</p>
<p>在dubbo-admin<code>主界面</code>——<code>服务治理</code>——<code>路由规则</code>，如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-e8b493fedb3b993c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-main.png"></p>
<p>点击<code>新增</code>：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-9682cecfb9d34518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-new.png"></p>
<p><code>路由名称</code>:为你定义的这个路由规则声明一个名称，之后可以根据这个名称来找这个路由规则。<br><code>优先级</code>:很明显，一个int数值代表这个路由规则的优先级，优先级越高这个规则越先匹配。<br><code>服务名</code>:列表选择的，从注册中心中已有的服务列表中选择一个服务，表示这个路由规则要约束的是哪个服务。<br><code>方法名</code>:列表选择的，选择要约束的这个服务中的哪个方法。<br><code>匹配条件</code>:填写<code>匹配</code>下面的列表就表示匹配了条件才受这个路由规则约束，否则就是不匹配规则才受该规则约束。<br><code>消费者IP地址</code>:要约束的Consumer的IP地址列表，逗号隔开。<br><code>消费者应用名</code>:要约束的Consumer的应用名列表。<br><code>消费者集群</code>:按照提示上写的去找，没找到相应的选项，暂时也没用到，之后再回头编辑。<br><code>过滤规则</code>:填写<code>匹配</code>下面的列表就表示匹配了条件才受这个路由规则约束，否则就是不匹配规则才受该规则约束。<br><code>提供者IP地址</code>:要约束的Provider的IP地址列表，逗号隔开。<br><code>提供者集群</code>:按照提示上写的去找，没找到相应的选项，暂时也没用到，之后再回头编辑。<br><code>提供者协议</code>:指定Provider的协议，不是该协议的也不约束。<br><code>提供者端口</code>:指定Provider的端口，不是这个端口的也不约束。</p>
<p>测试样例展示：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-109861dc573b0721.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-sample.png"></p>
<p>这样配置的路由就能够生效，效果是：<code>com.weidian.dubbo.IMyDemo</code>服务的<code>sayHello</code>方法下，地址为<code>192.168.31.164</code>的Consumer的请求由（地址：<code>192.168.31.164</code>；协议：<code>dubbo</code>；端口：<code>20880</code>）的Provider进行响应，如果没有匹配的Provider就会默认返回所有的Provider列表给Consumer，让Consumer自己选。<br>点击<code>保存</code>，保存新增的路由规则，并在路由规则列表中启用这个规则，如下：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-70b56949264cf927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-list.png"></p>
<p>点击<code>预览</code>，在消费者地址填写192.168.31.164，点击预览，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-cf0c715ff0276f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-success.png"></p>
<p>运行Consumer程序，查看消费者状态，可知设定的这个路由规则对该对应地址的消费真生效了，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-02922d6c57c73d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="router-consumer.png"></p>
<p>另外，IP地址支持结尾为<em>匹配所有，如10.0.0.</em>或者10.0.*等。<br>不匹配的配置规则和匹配的配置规则是一致的。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>dubbo提供4种负载均衡方式:<br><code>Random</code>：随机，按权重配置随机概率，调用量越大分布越均匀，默认是这种方式<br><code>RoundRobin</code>：轮询，按权重设置轮询比例，如果存在比较慢的机器容易在这台机器的请求阻塞较多<br><code>LeastActive</code>：最少活跃调用数，不支持权重，只能根据自动识别的活跃数分配，不能灵活调配<br><code>ConsistentHash</code>：一致性hash，对相同参数的请求路由到一个服务提供者上，如果有类似灰度发布需求可采用<br>dubbo的负载均衡机制是在客户端调用时通过内存中的服务方信息及配置的负责均衡策略选择，如果对自己系统没有一个全面认知，建议先采用random方式。</p>
<blockquote>
<ul>
<li>软负载均衡算法：<a href="http://www.cnblogs.com/xrq730/p/5154340.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/5154340.html</a></li>
</ul>
</blockquote>
<h3 id="Dubbo过滤器"><a href="#Dubbo过滤器" class="headerlink" title="Dubbo过滤器"></a>Dubbo过滤器</h3><p>有需要自己实现dubbo过滤器的，可关注如下步骤：</p>
<ol>
<li><p>dubbo初始化过程加载ClassPath下的<code>META-INF/dubbo/internal/</code>，<code>META-INF/dubbo/</code>，<code>META-INF/services/</code>三个路径(classloader resource)下面的<code>com.alibaba.dubbo.rpc.Filter</code>文件。<br>文件内容：<br>每行<code>Name</code>=<code>FullClassName</code>，这些类必须是实现Filter接口，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-bc7e16a034a40ec9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter-prop.png"></p>
</li>
<li><p>自定义Filter类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.Constants;</div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.Activate;</div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.*;</div><div class="line"><span class="comment">//激活这个过滤器的注解，标记这个过滤器在消费者端加入过滤器链</span></div><div class="line"><span class="meta">@Activate</span>(group = Constants.CONSUMER)</div><div class="line"><span class="comment">//dubbo过滤器的实现类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboTestFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line">    <span class="comment">/**计时器过滤器，记录这个RPC的整个过程执行时间</span></div><div class="line">     * <span class="doctag">@param</span> invoker</div><div class="line">     * <span class="doctag">@param</span> invocation</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     * <span class="doctag">@throws</span> RpcException</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="comment">//这个是RPC的实现体，Result就是RPC的执行结果，和Servlet的过滤器有些类似</span></div><div class="line">        Result result = invoker.invoke(invocation);</div><div class="line">        System.out.println(<span class="string">"time = "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line">        System.out.println(result.getValue());</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>consumer.xml配置文件中配置这个过滤器，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-f51971f7810ba245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter-spring.png"></p>
</li>
<li><p>先来看看配置完成之后的执行效果：<br><img src="http://upload-images.jianshu.io/upload_images/3932187-09de3a34c4ab619c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="filter-run.png"></p>
</li>
</ol>
<blockquote>
<p>对比上面的过滤器代码可知，先输出了RPC过程的运行时间，之后在过滤器中输出了一遍执行结果<code>hello world</code>，之后单元测试本身再把执行结果输出一遍，因此<code>hello world</code>输出了两遍。</p>
</blockquote>
<ol>
<li>Dubbo过于这个过滤器的加载过程：<blockquote>
<p>(1) 先加载那三个路径下的<code>com.alibaba.dubbo.rpc.Filter</code>文件里面的键值对，key为过滤器的名称，value为过滤器的类全限定名（这个类必须实现Dubbo中的Filter接口）；<br>(2) 这样就能找到这个类的class文件了，检查<code>@Activate</code>注解加载这个过滤器设定的一些全局基本属性；<br>(3) Spring在加载consumer.xml文件的时候，通过</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dubbo:consumer</span> <span class="attr">filter</span>=<span class="string">"dubboTestFilter"</span> <span class="attr">id</span>=<span class="string">"dubboTestFilter"</span> <span class="attr">retries</span>=<span class="string">"0"</span>/&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>指定消费者端要加载的过滤器，通过<code>filter</code>属性指定过滤器名称（就是配置文件中的过滤器key），这样刚才加载的过滤器类就加入消费者代码逻辑中的过滤器链了。</p>
<ol>
<li>关于<code>@Activate</code>注解： —— 自动激活<blockquote>
<p><code>group</code>：(provider|consumer）匹配了对应的角色才被加载<br><code>value</code>：标明过滤条件，不写则所有条件下都会被加载，写了则只有dubbo URL中包含该参数名且参数值不为空才被加载，这个参数会以dubbo协议的一个参数K-V对传到Provider。</p>
</blockquote>
</li>
</ol>
<h2 id="Dubbo-Rest风格服务"><a href="#Dubbo-Rest风格服务" class="headerlink" title="Dubbo Rest风格服务"></a>Dubbo Rest风格服务</h2><ol>
<li>当当Dubbox：<a href="https://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="external">https://dangdangdotcom.github.io/dubbox/rest.html</a></li>
<li>Dubbo Rest风格服务开发：<a href="https://segmentfault.com/a/1190000005170426" target="_blank" rel="external">https://segmentfault.com/a/1190000005170426</a></li>
</ol>
<hr>
<h4 id="还欠缺安全保护和集群性能调优方面的讲解，毕竟才刚入门，待我在公司的项目中使用一段时间有了真正的一些实战感悟再来好好总结"><a href="#还欠缺安全保护和集群性能调优方面的讲解，毕竟才刚入门，待我在公司的项目中使用一段时间有了真正的一些实战感悟再来好好总结" class="headerlink" title="还欠缺安全保护和集群性能调优方面的讲解，毕竟才刚入门，待我在公司的项目中使用一段时间有了真正的一些实战感悟再来好好总结~"></a>还欠缺安全保护和集群性能调优方面的讲解，毕竟才刚入门，待我在公司的项目中使用一段时间有了真正的一些实战感悟再来好好总结~</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Dubbo是什么&quot;&gt;&lt;a href=&quot;#Dubbo是什么&quot; class=&quot;headerlink&quot; title=&quot;Dubbo是什么&quot;&gt;&lt;/a&gt;Dubbo是什么&lt;/h3&gt;&lt;p&gt;Dubbo是Alibaba开源的分布式服务框架，它最大的特点是按照分层的方式来架构，使用这种
    
    </summary>
    
      <category term="微服务" scheme="http://www.coselding.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Java" scheme="http://www.coselding.cn/tags/Java/"/>
    
      <category term="RPC" scheme="http://www.coselding.cn/tags/RPC/"/>
    
      <category term="Dubbo" scheme="http://www.coselding.cn/tags/Dubbo/"/>
    
      <category term="SOA" scheme="http://www.coselding.cn/tags/SOA/"/>
    
      <category term="分布式" scheme="http://www.coselding.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper配置和学习笔记</title>
    <link href="http://www.coselding.cn/2017/01/02/ZooKeeper%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.coselding.cn/2017/01/02/ZooKeeper配置和学习笔记/</id>
    <published>2017-01-02T09:21:38.000Z</published>
    <updated>2017-01-02T09:21:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ZooKeeper介绍"><a href="#ZooKeeper介绍" class="headerlink" title="ZooKeeper介绍"></a>ZooKeeper介绍</h3><ol>
<li>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将从使用者角度详细介绍 Zookeeper 的安装和配置文件中各个配置项的意义，以及分析 Zookeeper 的典型的应用场景（配置文件的管理、集群管理、同步锁、Leader 选举、队列管理等）。</li>
<li>简单说下我的理解：<blockquote>
<ul>
<li>ZooKeeper有三种工作模式：<blockquote>
<ul>
<li><code>Standalone</code>：单点模式，有单点故障问题。</li>
<li><code>伪分布式</code>：在一台机器同时运行多个ZooKeeper实例，仍然有单点故障问题，当然，其中配置的端口号要错开的，适合实验环境模拟集群使用。</li>
<li><code>完全分布式</code>：在多台机器上部署ZooKeeper集群，适合线上环境使用。</li>
</ul>
</blockquote>
</li>
<li>ZooKeeper到底是什么：<blockquote>
<ul>
<li><code>三种端口号</code>：这里先说明三个ZooKeeper配置需要的端口号，因为后面的解释中会经常引用，就拉到前面讲啦<blockquote>
<ul>
<li><strong>端口X</strong>：客户端连接ZooKeeper集群使用的监听端口号</li>
<li><strong>端口Y</strong>：leader和follower之间数据同步使用的端口号</li>
<li><strong>端口Z</strong>：leader选举专用的端口号</li>
</ul>
</blockquote>
</li>
<li><code>单点分析</code>：在每个ZooKeeper节点当中，ZooKeeper维护了一个类似linux的树状文件系统结构，可以把一些配置信息，数据等存放到ZooKeeper当中，也可以把ZooKeeper当中的一个目录节点当做一个锁的互斥文件来实现并发安全控制，你看到这就先把ZooKeeper理解为一个在操作系统上运行的一个虚拟文件系统，只不过他不是像HDFS那样真的用来存放文件的，他是利用文件系统的节点作为底层实现来提供分布式环境很常用的功能，这在后面的<code>实战使用</code>会具体讲解.</li>
<li><code>集群分析</code>：ZooKeeper中的每个节点都是上面的<code>单点分析</code>那样工作的，但是集群多节点之间到底如何进行协商和通信呢？<blockquote>
<ul>
<li>首先，类似mysql读写分离那样，ZooKeeper的每个节点都存放相同的数据，因此访问ZooKeeper的时候会被分流道各个节点实现高并发，多节点也顺便实现了高可用。</li>
<li>ZooKeeper的节点之间也有主次关系，集群启动完成之后，ZooKeeper会运行选举程序（端口Z）从集群中选择一个leader节点，而其他的节点就是follower节点，对于ZooKeeper的写操作，会被转发到leader节点，而follower节点和leader节点的数据同步（端口Y）也在后台自动实现，读操作则每个节点都能提供，负载均衡~</li>
<li><code>容灾机制</code>：follower节点挂了比较不要紧，有leader协调，整个集群还不至于发生致命影响。但是leader节点要是挂了，就群龙无首了，但是其实这个状态和ZooKeeper集群启动前期还没确定leader节点的时候是一样的状态，下面讲解这个状态如何进行leader的 选举。<br>由于每个节点配置文件中都维护了整个ZooKeeper集群的所有节点列表，因此在没确定leader节点或者leader节点挂掉的时候，每个节点向leader的通信必然是失败的，follower节点就是这么发现leader节点挂了的，这个时候他就能启动选举程序进行leader竞选，和其他的所有follower节点进行通信，根据某种算法方案确定leader的节点之后，被选中的节点就启动leader的程序，化身leader重新领导整个集群。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>客户端访问高可用：<blockquote>
<ul>
<li><code>读操作</code>：每个节点都能响应</li>
<li><code>写操作</code>：不管向哪个节点请求都会转发到leader节点执行，再把数据同步到各个follower节点。</li>
<li><code>访问follower节点宕机</code>：客户端会保存一个地址列表，会自动使用另一个地址进行访问，实在不行还有leader节点分配地址再次访问呢，而且一旦客户端和服务器的连接被断开，客户端就会自动去连接另一个节点的地址进行请求。</li>
<li><code>访问leader节点宕机</code>：也是使用这个地址列表，如果是读操作，则leader选举出来之前都能访问，但是如果是写操作，就要等leader选举完成之后才能进行操作。</li>
<li>我之前有疑问的地方就是以为客户端只维护一个节点的地址，这样的话导致了这个节点宕机之后客户端就和ZooKeeper集群断开了且无法重新连接了，但是后来知道了客户端是保存了节点地址列表，那所有问题就很好理解啦。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li>好了，说了很多废话你可能有点晕了，但是总说一点，别忘了，现在先把他当成一个树形文件系统~</li>
</ol>
<h3 id="ZooKeeper环境部署和和简单测试"><a href="#ZooKeeper环境部署和和简单测试" class="headerlink" title="ZooKeeper环境部署和和简单测试"></a>ZooKeeper环境部署和和简单测试</h3><ol>
<li>ZooKeeper下载：<a href="http://apache.fayea.com/zookeeper/" target="_blank" rel="external">http://apache.fayea.com/zookeeper/</a></li>
<li>官网文档：<a href="https://zookeeper.apache.org/doc/r3.4.9/" target="_blank" rel="external">https://zookeeper.apache.org/doc/r3.4.9/</a></li>
<li>安装准备：<blockquote>
<ul>
<li>JDK</li>
<li>hosts</li>
<li>防火墙</li>
<li>SELinux</li>
<li>ssh免密码登录</li>
<li>等等这些基本配置前面的Hadoop教程说过了，不再赘述，这些问题我相信都是很容易解决的。</li>
</ul>
</blockquote>
</li>
<li><p>安装步骤总结：</p>
<blockquote>
<p>(1) 创建缓存目录；<br>(2) 配置zookeeper配置文件zoo.cfg，设置缓存目录、监听客户端端口号、server列表配置等<br>(3) bin目录下的zkServer.sh启动即可，还能查看集群中的leader、follower之间的关系</p>
</blockquote>
</li>
<li><p>单机模式：</p>
<blockquote>
<ul>
<li>创建缓存目录;</li>
<li>解压ZooKeeper安装包，在conf目录下的zoo_sample.cfg文件复制一个副本zoo.cfg，在里面进行ZooKeeper整体配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">dataDir=/opt/zookeeper1</div><div class="line">clientPort=2181</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><code>tickTime</code>：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。<br><code>dataDir</code>：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。<br><code>clientPort</code>：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</p>
<ul>
<li><p>bin目录下的zkServer.sh执行即可启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh start</div></pre></td></tr></table></figure>
</li>
<li><p>可以查看ZooKeeper的执行状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh status</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ol>
<li>集群模式：<blockquote>
<ul>
<li>创建缓存目录;</li>
<li>解压ZooKeeper安装包，在conf目录下的zoo_sample.cfg文件复制一个副本zoo.cfg，在里面进行ZooKeeper整体配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">tickTime=2000</div><div class="line">dataDir=/opt/zookeeper1</div><div class="line">clientPort=2181</div><div class="line">initLimit=5</div><div class="line">syncLimit=2</div><div class="line">server.1=192.168.211.1:2888:3888</div><div class="line">server.2=192.168.211.2:2888:3888</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>上面前三个的配置和单机模式一样，不多赘述了。<br><code>initLimit</code>：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5<em>2000=10 秒<br><code>syncLimit</code>：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2</em>2000=4 秒<br><code>server.A=B：C：D</code>：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口(上面的端口Y)；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口(上面的端口Z)。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</p>
<ul>
<li><p>在上面配置的dataDir目录下创建myid文件，填写这个节点上的id号，就是<code>server.A=B：C：D</code>配置的A那个号码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># cat /opt/zookeeper1/myid</span></div><div class="line">1</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># cat /opt/zookeeper2/myid</span></div><div class="line">2</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># cat /opt/zookeeper3/myid</span></div><div class="line">3</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># cat /opt/zookeeper4/myid</span></div><div class="line">4</div></pre></td></tr></table></figure>
</li>
<li><p>将配置好的整个安装包复制到每个节点机器上，scp命令复制过去，我这里是采用伪分布式，直接使用cp命令即可。</p>
</li>
<li>到每个节点上zookeeper/bin目录下的zkServer.sh执行即可启动：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/zkServer.sh start</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其他脚本介绍：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">zkServer.sh     ： ZooKeeper服务器的启动、停止和重启脚本；</div><div class="line">zkCli.sh        ： ZooKeeper的简易客户端；</div><div class="line">zkEnv.sh        ： 设置ZooKeeper的环境变量；</div><div class="line">zkCleanup.sh    ： 清理ZooKeeper历史数据，包括事务日志文件和快照数据文件。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>可以查看ZooKeeper的执行状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zookeeper/bin/zkServer.sh status</div></pre></td></tr></table></figure>
</li>
<li><p>简单说明这样的配置ZooKeeper集群是怎么工作的：</p>
<blockquote>
<ul>
<li>首先，每个节点上zoo.cfg配置文件中都有整个集群的列表，所以每个节点之间的通信都是可行的。</li>
<li>然后是dataDir目录下的myid标记了这个机器上的这个节点是zoo.cfg上的集群列表的哪个记录，从这个就能知道当前的这个节点所处的位置，也能知道当前机器的节点是不是leader，以便于执行leader该执行的程序。</li>
<li>关于配置的三个端口号：<blockquote>
<ul>
<li><strong>端口X</strong>：监听客户端连接的，没什么可说的</li>
<li><strong>端口Y</strong>：follower和leader进行数据同步通信用的，这个是长连接随时同步数据，健康情况下正常运行，leader宕机就无法正常执行，此时触发选举程序选择新的leader。</li>
<li><strong>端口Z</strong>：选举时各个follower节点之间两两可以相互通信的，以便于成功选择出leader。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><code>踩坑记录</code>：我刚开始以为端口X和端口Y是同一个，导致了我就设置了同一个端口号，所以显然是无法启动成功的，后来知道这两个端口号完成的是不同的功能，所以改正完成就能启动成功了。</li>
</ul>
</blockquote>
<ol>
<li>可以创建一个启动脚本一次性启动整个集群，比如我搭建的伪分布式的启动脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/sh</span></div><div class="line">/usr/java/zookeeper/zookeeper1/bin/zkServer.sh start</div><div class="line">/usr/java/zookeeper/zookeeper2/bin/zkServer.sh start</div><div class="line">/usr/java/zookeeper/zookeeper3/bin/zkServer.sh start</div><div class="line">/usr/java/zookeeper/zookeeper4/bin/zkServer.sh start</div><div class="line">/usr/java/zookeeper/zookeeper1/bin/zkServer.sh status</div><div class="line">/usr/java/zookeeper/zookeeper2/bin/zkServer.sh status</div><div class="line">/usr/java/zookeeper/zookeeper3/bin/zkServer.sh status</div><div class="line">/usr/java/zookeeper/zookeeper4/bin/zkServer.sh status</div><div class="line"><span class="built_in">echo</span> <span class="string">'you can use zookeeper client connect to 119.29.153.56 on follow ports:'</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'2181'</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'2182'</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'2183'</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'2184'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>各个节点的启动状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># /usr/java/zookeeper/zookeeper1/bin/zkServer.sh status</span></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /usr/java/zookeeper/zookeeper1/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># /usr/java/zookeeper/zookeeper2/bin/zkServer.sh status</span></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /usr/java/zookeeper/zookeeper2/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># /usr/java/zookeeper/zookeeper3/bin/zkServer.sh status</span></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /usr/java/zookeeper/zookeeper3/bin/../conf/zoo.cfg</div><div class="line">Mode: leader</div><div class="line">[root@VM_68_145_centos zookeeper]<span class="comment"># /usr/java/zookeeper/zookeeper4/bin/zkServer.sh status</span></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /usr/java/zookeeper/zookeeper4/bin/../conf/zoo.cfg</div><div class="line">Mode: follower</div></pre></td></tr></table></figure></p>
<p>启动完成之后顺便查看了每个节点充当的是leader还是follower，并把集群的所有客户端连接端口号输出出来，从上面的执行结果可知，zookeeper3的这个实例是leader，其他实例是follower。</p>
</blockquote>
<ol>
<li>ZooKeeper简单操作测试：<blockquote>
<ul>
<li>命令行方式操纵ZooKeeper：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 进入本地的ZooKeeper：</span></div><div class="line">/usr/java/zookeeper/zookeeper1/bin/zkCli.sh</div><div class="line"><span class="comment"># 进入远程的ZooKeeper：</span></div><div class="line">/usr/java/zookeeper/zookeeper1/bin/zkCli.sh -server &#123;ip&#125;:&#123;port&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>这样就进入了ZooKeeper的命令行客户端，就能访问指定的ZooKeeper集群中的数据，支持以下的操作（在命令行下输入错误命令就能看到提示了。。。）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">stat</span> path [watch]</div><div class="line">	<span class="built_in">set</span> path data [version]</div><div class="line">	ls path [watch]</div><div class="line">	delquota [-n|-b] path</div><div class="line">	ls2 path [watch]</div><div class="line">	<span class="built_in">set</span>Acl path acl</div><div class="line">	setquota -n|-b val path</div><div class="line">	<span class="built_in">history</span></div><div class="line">	redo cmdno</div><div class="line">	printwatches on|off</div><div class="line">	delete path [version]</div><div class="line">	sync path</div><div class="line">	listquota path</div><div class="line">	rmr path</div><div class="line">	get path [watch]</div><div class="line">	create [<span class="_">-s</span>] [<span class="_">-e</span>] path data acl</div><div class="line">	addauth scheme auth</div><div class="line">	quit</div><div class="line">	getAcl path</div><div class="line">	close</div><div class="line">	connect host:port</div></pre></td></tr></table></figure></p>
<ul>
<li>操作示例：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建节点/testInput，节点中的数值为inputData</span></div><div class="line">create /<span class="built_in">test</span>Input <span class="string">"inputData"</span></div><div class="line"><span class="comment"># 查询刚才插入的节点</span></div><div class="line">get /<span class="built_in">test</span>Input</div><div class="line"><span class="comment"># 运行结果</span></div><div class="line">inputData</div><div class="line">cZxid = 0x300000006</div><div class="line">ctime = Sun Dec 18 21:47:21 CST 2016</div><div class="line">mZxid = 0x300000006</div><div class="line">mtime = Sun Dec 18 21:47:21 CST 2016</div><div class="line">pZxid = 0x300000006</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 9</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure>
</li>
</ul>
<p>所以整个操纵的过程就和平时操作linux文件的感觉差不多，下面的Java程序操纵其实也只是对这些命令行的封装，下面也给出一些示例。</p>
</blockquote>
<ol>
<li>Java客户端操纵ZooKeeper：<blockquote>
<ul>
<li>这里也只简单示例一些基本操作：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperClient</span> </span>&#123;</div><div class="line">    <span class="comment">//同步互斥变量，用来阻塞等待ZooKeeper连接完成之后再进行ZooKeeper的操作命令</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch connectedSemaphore = <span class="keyword">new</span> CountDownLatch( <span class="number">1</span> );</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">// 创建一个与服务器的连接</span></div><div class="line">        ZooKeeper zk = <span class="keyword">new</span> ZooKeeper(<span class="string">"119.29.153.56:2181"</span>,<span class="number">3000</span>, <span class="keyword">new</span> Watcher() &#123;<span class="comment">//这个是服务器连接完成回调的监听器</span></div><div class="line">            <span class="comment">// 监控所有被触发的事件</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"已经触发了"</span> + event.getType() + <span class="string">"事件！"</span>);</div><div class="line">                <span class="keyword">if</span> ( Event.KeeperState.SyncConnected == event.getState() ) &#123;</div><div class="line">                    <span class="comment">//连接完成的同步事件，互斥变量取消，下面的阻塞停止，程序继续执行</span></div><div class="line">                    connectedSemaphore.countDown();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="comment">//如果和ZooKeeper服务器的TCP连接还没完全建立，就阻塞等待</span></div><div class="line">        connectedSemaphore.await();</div><div class="line">        <span class="comment">// 创建一个目录节点</span></div><div class="line">        zk.create(<span class="string">"/testRootPath"</span>, <span class="string">"testRootData"</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,</div><div class="line">                CreateMode.PERSISTENT);</div><div class="line">        <span class="comment">// 创建一个子目录节点</span></div><div class="line">        zk.create(<span class="string">"/testRootPath/testChildPathOne"</span>, <span class="string">"testChildDataOne"</span>.getBytes(),</div><div class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</div><div class="line">        System.out.println(<span class="keyword">new</span> String(zk.getData(<span class="string">"/testRootPath"</span>,<span class="keyword">false</span>,<span class="keyword">null</span>)));</div><div class="line">        <span class="comment">// 取出子目录节点列表</span></div><div class="line">        System.out.println(zk.getChildren(<span class="string">"/testRootPath"</span>,<span class="keyword">true</span>));</div><div class="line">        <span class="comment">// 修改子目录节点数据</span></div><div class="line">        zk.setData(<span class="string">"/testRootPath/testChildPathOne"</span>,<span class="string">"modifyChildDataOne"</span>.getBytes(),-<span class="number">1</span>);</div><div class="line">        System.out.println(<span class="string">"目录节点状态：["</span>+zk.exists(<span class="string">"/testRootPath"</span>,<span class="keyword">true</span>)+<span class="string">"]"</span>);</div><div class="line">        <span class="comment">// 创建另外一个子目录节点</span></div><div class="line">        zk.create(<span class="string">"/testRootPath/testChildPathTwo"</span>, <span class="string">"testChildDataTwo"</span>.getBytes(),</div><div class="line">                ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);</div><div class="line">        System.out.println(<span class="keyword">new</span> String(zk.getData(<span class="string">"/testRootPath/testChildPathTwo"</span>,<span class="keyword">true</span>,<span class="keyword">null</span>)));</div><div class="line">        <span class="comment">// 删除子目录节点</span></div><div class="line">        zk.delete(<span class="string">"/testRootPath/testChildPathTwo"</span>,-<span class="number">1</span>);</div><div class="line">        zk.delete(<span class="string">"/testRootPath/testChildPathOne"</span>,-<span class="number">1</span>);</div><div class="line">        <span class="comment">// 删除父目录节点</span></div><div class="line">        zk.delete(<span class="string">"/testRootPath"</span>,-<span class="number">1</span>);</div><div class="line">        <span class="comment">// 关闭连接</span></div><div class="line">        zk.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">已经触发了None事件！</div><div class="line"><span class="built_in">test</span>RootData</div><div class="line">[<span class="built_in">test</span>ChildPathOne]</div><div class="line">目录节点状态：[17179869200,17179869200,1482114759242,1482114759242,0,1,0,0,12,1,17179869201</div><div class="line">]</div><div class="line">已经触发了NodeChildrenChanged事件！</div><div class="line"><span class="built_in">test</span>ChildDataTwo</div><div class="line">已经触发了NodeDeleted事件！</div><div class="line">已经触发了NodeDeleted事件！</div></pre></td></tr></table></figure></p>
<p><code>解释</code>：<br>第一个添加节点/testRootPath，触发None事件，之后再获取这个节点数据、其子节点列表、节点状态<br>接下来创建第二个子节点/testRootPath/testChildPathTwo，触发NodeChildrenChanged事件<br>然后删除两个子节点，触发两次NodeDeleted事件</p>
<ul>
<li><strong>常用接口介绍</strong>：<blockquote>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external"><code>IBM教程</code></a>这边已经有部分接口的说明，可以拿来当做初步认识，在比较下面，往下翻哦~。</li>
<li>几个可能的疑问：<br><code>ACL</code>：这个是ZooKeeper本身提供的简单的权限控制模型，有一些简单的权限控制策略，可以稍做了解。<br><code>OP</code>：面向对象的思想嘛，一个ZooKeeper的操作命令也抽象为一个操作对象，不过它只是个抽象类，具体的实现有Delete、Check等子类才是实际的具体操作对象。<br><code>CreateMode</code>：创建节点的模式枚举，四个成员分别是：PERSISTENT（持久化）、PERSISTENT_SEQUENTIAL（持久化并序号自增）、EPHEMERAL（临时，当前session有效）、EPHEMERAL_SEQUENTIAL（临时，当前session有效，序号自增）<br><code>ZooDefs.Ids</code>：提供了上面<code>ACL</code>的常用的权限策略常量列表。<br><code>Event.KeeperState</code>：ZooKeeper的事件类型状态常量列表。</li>
<li>有了上面的就基本对ZooKeeper的API有了初步的认识，剩下的问题看官方文档就很好理解了：<a href="http://people.apache.org/~larsgeorge/zookeeper-1215258/build/docs/dev-api/" target="_blank" rel="external">http://people.apache.org/~larsgeorge/zookeeper-1215258/build/docs/dev-api/</a></li>
</ul>
</blockquote>
</li>
<li><h4 id="特别注意：ZooKeeper是支持Watcher监听的，你可以用它监听某个节点的值是否存在、是否改变、是否被删除等之类的动作，当他触发了相关的动作就会进行回调的，有点是异步编程，也是特别棒的东西。"><a href="#特别注意：ZooKeeper是支持Watcher监听的，你可以用它监听某个节点的值是否存在、是否改变、是否被删除等之类的动作，当他触发了相关的动作就会进行回调的，有点是异步编程，也是特别棒的东西。" class="headerlink" title="特别注意：ZooKeeper是支持Watcher监听的，你可以用它监听某个节点的值是否存在、是否改变、是否被删除等之类的动作，当他触发了相关的动作就会进行回调的，有点是异步编程，也是特别棒的东西。"></a><strong>特别注意：ZooKeeper是支持<code>Watcher监听</code>的，你可以用它监听某个节点的值是否存在、是否改变、是否被删除等之类的动作，当他触发了相关的动作就会进行<code>回调</code>的，有点是异步编程，也是特别棒的东西。</strong></h4>到这里入门就告一段落了，接下来就是实际应用场景的分析啦~</li>
</ul>
</blockquote>
<h3 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h3><ol>
<li><code>统一命名服务（Name Service）</code>：在ZooKeeper的树形结构下你可以创建一个统一的不重复的命名，比如create创建一个节点即可，再创建一个相同名称的节点是不允许的。</li>
<li><code>配置管理（Configuration Management）</code>：意思就是分布式应用的配置可以交给ZooKeeper来管理，不然一旦修改配置，就得每台机器上的配置都做相应的修改，如果交给ZooKeeper管理的话，只需要修改ZooKeeper上的节点值即可。</li>
<li><code>集群管理（Group Membership）</code>：<blockquote>
<ul>
<li>Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。</li>
<li>它们的实现方式都是在 Zookeeper上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。</li>
<li>Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。</li>
</ul>
</blockquote>
</li>
<li><code>共享锁（Locks）</code>：共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。</li>
<li><code>队列管理</code>：<blockquote>
<ul>
<li><code>同步队列</code>：<br>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。<br>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。<br>同步队列用 Zookeeper 实现的实现思路如下：<br>创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。</li>
<li><code>FIFO队列</code>：<br>实现的思路也非常简单，就是在特定的目录下创建 SEQUENTIAL 类型的子目录 /queue_i，这样就能保证所有成员加入队列时都是有编号的，出队列时通过 getChildren( ) 方法可以返回当前所有的队列中的元素，然后消费其中最小的一个，这样就能保证 FIFO。</li>
</ul>
</blockquote>
</li>
<li><strong>可见ZooKeeper本身的树形目录结构以及其提供的对目录节点的<code>监控Watcher</code>，提供了实时数据同步以及可客户端的及时通知。并且利用节点之间的变化<code>触发的事件类型</code>可以很方便地设计很多实际应用场景的算法需求。</strong>具体的很多说明和算法示例代码在<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external">IBM教程</a>中有详细的讲解。</li>
</ol>
<h3 id="常用分布式服务框架和ZooKeeper的依赖讲解"><a href="#常用分布式服务框架和ZooKeeper的依赖讲解" class="headerlink" title="常用分布式服务框架和ZooKeeper的依赖讲解"></a>常用分布式服务框架和ZooKeeper的依赖讲解</h3><blockquote>
<ul>
<li>之前的<code>Hadoop 2.x</code>高可用配置使用了ZooKeeper，但是我根本不知道这个外部添加的ZooKeeper工具是怎么被Hadoop调用的，当时只是知道按照教程一步步下来就能成功运行，不过现在好好把ZooKeeper研究完了，就该来好好回顾一下这个问题了。</li>
<li>这个是之前的Hadoop 2.x的高可用安装配置教程：<a href="http://www.coselding.cn/article/2016-05-31/hadoop2-high-available.html">http://www.coselding.cn/article/2016-05-31/hadoop2-high-available.html</a></li>
<li>具体的过程就不在这里重复说明了，只挑要点讲解：</li>
</ul>
<ol>
<li>Hadoop 2.x启动前要求先把ZooKeeper配置好并启动起来，这个时候ZooKeeper还是独立运行的。</li>
<li>Hadoop 2.x配置完成之后在启动步骤中有一步：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hdfs zkfc -formatZK</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这步干嘛的？这个时候Hadoop中的多个NameNode节点都已经配置好了，这个步骤就是把NameNode的信息注册到ZooKeeper当中，包括哪个是Active，有哪些Standby，都在ZooKeeper当中进行注册记录，并且有一个<code>ZKFC</code>进程负责观察NameNode的状态，如果有NameNode宕机了，就马上通知ZooKeeper进行相应的记录修改，也就是说，ZooKeeper当中实时存放着NameNode的节点列表以及哪个是Active。（这部分的实时记录和更新代码存在ZKFC当中，是Hadoop本身就已经实现的代码，不需要我们自己编写，配置好就行）。</p>
<ol>
<li>Hadoop怎么知道ZooKeeper的存在？<code>hdfs-site.xml</code>中不是配置了<code>dfs.nameservices</code>这个属性吗，这个属性就是告诉Hadoop ZooKeeper的地址，Hadoop通过这个地址连接到ZooKeeper注册NameNode的命名信息，这个动作由<code>hdfs zkfc -formatZK</code>这个命令触发初始化执行。</li>
<li>到这步就已经知道了，Hadoop中的NameNode的信息ZooKeeper都知道了，那我们是怎么访问HDFS的呢？教程中很清楚说明了，我们访问的是<code>hdfs-site.xml</code>中配置的<code>dfs.nameservices</code>来访问HDFS的，这个地址刚才说了，就是ZooKeeper的地址，所以在访问HDFS的时候就是先访问了ZooKeeper得到当前的Active NameNode，然后再用得到的Active NameNode地址再去访问HDFS。</li>
<li>Hadoop的Active NameNode宕机呢？<code>ZKFC</code>时刻检测着NameNode，当NameNode宕机的时候，通知ZooKeeper，ZooKeeper保存了所有的NameNode的地址列表，他去通知所有的Standby NameNode进行<code>抢锁竞选</code>，谁抢到不重要，结果是会有一个Standby NameNode抢到锁并切换为Active NameNode，并通知ZooKeeper，这个时候ZooKeeper中的数据依然是实时最新的，很完美~</li>
<li>这不实现了高可用和主备自动切换吗~ 简单粗暴~</li>
</ol>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><blockquote>
<ul>
<li>IBM教程：<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li>
<li>官网文档：<a href="https://zookeeper.apache.org/doc/r3.4.9/" target="_blank" rel="external">https://zookeeper.apache.org/doc/r3.4.9/</a></li>
<li>参考博客：<a href="http://luchunli.blog.51cto.com/2368057/1681841" target="_blank" rel="external">http://luchunli.blog.51cto.com/2368057/1681841</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ZooKeeper介绍&quot;&gt;&lt;a href=&quot;#ZooKeeper介绍&quot; class=&quot;headerlink&quot; title=&quot;ZooKeeper介绍&quot;&gt;&lt;/a&gt;ZooKeeper介绍&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Zookeeper 分布式服务框架是 Apache Ha
    
    </summary>
    
      <category term="分布式" scheme="http://www.coselding.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="集群管理" scheme="http://www.coselding.cn/tags/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    
      <category term="选举" scheme="http://www.coselding.cn/tags/%E9%80%89%E4%B8%BE/"/>
    
      <category term="zookeeper" scheme="http://www.coselding.cn/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Pushy入门文档中文翻译</title>
    <link href="http://www.coselding.cn/2016/12/21/Pushy%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/"/>
    <id>http://www.coselding.cn/2016/12/21/Pushy入门文档中文翻译/</id>
    <published>2016-12-20T20:14:38.000Z</published>
    <updated>2016-12-20T20:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pushy"><a href="#pushy" class="headerlink" title="pushy"></a>pushy</h1><h3 id="这是我自己的翻译版本，原文地址。"><a href="#这是我自己的翻译版本，原文地址。" class="headerlink" title="这是我自己的翻译版本，原文地址。"></a>这是我自己的翻译版本，<a href="https://github.com/relayrides/pushy/blob/master/README.md" target="_blank" rel="external">原文地址</a>。</h3><p>Pushy 是一个发送 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ApplePushService.html" target="_blank" rel="external">APNs</a> (iOS, OS X, 或 Safari) 推送通知的Java类库。这是一个<a href="https://turo.com/" target="_blank" rel="external">Turo</a>创建和维护的项目。</p>
<p>Pushy 使用Apple的基于HTTP/2的APNs协议来推送通知。她区别于其他类库的主要特征在于 <a href="http://relayrides.github.io/pushy/apidocs/0.8/" target="_blank" rel="external">完善的文档</a>，异步任务操作和为了工业规模而设计；对于Pushy来说,维持多个和APNs网关服务器的并行连接发送大量的通知到多个不同的app(“topics”)，是很简单又高效的。</p>
<p>我们坚信Pushy已经是发送APNs推送通知的最好的Java应用程序工具，我们希望您能通过报告bug或pull代码请求来使这个项目越来越好。 如果你有任何关于使用Pushy的问题，请加入我们<a href="https://groups.google.com/d/forum/pushy-apns" target="_blank" rel="external">Pushy邮件列表</a> 或者查看我们的<a href="https://github.com/relayrides/pushy/wiki" target="_blank" rel="external">wiki</a>。谢谢！</p>
<h2 id="使用Pushy"><a href="#使用Pushy" class="headerlink" title="使用Pushy"></a>使用Pushy</h2><p>如果你用<a href="http://maven.apache.org/" target="_blank" rel="external">Maven</a>，你可以通过在你的项目中的pom.xml文件中添加以下的依赖声明来向项目中添加Pushy：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.relayrides<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pushy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果你不使用Maven(或者其他像Gradle一样能识别Maven依赖的工具), 你就需要<a href="https://github.com/relayrides/pushy/releases/download/pushy-0.8.1/pushy-0.8.1.jar" target="_blank" rel="external">下载Pushy的jar文件</a>并直接添加到你的项目中。你还需要确认Pushy运行时依赖的以下组件是否在classpath中：</p>
<ul>
<li><a href="http://netty.io/" target="_blank" rel="external">netty 4.1.5</a></li>
<li><a href="https://github.com/google/gson" target="_blank" rel="external">gson 2.6</a></li>
<li><a href="http://www.slf4j.org/" target="_blank" rel="external">slf4j 1.7.6</a> (还需要绑定SLF4J的具体实现，具体详细说明请看下面的<a href="#logging">logging</a>模块)</li>
<li><code>netty-tcnative</code> (1.1.33.Fork22以上版本) 或者 <code>alpn-boot</code>其中之一的组件。具体的讨论请看下面的<a href="#system-requirements">系统准备</a>模块<ul>
<li><a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html" target="_blank" rel="external">alpn-api</a> 如果你选择native SSL provider (<code>alpn-api</code>已经包含在<code>alpn-boot</code>里面了)；请看<a href="#system-requirements">系统需求</a>模块查看详细内容)</li>
</ul>
</li>
</ul>
<p>Pushy的运行和构建需要在Java7以及以上版本。</p>
<h2 id="发送推送通知"><a href="#发送推送通知" class="headerlink" title="发送推送通知"></a>发送推送通知</h2><p>在你开始使用Pushy之前，你需要先做一些准备工作，包括到Apple注册你的app并获得所需的证书。这个准备工作的详细说明请看苹果官方文档的<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/ProvisioningDevelopment.html#//apple_ref/doc/uid/TP40008194-CH104-SW1" target="_blank" rel="external">Provisioning and Development</a>模块。请注意这里有一些<a href="https://github.com/relayrides/pushy/wiki/Certificates" target="_blank" rel="external">警告</a>，特别是Mac OS X 10.11 (El Capitan)以下的版本。</p>
<p>当你的app注册完成并获得相应的证书之后, 要开始推送通知，你需要做的第一件事是使用Pushy创建一个<a href="http://relayrides.github.io/pushy/apidocs/0.8/com/relayrides/pushy/apns/ApnsClient.html" target="_blank" rel="external"><code>ApnsClient</code></a>。客户端需要一个证书和一个私钥向APNs服务器请求认证。保存证书的最常用方法是使用一个私钥加密PKCS#12文件(如果在我写这篇文章的这个时间点你遵守Apple的相关说明和建议，你会使用一个.p12后缀名的文件存储证书):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ApnsClient apnsClient = <span class="keyword">new</span> ApnsClientBuilder()</div><div class="line">        .setClientCredentials(<span class="keyword">new</span> File(<span class="string">"/path/to/certificate.p12"</span>), <span class="string">"p12-file-password"</span>)</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<p>当你创建了一个client实例之后，你就可以连接上APNs网关服务器可。请注意，这个连接过程是异步的；client实例将会马上返回一个Future对象，但在你发送任何推送通知之前，你需要等待这个连接过程完成之后才能进行。请注意，这个<a href="http://netty.io/4.1/api/io/netty/util/concurrent/Future.html" target="_blank" rel="external"><code>Future</code></a>对象是Netty框架中的，它是Java中的<a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" target="_blank" rel="external"><code>Future</code></a>接口的一个拓展，它允许调用者添加监听器或添加methods来检测<code>Future</code>的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Future&lt;Void&gt; connectFuture = apnsClient.connect(ApnsClient.DEVELOPMENT_APNS_HOST);</div><div class="line">connectFuture.await();</div></pre></td></tr></table></figure>
<p>只要你的client实例完成了和APNs服务器的连接，你就可以发送推送通知了。不过在你进行<a href="http://relayrides.github.io/pushy/apidocs/0.8/com/relayrides/pushy/apns/ApnsPushNotification.html" target="_blank" rel="external">推送通知</a>的时候，需要提供这几个数据：目标设备的token，代表app签名的topic，和一个推送通知负载（消息内容）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> SimpleApnsPushNotification pushNotification;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">final</span> ApnsPayloadBuilder payloadBuilder = <span class="keyword">new</span> ApnsPayloadBuilder();</div><div class="line">    payloadBuilder.setAlertBody(<span class="string">"Example!"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">final</span> String payload = payloadBuilder.buildWithDefaultMaximumLength();</div><div class="line">    <span class="keyword">final</span> String token = TokenUtil.sanitizeTokenString(<span class="string">"&lt;efc7492 bdbd8209&gt;"</span>);</div><div class="line"></div><div class="line">    pushNotification = <span class="keyword">new</span> SimpleApnsPushNotification(token, <span class="string">"com.example.myApp"</span>, payload);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和连接服务器一样，发送推送通知也是一个异步过程。你会马上获取一个<code>Future</code>对象，但在你获知你的推送消息是被APNs网关服务器接受还是拒绝之前，还需要等待<code>Future</code>过程完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; sendNotificationFuture =</div><div class="line">        apnsClient.sendNotification(pushNotification);</div></pre></td></tr></table></figure>
<p><code>Future</code>对象的执行结果会有以下三种情形：</p>
<ol>
<li>APNs网关服务器接收推送通知，并尝试将消息投递到token对应的目标设备。</li>
<li>APNs网关服务器拒绝推送通知，并且这是一个永久的错误，您的推送通知将不会被重新投递推送。此外，APNs服务器会给token对应的设备标记一个最近失效时间的<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Chapters/APNsProviderAPI.html#//apple_ref/doc/uid/TP40008194-CH101-SW18" target="_blank" rel="external">时间戳</a>。如果发生这个情况，你应该停止尝试向这个token对应的设备发送任何通知， 除非这个token在这个时间戳之后又重新上线了。</li>
<li><code>Future</code>对象因为一些未知异常而执行失败，这通常是在某种特定情况下的暂时性的失败，调用者应该在问题解决之后对这个推送通知进行重新地投递发送。但如果是在<a href="http://relayrides.github.io/pushy/apidocs/0.8/com/relayrides/pushy/apns/ClientNotConnectedException.html" target="_blank" rel="external"><code>ClientNotConnectedException</code></a>这种情况下投递失败，调用者应该通过调用阻塞方法<a href="http://relayrides.github.io/pushy/apidocs/0.8/com/relayrides/pushy/apns/ApnsClient.html#getReconnectionFuture--" target="_blank" rel="external"><code>ApnsClient#getReconnectionFuture()</code></a>来返回一个<code>Future</code>对象，这个过程其实是在连接断开之后进行自动重连。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">final</span> PushNotificationResponse&lt;SimpleApnsPushNotification&gt; pushNotificationResponse =</div><div class="line">            sendNotificationFuture.get();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pushNotificationResponse.isAccepted()) &#123;</div><div class="line">        System.out.println(<span class="string">"Push notification accepted by APNs gateway."</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Notification rejected by the APNs gateway: "</span> +</div><div class="line">                pushNotificationResponse.getRejectionReason());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pushNotificationResponse.getTokenInvalidationTimestamp() != <span class="keyword">null</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"\t…and the token is invalid as of "</span> +</div><div class="line">                pushNotificationResponse.getTokenInvalidationTimestamp());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">final</span> ExecutionException e) &#123;</div><div class="line">    System.err.println(<span class="string">"Failed to send push notification."</span>);</div><div class="line">    e.printStackTrace();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> ClientNotConnectedException) &#123;</div><div class="line">        System.out.println(<span class="string">"Waiting for client to reconnect…"</span>);</div><div class="line">        apnsClient.getReconnectionFuture().await();</div><div class="line">        System.out.println(<span class="string">"Reconnected."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再强调一遍，返回的这个<code>Future</code>对象是支持监听器的；在实际应用场景中，去等待对每个特定设备的阻塞推送，效率是极其低的。而在<code>Future</code>中添加一个监听器，在推送完成之后回调这个监听器的方法，和阻塞等待每个推送完成这种方式相比起来，显然能够提供更高效的高并发服务。</p>
<p>最后一点，在你的应用程序关闭的时候，你需要断开每个存活的client对象中的连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Future&lt;Void&gt; disconnectFuture = apnsClient.disconnect();</div><div class="line">disconnectFuture.await();</div></pre></td></tr></table></figure>
<p>client关闭连接的过程，也是一个异步过程。client会等待那些已经发送给APNs服务器的，但还没收到APNs服务器回复响应消息的推送通知，等这些消息收到了APNs的回复之后，再断开连接。调用者通常应该确保所有已经发送给APNs服务器的推送通知都得到服务器的回复之后，再关闭和服务器的连接。此外，在Pushy内部维护了一个消息队列，在你调用了<code>sendNotification</code>方法投放的推送通知对象都会先放到这个消息队列中，然后再一个个的发送给APNs服务器，也就是说，在你关闭client对象连接的瞬间，消息队列中如果还有未发送的消息存在，那这些消息就会在这个瞬间立即推送失败，client在这之后只负责等待未被服务器回复的消息，不再添加额外的推送通知。</p>
<h2 id="系统准备"><a href="#系统准备" class="headerlink" title="系统准备"></a>系统准备</h2><p>Pushy运行于Java 7以上版本，但在特定的运行环境中可能要添加额外的特定依赖。</p>
<p>APNs协议是基于<a href="https://http2.github.io/" target="_blank" rel="external">HTTP/2协议</a>的一套推送协议。HTTP/2是一套相对新的协议，以至于它的发展还没有延伸拓展到Java世界中。例如以下几点：</p>
<ol>
<li>HTTP/2依赖于<a href="https://tools.ietf.org/html/rfc7301" target="_blank" rel="external">ALPN</a>，它是一种在TLS协议上拓展出来的协议协商机制。在目前还没有哪个Java版本原生支持ALPN协议。所以如果我们要用ALPN，目前可以在Java7或Java8中，使用<a href="#using-a-native-ssl-provider">第三方的原生SSL provider</a>，或者使用<a href="#using-jettys-alpn-implementation">Jetty的ALPN实现</a>。</li>
<li>HTTP/2还需要使用<a href="https://httpwg.github.io/specs/rfc7540.html#rfc.section.9.2.2" target="_blank" rel="external">ciphers</a>，这个直到Java8才被引入到JDK中。在Java7中最好是使用原生的SSL provider。但在Java8中，原生SSL provider不再是必备的了,但可能还是有一些性能上的不足。</li>
</ol>
<p>通常来说，原生的SSL provider是满足HTTP/2对系统性能增强要求的最好方法，因为安装是相当简单的，并且它运行在Java 7以上版本通常能够提供比JDK的SSL provider更好的SSL执行性能。</p>
<h3 id="使用一个原生SSL-provider"><a href="#使用一个原生SSL-provider" class="headerlink" title="使用一个原生SSL provider"></a>使用一个原生SSL provider</h3><p>在所有支持的Java版本中，通过netty-tcnative使用一个native SSL provider (比如<a href="https://www.openssl.org/" target="_blank" rel="external">OpenSSL</a>, <a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="external">BoringSSL</a>, 或<a href="http://www.libressl.org/" target="_blank" rel="external">LibreSSL</a>)，就能够满足HTTP/2对于ALPN和cipher套件的系统要求。为了使用native SSL provider, 你只需要去添加一个<code>netty-tcnative</code>依赖到你的项目中。<code>netty-tcnative</code>的wiki提供了<a href="http://netty.io/wiki/forked-tomcat-native.html" target="_blank" rel="external">详细的说明</a>，但简单来说，你需要额外添加一个和平台特性相关的依赖到你的项目中；我们推荐使用静态的原生链接——“uber jar”，它可以支持大多数的操作系统和CPU架构(比如<code>linux-x86_64</code>, <code>osx-x86_64</code>, 和<code>windows-x86_64</code>)。这个方式将会满足大多数在Java 7和Java 8下对HTTP/2的要求。</p>
<p>如果你需要添加netty-tcnative的”uber jar”包，你只需要添加以下依赖(前提是你使用Maven):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-tcnative-boringssl-static<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.33.Fork22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<p>否则，你可能要根据你自己的选择添加相应的jar包到你的classpath中。</p>
<p>记得标注好Pushy是需要netty-tcnative 1.1.33.Fork22以上的版本。此外，你需要添加一个<a href="http://mvnrepository.com/artifact/org.eclipse.jetty.alpn/alpn-api" target="_blank" rel="external"><code>alpn-api</code></a>作为你项目的<code>运行时</code>依赖。如果你手动地管理项目依赖，你只需要确保最新版的<code>alpn-api</code>在你的classpath中可用。</p>
<h3 id="使用Jetty的ALPN实现"><a href="#使用Jetty的ALPN实现" class="headerlink" title="使用Jetty的ALPN实现"></a>使用Jetty的ALPN实现</h3><p>Jetty的ALPN实现，是native SSL provider的一种选择。请注明如果你不是使用JDK 8以上版本(或者你使用Oracle以外的JDK)，你需要查看是否分别达到cipher套件的要求，你可能要使用native SSL provider (也是满足ALPN的一种实现)，或使用另一种密码的provider (这部分内容在本文档中不涉及)。</p>
<p>使用Jetty的ALPN实现是比使用native SSL provider稍微有点复杂。你需要去选择一个和你当前使用的JDK版本匹配的<code>alpn-boot</code>版本，然后把它添加到你的<em>boot</em> classpath中(请注意这和常规的classpath<em>不</em>是同一个概念)。<a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html" target="_blank" rel="external">详细说明</a>在Jetty的官网中有。如果你选择使用<code>alpn-boot</code>的方式而不是用native SSL provider，我们强烈建议使用<a href="https://github.com/jetty-project/jetty-alpn-agent" target="_blank" rel="external"><code>jetty-alpn-agent</code></a>，原因是它会自动选择和你使用的JRE相匹配的正确版本的<code>alpn-boot</code>。</p>
<h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>Pushy提供了一个监控指标的接口，赋予客户端对行为和性能的洞察力，你可以编写你自己的<code>ApnsClientMetricsListener</code>接口的实现来记录和报告指标。我们也提供了一个<a href="https://github.com/relayrides/pushy/tree/master/dropwizard-metrics-listener" target="_blank" rel="external">使用了Dropwizard指标类库的指标监听器</a>作为一个分离的模块。若想要开始监控接收指标数据，在你创建client对象的时候设置一个监听器即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ApnsClient apnsClient = <span class="keyword">new</span> ApnsClientBuilder()</div><div class="line">        .setClientCredentials(<span class="keyword">new</span> File(<span class="string">"/path/to/certificate.p12"</span>), <span class="string">"p12-file-password"</span>)</div><div class="line">        .setMetricsListener(<span class="keyword">new</span> MyCustomMetricsListener())</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<p>请注意，在你的监听器中实现的指标处理的method中，<em>绝不</em>能调用到阻塞代码。直接在handler方法中直接增加一个计数器是比较恰当的，但是调用数据库或者远程监控端点必须被转发到分离的其他线程当中。</p>
<h2 id="使用代理"><a href="#使用代理" class="headerlink" title="使用代理"></a>使用代理</h2><p>如果你需要使用一个代理通过国外服务器进行连接，你最好在你创建ApnsClient对象实例的时候，提供一个<a href="http://relayrides.github.io/pushy/apidocs/0.8/com/relayrides/pushy/apns/proxy/ProxyHandlerFactory.html" target="_blank" rel="external"><code>ProxyHandlerFactory</code></a>对象。我们提供了HTTP，SOCKS4，和SOCKS5代理的<code>ProxyHandlerFactory</code>的具体实现。</p>
<p>举个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ApnsClient apnsClient = <span class="keyword">new</span> ApnsClientBuilder()</div><div class="line">        .setClientCredentials(<span class="keyword">new</span> File(<span class="string">"/path/to/certificate.p12"</span>), <span class="string">"p12-file-password"</span>)</div><div class="line">        .setProxyHandlerFactory(<span class="keyword">new</span> Socks5ProxyHandlerFactory(</div><div class="line">            <span class="keyword">new</span> InetSocketAddress(<span class="string">"my.proxy.com"</span>, <span class="number">1080</span>), <span class="string">"username"</span>, <span class="string">"password"</span>))</div><div class="line">        .build();</div><div class="line"></div><div class="line"><span class="keyword">final</span> Future&lt;Void&gt; connectFuture = apnsClient.connect(ApnsClient.DEVELOPMENT_APNS_HOST);</div><div class="line">connectFuture.await();</div></pre></td></tr></table></figure>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Pushy使用<a href="http://www.slf4j.org/" target="_blank" rel="external">SLF4J</a>来记录日志。如果你还不熟悉它，SLF4J只提供了外观接口，允许用户在系统部署的时候添加一个专门的”绑定”到classpath中来选择要使用的具体日志类库。为了避免让你进行选择，Pushy<em>不</em>依赖任何SLF4J绑定；你需要添加一个你自己的绑定（要么添加到项目依赖中，或者直接安装绑定）。如果你没有在你的classpath中绑定SLF4J，你可能会看到如下的警告信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.</div><div class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</div><div class="line">SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</div></pre></td></tr></table></figure>
<p>更多详细信息，请看<a href="http://www.slf4j.org/manual.html" target="_blank" rel="external">SLF4J用户指南</a>。</p>
<p>Pushy使用的日记级别如下所示：</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>事件日志</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>error</code></td>
<td>严重、不可恢复的错误；如果是可恢复的错误出现这个级别的日志信息这说明Pushy有bug</td>
</tr>
<tr>
<td><code>warn</code></td>
<td>严重但可恢复的错误；错误可能可以表明调用者的代码有一定的错误，并指定错误信息</td>
</tr>
<tr>
<td><code>info</code></td>
<td>重要的生命周期事件</td>
</tr>
<tr>
<td><code>debug</code></td>
<td>较小的生命周期事件；期待可能出现的异常信息</td>
</tr>
<tr>
<td><code>trace</code></td>
<td>个别IO操作</td>
</tr>
</tbody>
</table>
<h2 id="在应用容器中使用Pushy"><a href="#在应用容器中使用Pushy" class="headerlink" title="在应用容器中使用Pushy"></a>在应用容器中使用Pushy</h2><p>如果你计划在一个应用容器中使用Pushy(比如Tomcat)，你可能必须去进行一些额外的步骤，并且要知道一些具体的限制详情——<a href="https://github.com/relayrides/pushy/wiki/Using-Pushy-in-an-application-container" target="_blank" rel="external">“在应用容器中使用Pushy”的wiki页</a>。</p>
<h2 id="许可和状态"><a href="#许可和状态" class="headerlink" title="许可和状态"></a>许可和状态</h2><p>Pushy基于<a href="http://opensource.org/licenses/MIT" target="_blank" rel="external">MIT License</a>开源协议。</p>
<p>Pushy的当前最新版本为0.8.1。我们还在日臻完善它的功能（已经把它用在实际产品当中），在未来的1.0 发布版当中，对外提供的API和现在的版本相比，可能会有明显的差别。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;pushy&quot;&gt;&lt;a href=&quot;#pushy&quot; class=&quot;headerlink&quot; title=&quot;pushy&quot;&gt;&lt;/a&gt;pushy&lt;/h1&gt;&lt;h3 id=&quot;这是我自己的翻译版本，原文地址。&quot;&gt;&lt;a href=&quot;#这是我自己的翻译版本，原文地址。&quot; class=&quot;
    
    </summary>
    
      <category term="推送" scheme="http://www.coselding.cn/categories/%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="pushy" scheme="http://www.coselding.cn/tags/pushy/"/>
    
      <category term="APNs" scheme="http://www.coselding.cn/tags/APNs/"/>
    
      <category term="IOS" scheme="http://www.coselding.cn/tags/IOS/"/>
    
      <category term="http/2" scheme="http://www.coselding.cn/tags/http-2/"/>
    
  </entry>
  
  <entry>
    <title>APNs入门学习和使用</title>
    <link href="http://www.coselding.cn/2016/12/01/APNs%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.coselding.cn/2016/12/01/APNs入门学习和使用/</id>
    <published>2016-11-30T23:44:38.000Z</published>
    <updated>2016-11-30T23:44:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章费了我好多心血啊，这都是在我测试了一堆失败的代码，看了大量的博客之后，把其中最有用，最精华的部分提取出来的集成，也是我艰辛的踩坑历程，满满的干货啊！可能是我太渣了，这些东西以前都没接触过，所以下面会有很多很基础的东西，大神切莫见怪。。。</p>
<h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><blockquote>
<ul>
<li>HTTP/2扫盲：<a href="http://www.cnblogs.com/yingsmirk/p/5248506.html" target="_blank" rel="external">http://www.cnblogs.com/yingsmirk/p/5248506.html</a></li>
<li>HTTP/2官网文档：<a href="https://http2.github.io/" target="_blank" rel="external">https://http2.github.io/</a></li>
<li>HTTP/2标准文档中英文对照：<a href="https://github.com/fex-team/http2-spec" target="_blank" rel="external">https://github.com/fex-team/http2-spec</a></li>
<li>Wireshark抓包教程：<a href="http://fangxin.blog.51cto.com/1125131/735178" target="_blank" rel="external">http://fangxin.blog.51cto.com/1125131/735178</a></li>
<li><p>HTTP/2 大神汇总博客：<a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="external">https://imququ.com/post/http2-resource.html</a></p>
</li>
<li><p>看过这些之后，应该对http/2协议有了一些最初的了解，知道大体是怎么回事，其实和http1/1差不多，区别点主要是以下几点：</p>
<blockquote>
<ol>
<li>二进制分帧：每个请求分成多个帧进行传送，都送到之后再进行拼装</li>
<li>多路复用：二进制分帧之后的一个好处，多个请求共享同一个tcp连接，节约连接数量，提高连接利用率</li>
<li>服务器推送：推测客户端之后可能要的数据提前推送</li>
<li>头部压缩：两端各维护一个头部表，每次请求只传送头部不同的部分，减少传输冗余资源</li>
<li>ALPN应用层协议协商：和http1/1的兼容协商机制，这个下面会有关于java的相关说明</li>
<li>支持异步编程，非阻塞，提高效率</li>
</ol>
</blockquote>
</li>
<li>看了这些算是了解一些大概吧，很多东西到了实际使用中再来慢慢体会</li>
</ul>
</blockquote>
<h1 id="OkHttp学习和使用"><a href="#OkHttp学习和使用" class="headerlink" title="OkHttp学习和使用"></a>OkHttp学习和使用</h1><blockquote>
<p>这东西好久之前就用过，这次算是复习和提升以下，以前就是当个http客户端模拟使用，没处理过cookie、证书什么的，这次由于下面要做的事情的需要，就做了这些测试：</p>
<ul>
<li>okhttp教程：<a href="http://gold.xitu.io/entry/5728441d128fe1006058b6b9" target="_blank" rel="external">http://gold.xitu.io/entry/5728441d128fe1006058b6b9</a></li>
<li>OkHttp使用进阶 译自OkHttp Github官方教程：<a href="http://www.cnblogs.com/ct2011/p/3997368.html" target="_blank" rel="external">http://www.cnblogs.com/ct2011/p/3997368.html</a></li>
<li><p>OkHttp使用完全教程：<a href="http://www.jianshu.com/p/ca8a982a116b" target="_blank" rel="external">http://www.jianshu.com/p/ca8a982a116b</a></p>
</li>
<li><p>okhttp APNs：<a href="https://segmentfault.com/a/1190000005060740" target="_blank" rel="external">https://segmentfault.com/a/1190000005060740</a></p>
</li>
<li>okhttp https:<a href="http://blog.csdn.net/lmj623565791/article/details/48129405" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/48129405</a><br><a href="http://www.itdadao.com/articles/c15a693269p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a693269p0.html</a></li>
</ul>
<p>用的很爽啊，链式编程、API设计易于理解、sample众多、直接搬砖。。。</p>
</blockquote>
<h1 id="APNs"><a href="#APNs" class="headerlink" title="APNs"></a>APNs</h1><p>github上找了很多项目来实验啊，最后还是Pushy这个最满意，也最实用，并且也由它又发现了新世界，开启新世界，新的征程开始~<br>先来点介绍文吧~ 这些介绍看完，相信你也对APNs新版的协议有了比较清楚的了解。</p>
<blockquote>
<ul>
<li>APNs官网文档：<a href="https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/APNSOverview.html#//apple_ref/doc/uid/TP40008194-CH8-SW1</a></li>
<li>APNs简要介绍：基于HTTP2的全新APNs协议：<a href="https://github.com/ChenYilong/iOS9AdaptationTips" target="_blank" rel="external">https://github.com/ChenYilong/iOS9AdaptationTips</a></li>
<li><a href="https://github.com/ChenYilong/iOS9AdaptationTips/blob/master/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE.md" target="_blank" rel="external">https://github.com/ChenYilong/iOS9AdaptationTips/blob/master/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE/%E5%9F%BA%E4%BA%8EHTTP2%E7%9A%84%E5%85%A8%E6%96%B0APNs%E5%8D%8F%E8%AE%AE.md</a></li>
</ul>
</blockquote>
<p>Pushy神器来啦~下面的APNs调用都用这个项目来作为底层支撑。</p>
<blockquote>
<ul>
<li>Pushy开源项目：<a href="https://github.com/relayrides/pushy" target="_blank" rel="external">https://github.com/relayrides/pushy</a></li>
<li>Pushy官网：<a href="http://relayrides.github.io/pushy/" target="_blank" rel="external">http://relayrides.github.io/pushy/</a></li>
<li>Pushy文档：<a href="http://relayrides.github.io/pushy/apidocs/0.8/overview-summary.html" target="_blank" rel="external">http://relayrides.github.io/pushy/apidocs/0.8/overview-summary.html</a></li>
<li>Jetty ALPN配置：<a href="http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-starting" target="_blank" rel="external">http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-starting</a></li>
<li>alpn-boot依赖下载：<a href="http://mvnrepository.com/artifact/org.mortbay.jetty.alpn/alpn-boot" target="_blank" rel="external">http://mvnrepository.com/artifact/org.mortbay.jetty.alpn/alpn-boot</a></li>
</ul>
</blockquote>
<h1 id="额外收获"><a href="#额外收获" class="headerlink" title="额外收获"></a>额外收获</h1><blockquote>
<ul>
<li>Netty高性能之道：<a href="http://www.infoq.com/cn/articles/netty-high-performance" target="_blank" rel="external">http://www.infoq.com/cn/articles/netty-high-performance</a></li>
<li>Netty官网：<a href="http://netty.io/" target="_blank" rel="external">http://netty.io/</a></li>
<li>书：《Netty权威指南》</li>
</ul>
</blockquote>
<p>你可能会觉得上面的废话好多，好多东西好像不需要了解，直接使用Pushy就行了呗，其实我也不敢说上面那些东西是否真的对下面的有用，但是知道这些原理，对后面发生的异常才能心中有数，至少在我的踩坑过程中也是深有体会的，其实上面那些东西不是我一开始就都看完的，是在我踩坑的过程中一步步补充的，每个人的只是学习顺序也许有所不同，你可以根据自己的情况合理安排~<br>我之所以会事先看这些东西，原因也是因为http/2、APNs、IOS推送、TLS等这些东西我真的不是很了解，会有一种恐惧之心，算是我自己的一个知识补充吧，所以对于对这些知识掌握很好的大神其实上面那些基础是完全可以不看的~<br>下面开始开发：</p>
<h1 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h1><p>在Pushy的README.md中详细说明了Pushy所需的环境，我个人由于感激这篇文章在我踩坑过程中的作用，因此特别的把它翻译出来<a href="http://www.coselding.cn/article/2016/12/01/Pushy%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/">Pushy README.md中文翻译本</a>。<br>因为Pushy本身依赖了其他类库，为了方便，也由于我是是使用Maven管理和构件项目，我下面的教程完全都在Maven下进行部署和开发，请悉知：</p>
<h2 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h2><blockquote>
<p>必须JDK7以上版本，这个<a href="http://www.coselding.cn/article/2016/12/01/Pushy%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/">Pushy README.md中文翻译本</a>上面详细说明了。</p>
<ol>
<li>JDK8+Tomcat9 M11：部署成功</li>
<li>JDK7+Tomcat7：部署成功</li>
<li>JDK7+Tomcat9 M11：Tomcat启动失败，原因不明，我从Tomcat启动失败的报错中认为可能是Tomcat9 M11中调用了JDK8中特有的API，导致在JDK7中启动失败。</li>
</ol>
<p>所以你部署环境的时候这个要注意，特别是部署到服务器当中的时候。</p>
</blockquote>
<h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><blockquote>
<ol>
<li><p>添加Pushy依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.relayrides<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pushy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>添加native SSL provider依赖，注意版本哦：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-tcnative-boringssl-static<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.33.Fork22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个是ALPN协议协商的实现依赖包，在<a href="http://www.coselding.cn/article/2016/12/01/Pushy%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/">Pushy README.md中文翻译本</a>有详细说明的。到这一步，你的普通Java程序就能跑起来向APNs服务器发起一个推送了~~</p>
<ol>
<li><p>添加alpn-boot依赖（Tomcat中所需）：<br>这一步和上面的不太一样，因为jar包需要添加到bootclasspath中，和普通的classpath不太一样，在JVM启动参数添加如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;`p:`后面的部分就是你下载下来的alpn-boot的jar包的本地地址，这个jar包的下载地址是这个[http://mvnrepository.com/artifact/org.mortbay.jetty.alpn/alpn-boot](http://mvnrepository.com/artifact/org.mortbay.jetty.alpn/alpn-boot)</div><div class="line">&gt;`原因：`</div><div class="line">&gt;&gt;1. 这种方式添加的jar包会替换JVM底层运行的相关API，你可以理解为加载优先级更高的jar，但是这种方式加载的jar是和平台相关的，所以你下载的jar包要选择和你平台相匹配的才行哦~~，当然，这里的这个jar其实已经是linux、win、macOS全平台都具有的了，它会根据平台加载相应的那个组件。</div><div class="line">&gt;&gt;2. 加载这个jar的理由是，我们上面加载的netty-tcnative-boringssl-static这个依赖，和Tomcat内部的tcnative实现相冲突了，所以要用这个jar包要进行适配，具体的底层原理这里不研究，你只要记住，如果你使用Tomcat，就要加上步骤3的这个依赖，Jetty实测不需要这个依赖。</div><div class="line"></div><div class="line">&gt;4. 添加从Apple开发者平台申请到的app证书文件到项目资源目录下</div><div class="line"></div><div class="line">&gt;5. 开始编码：创建ApnsClient对象实例：根据证书和证书密码创建和APNs服务器的连接对象</div><div class="line">```java</div><div class="line">ApnsClient apnsClient = new ApnsClientBuilder().setClientCredentials(new File(&quot;/path/to/p12-file&quot;), &quot;p12-file-password&quot;).build();</div></pre></td></tr></table></figure>
</li>
<li><p>等待和APNs的连接成功（HTTP/2是异步的，但是这里连接没成功后续步骤无法继续，所以需要等待）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Future&lt;Void&gt; connectFuture = apnsClient.connect(ApnsClient.PRODUCTION_APNS_HOST);</div><div class="line">        connectFuture.await();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>链接地址有<code>DEVELOPMENT_APNS_HOST</code>和<code>PRODUCTION_APNS_HOST</code>两个，你要确认你拿到的证书是否支持开发者模式连接开发者服务器，我拿到的证书就是不支持的，需要直接连接正式服务器，这是我踩的坑。</p>
<ol>
<li>封装推送消息内容体：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ApnsPayloadBuilder payloadBuilder = <span class="keyword">new</span> ApnsPayloadBuilder();</div><div class="line">        payloadBuilder.setAlertBody(<span class="string">"alert-message-body"</span>);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>ApnsPayloadBuilder这个类可以好好看看，就是这个类封装推送消息体，携带了APNs推送能发送的各个字段，比如显示按钮、通知消息标题、消息体、图片名、消息声音文件名等，还由于APNs对每个消息最大长度限制为4K，因此还对过长的消息进行了智能化地截取工作。最后这这个类会被序列化为json串，就像如下的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   "aps" : &#123;</div><div class="line">      "category" : "NEW_MESSAGE_CATEGORY"</div><div class="line">      "alert" : &#123;</div><div class="line">         "body" : "Acme message received from Johnny Appleseed",</div><div class="line">      &#125;,</div><div class="line">      "badge" : 3,</div><div class="line">      "sound" : “chime.aiff"</div><div class="line">   &#125;,</div><div class="line">   "acme-account" : "jane.appleseed@apple.com",</div><div class="line">   "acme-message" : "message123456"</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你要自己封装json也行，只要最后的json中有apple规定的那些键值就行，而额外的，你也可以自定义地添加一些自己业务所需的其他键值方便客户端接收到推送消息之后进行处理。</p>
<p>######智能截取4K长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String payload = payloadBuilder.buildWithDefaultMaximumLength();</div></pre></td></tr></table></figure></p>
<ol>
<li>封装消息体：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SimpleApnsPushNotification pushNotification = <span class="keyword">new</span> SimpleApnsPushNotification(token, <span class="string">"com.example.AppName"</span>, payload);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中token是每个设备生成的token串经过如下代码加工后得到的，相当于是设备的唯一id：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String token = TokenUtil.sanitizeTokenString(<span class="string">"&lt;device token&gt;"</span>);</div></pre></td></tr></table></figure></p>
<p>“com.example.AppName”:这个是你的证书签名，必须保证证书签名、证书、证书密码、产生token的app签名全部一致，不然就会报错。</p>
<h6 id="你的整个推送消息体封装好之后，在网络http-2传输过程中的最终传输的数据格式如下，主要包括headers和body-data："><a href="#你的整个推送消息体封装好之后，在网络http-2传输过程中的最终传输的数据格式如下，主要包括headers和body-data：" class="headerlink" title="你的整个推送消息体封装好之后，在网络http/2传输过程中的最终传输的数据格式如下，主要包括headers和body data："></a>你的整个推送消息体封装好之后，在网络http/2传输过程中的最终传输的数据格式如下，主要包括headers和body data：</h6><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">HEADERS</div><div class="line">  \- END_STREAM</div><div class="line">  \+ END_HEADERS</div><div class="line">  :method = POST</div><div class="line">  :scheme = https</div><div class="line">  :path = /<span class="number">3</span>/device/<span class="number">00f</span>c13adff785122b4ad28809a3420982341241421348097878e577c991de8f0</div><div class="line">  host = api.development.push.apple.com</div><div class="line">  apns-id = eabeae54-<span class="number">14</span>a8-<span class="number">11e5</span>-b60b-<span class="number">1697f</span>925ec7b</div><div class="line">  apns-expiration = <span class="number">0</span></div><div class="line">  apns-priority = <span class="number">10</span></div><div class="line">  apns-topic = &lt;MyAppTopic&gt; </div><div class="line">DATA</div><div class="line">  \+ END_STREAM</div><div class="line">    &#123; <span class="string">"aps"</span> : &#123; <span class="string">"alert"</span> : <span class="string">"Hello"</span> &#125; &#125;</div></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>发送消息推送：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; sendNotificationFuture = apnsClient.sendNotification(pushNotification);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这是一个异步阻塞方法，调用之后推送通知会放到内部消息队列，等待APNs接收到消息并反馈的时候才能通过下面的方法得到响应，否则下面这个方法就会阻塞着，上线产品建议写成异步回调的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PushNotificationResponse&lt;SimpleApnsPushNotification&gt; pushNotificationResponse = sendNotificationFuture.get();</div></pre></td></tr></table></figure></p>
<ol>
<li>接收APNs服务器响应：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pushNotificationResponse.isAccepted();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以下方法获取APNs服务器拒绝消息的相关响应信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pushNotificationResponse.getRejectionReason();<span class="comment">//获取拒绝原因</span></div><div class="line">pushNotificationResponse.getTokenInvalidationTimestamp();<span class="comment">//获取token失效时间</span></div></pre></td></tr></table></figure></p>
<ol>
<li><p>连接断开重连：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apnsClient.getReconnectionFuture().await();</div></pre></td></tr></table></figure>
</li>
<li><p>关闭连接，释放资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Future&lt;Void&gt; disconnectFuture = apnsClient.disconnect();</div><div class="line">disconnectFuture.await();</div></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>踩坑记录：Pushy项目中依赖了gson，如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果你添加了如下的gson：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那你的com.google的gson就会和Pushy中的gson冲突，然后出现未知的错误。。。知道就行，具体和这两个gson的差别有关，我没了解。。。这种坑也只有我这种人品的能踩到。。。最好是两个够不添加，反正Pushy在Maven中就会自动依赖引入了，何必多此一举。</p>
</blockquote>
<h1 id="消息包装实战"><a href="#消息包装实战" class="headerlink" title="消息包装实战"></a>消息包装实战</h1><p>我本人没接触过iOS开发，因此对这个消息体那些字段有些什么用不是搞得很清楚，只是大概知道图标、按钮显示、声音等意思，但是具体到iOS设备接收到之后会有什么样的消息体现，我不是很清楚，但是懂得的人看了下面我的测试样例，我相信也能很快包装出自己想要的消息~</p>
<h5 id="消息json中的aps字段一看就知道是apple推送到设备之后的专属识别字段，在该字段下的每个子字段分别有相应的作用和意义，再来就是自定义字段，在json中会和aps同一级别目录下展示，这个是开发者自己知道的字段，在客户端自行解析和提取使用。"><a href="#消息json中的aps字段一看就知道是apple推送到设备之后的专属识别字段，在该字段下的每个子字段分别有相应的作用和意义，再来就是自定义字段，在json中会和aps同一级别目录下展示，这个是开发者自己知道的字段，在客户端自行解析和提取使用。" class="headerlink" title="消息json中的aps字段一看就知道是apple推送到设备之后的专属识别字段，在该字段下的每个子字段分别有相应的作用和意义，再来就是自定义字段，在json中会和aps同一级别目录下展示，这个是开发者自己知道的字段，在客户端自行解析和提取使用。"></a>消息json中的<code>aps字段</code>一看就知道是apple推送到设备之后的专属识别字段，在该字段下的每个子字段分别有相应的作用和意义，再来就是<code>自定义字段</code>，在json中会和aps同一级别目录下展示，这个是开发者自己知道的字段，在客户端自行解析和提取使用。</h5><blockquote>
<ul>
<li><p>消息包装代码展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ApnsPayloadBuilder payloadBuilder = <span class="keyword">new</span> ApnsPayloadBuilder();</div><div class="line"><span class="comment">//体现在aps的category字段</span></div><div class="line">payloadBuilder.setCategoryName(<span class="string">"category"</span>);</div><div class="line"><span class="comment">//体现在aps的content-available字段</span></div><div class="line">payloadBuilder.setContentAvailable(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//弹出窗消息图标，aps的alert字段的launch-image字段</span></div><div class="line">payloadBuilder.setLaunchImageFileName(<span class="string">"icon.icon"</span>);</div><div class="line"><span class="comment">//以下为两种弹出窗的消息封装模式</span></div><div class="line"><span class="comment">//弹出窗消息封装1</span></div><div class="line">payloadBuilder.setAlertBody(<span class="string">"Example!"</span>);<span class="comment">//aps的alert字段的body字段</span></div><div class="line">payloadBuilder.setAlertSubtitle(<span class="string">"AlertSubtitle"</span>);<span class="comment">//aps的alert字段的title字段</span></div><div class="line">payloadBuilder.setAlertTitle(<span class="string">"AlertTitle"</span>);<span class="comment">//aps的alert字段的subtitle字段</span></div><div class="line"><span class="comment">//弹出窗消息封装2</span></div><div class="line">payloadBuilder.setLocalizedActionButtonKey(<span class="string">"LocalizedActionButtonKey"</span>);<span class="comment">//aps的alert字段的action-loc-key字段</span></div><div class="line">payloadBuilder.setLocalizedAlertMessage(<span class="string">"LocalizedAlertMessage"</span>);<span class="comment">//aps的alert字段的loc-key字段</span></div><div class="line">payloadBuilder.setLocalizedAlertSubtitle(<span class="string">"LocalizedAlertSubtitle"</span>);<span class="comment">//aps的alert字段的subtitle-loc-key字段</span></div><div class="line">payloadBuilder.setLocalizedAlertTitle(<span class="string">"LocalizedAlertTitle"</span>);<span class="comment">//aps的alert字段的title-loc-key字段</span></div><div class="line"><span class="comment">//消息通知声音，aps的sound字段</span></div><div class="line">payloadBuilder.setSoundFileName(<span class="string">"sound.wav"</span>);</div><div class="line"><span class="comment">//aps的badge字段</span></div><div class="line">payloadBuilder.setBadgeNumber(<span class="number">1</span>);</div><div class="line"><span class="comment">//aps的mutable-content字段</span></div><div class="line">payloadBuilder.setMutableContent(<span class="keyword">true</span>);</div><div class="line"><span class="comment">//自定义键值对，其中value是Object，可以支持多层的json字串，这个根据业务需求而定</span></div><div class="line">payloadBuilder.addCustomProperty(<span class="string">"name"</span>,<span class="string">"value"</span>);</div><div class="line"><span class="comment">//是否显示动作按钮，这个没在json中体现啊，可能在header中体现吧，没研究</span></div><div class="line">payloadBuilder.setShowActionButton(<span class="keyword">true</span>);</div><div class="line">String payload = payloadBuilder.buildWithDefaultMaximumLength();</div><div class="line">String token = TokenUtil.sanitizeTokenString(<span class="string">"aa1e3286fcf87a68f9e8be642d9661c4a4537e34fe4abab68a9681ced773c18f"</span>);</div><div class="line">System.out.println(<span class="string">"payload = "</span> + payload);</div><div class="line">System.out.println(<span class="string">"token = "</span> + token);</div><div class="line">SimpleApnsPushNotification pushNotification = <span class="keyword">new</span> SimpleApnsPushNotification(token, <span class="string">"cn.geili.KoudaiGouwu"</span>, payload);</div><div class="line">System.out.println(pushNotification.toString());</div></pre></td></tr></table></figure>
</li>
<li><p>其中弹出窗消息封装有两种，如下所示</p>
</li>
<li><p>弹出窗消息封装1，json展示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"aps"</span>: &#123;</div><div class="line">        <span class="string">"category"</span>: <span class="string">"category"</span>,</div><div class="line">        <span class="string">"content-available"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"alert"</span>: &#123;</div><div class="line">            <span class="string">"body"</span>: <span class="string">"Example!"</span>,</div><div class="line">            <span class="string">"launch-image"</span>: <span class="string">"icon.icon"</span>,</div><div class="line">            <span class="string">"title"</span>: <span class="string">"AlertTitle"</span>,</div><div class="line">            <span class="string">"subtitle"</span>: <span class="string">"AlertSubtitle"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"sound"</span>: <span class="string">"sound.wav"</span>,</div><div class="line">        <span class="string">"badge"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"mutable-content"</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"name"</span>: <span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>弹出窗消息封装2，json展示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"aps"</span>: &#123;</div><div class="line">        <span class="string">"category"</span>: <span class="string">"category"</span>,</div><div class="line">        <span class="string">"content-available"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"alert"</span>: &#123;</div><div class="line">            <span class="string">"launch-image"</span>: <span class="string">"icon.icon"</span>,</div><div class="line">            <span class="string">"action-loc-key"</span>: <span class="string">"LocalizedActionButtonKey"</span>,</div><div class="line">            <span class="string">"loc-key"</span>: <span class="string">"LocalizedAlertMessage"</span>,</div><div class="line">            <span class="string">"subtitle-loc-key"</span>: <span class="string">"LocalizedAlertSubtitle"</span>,</div><div class="line">            <span class="string">"title-loc-key"</span>: <span class="string">"LocalizedAlertTitle"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"sound"</span>: <span class="string">"sound.wav"</span>,</div><div class="line">        <span class="string">"badge"</span>: <span class="number">1</span>,</div><div class="line">        <span class="string">"mutable-content"</span>: <span class="number">1</span></div><div class="line">    &#125;,</div><div class="line">    <span class="string">"name"</span>: <span class="string">"value"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>教程完结，有了这个教程，差不多就可以在生产环境中部署新版的APNs推送服务了，你只需要将以上的教程代码进行相应的封装，根据业务场景对消息体json也进行相应的封装，剩余的事情都交给这个Pushy框架即可，内部对消息队列、失败重传等都进行了处理，不过为了更好地开发出高性能高并发的推送服务器，最好还是对内部原理深入理解，特别是Netty内部细节（这个可是Pushy底层的网络支持和IO框架）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章费了我好多心血啊，这都是在我测试了一堆失败的代码，看了大量的博客之后，把其中最有用，最精华的部分提取出来的集成，也是我艰辛的踩坑历程，满满的干货啊！可能是我太渣了，这些东西以前都没接触过，所以下面会有很多很基础的东西，大神切莫见怪。。。&lt;/p&gt;
&lt;h1 id=&quot;HT
    
    </summary>
    
      <category term="推送" scheme="http://www.coselding.cn/categories/%E6%8E%A8%E9%80%81/"/>
    
    
      <category term="pushy" scheme="http://www.coselding.cn/tags/pushy/"/>
    
      <category term="APNs" scheme="http://www.coselding.cn/tags/APNs/"/>
    
      <category term="IOS" scheme="http://www.coselding.cn/tags/IOS/"/>
    
      <category term="http/2" scheme="http://www.coselding.cn/tags/http-2/"/>
    
  </entry>
  
  <entry>
    <title>macOS入门认识与折腾</title>
    <link href="http://www.coselding.cn/2016/11/17/macOS%E5%85%A5%E9%97%A8%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%8A%98%E8%85%BE/"/>
    <id>http://www.coselding.cn/2016/11/17/macOS入门认识与折腾/</id>
    <published>2016-11-17T05:51:38.000Z</published>
    <updated>2016-11-17T05:51:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>我这个不怕折腾星人入职一个多星期除了完成老大安排的任务外，其余时间都在没日没夜地折腾电脑，写这篇文章也算是对这次的折腾宣告结束，至少我觉得我与这台电脑的磨合期过了。。。可以愉快地用这台电脑学东西，做东西，不过这篇文章也算是一个笔记，比如快捷键，还没那么快完全记住。。。毕竟那些关键的操作按键和win的都不一样，我还是得时不时打开这个文档查看。。。</p>
<h3 id="第一步、拆包开机"><a href="#第一步、拆包开机" class="headerlink" title="第一步、拆包开机"></a>第一步、拆包开机</h3><blockquote>
<ul>
<li>很无脑的操作，一开始开机会设置用户之类的基本信息，按照自己的情况选择就行~</li>
</ul>
</blockquote>
<h3 id="第二步、安装软件"><a href="#第二步、安装软件" class="headerlink" title="第二步、安装软件"></a>第二步、安装软件</h3><h4 id="软件列表是根据老大给的列表-我个人以前使用积累-Java这三个因素共同影响的结果，仅供参考。软件安装的原则是使用免费版，就算付费的也是找到破解教程（当然还是推荐支持正版！！！），仅供参考。。。"><a href="#软件列表是根据老大给的列表-我个人以前使用积累-Java这三个因素共同影响的结果，仅供参考。软件安装的原则是使用免费版，就算付费的也是找到破解教程（当然还是推荐支持正版！！！），仅供参考。。。" class="headerlink" title="软件列表是根据老大给的列表+我个人以前使用积累+Java这三个因素共同影响的结果，仅供参考。软件安装的原则是使用免费版，就算付费的也是找到破解教程（当然还是推荐支持正版！！！），仅供参考。。。"></a>软件列表是根据老大给的列表+我个人以前使用积累+Java这三个因素共同影响的结果，仅供参考。软件安装的原则是使用免费版，就算付费的也是找到破解教程（当然还是推荐支持正版！！！），仅供参考。。。</h4><blockquote>
<ul>
<li><a href="https://www.iterm2.com/" target="_blank" rel="external">iTerm2</a> 挺不错的ssh客户端工具，比系统自带的好处是可以在菜单栏Profiles设置自己的常用服务器连接，之后需要使用直接点击连接即可，支持多标签，可以同时维护多个shell连接，基本上win上的XShell有的功能都有了，不过为了一个用的顺手的ssh工具我也是折腾了很久，以下列出部分折腾的干货：<blockquote>
<ol>
<li>应用商店有很多ssh客户端工具，不过大多收费，其中vSSH有个免费版，算还不错，但是最多支持2个标签同时工作，再多就得使用付费版。。。</li>
<li>保存常用连接：</li>
</ol>
<ul>
<li>######方式一<br>公私钥验证设置：<br>(1) 在mac下生成public_key与private_key生成的密钥在~/.ssh/下面<br>(2) 把mac下刚生成的public_key “id_rsa.pub”文件拷贝一份到远端服务器即将需要登录用户家目录下的.ssh/目录下，并命名为authorized_keys，如果已存在该文件就追加。<br>(3) 最后修改本机mac下得配置文件，~/.ssh/config，格式如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Host aliyun</div><div class="line">	HostName coselding.cn</div><div class="line">	User coselding</div><div class="line">	Port 22</div><div class="line">	PubkeyAuthentication yes</div><div class="line">	IdentityFile ~/.ssh/aliyun</div><div class="line">Host qqcloud</div><div class="line">	HostName itransfer.coselding.cn</div><div class="line">	User coselding</div><div class="line">	Port 22</div><div class="line">	PubkeyAuthentication yes</div><div class="line">	IdentityFile ~/.ssh/qqcloud</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>就是按照这个格式设置好目标服务器的ssh地址、端口号、用户名，并指定自己对应在服务器上公钥的私钥文件即可。<br>(4) 直接执行 ssh aliyun即可达到所记录的远端服务器，他其实就是找到对应的Host，然后用这个Host下设置的一系列参数自动帮你发送给命令连接，和你平时ssh ip这样连接然后提示你输入帐号密码是一样的道理。<br>(5) 当然，上面的key设置你也可以换成直接写密码，只不过这样安全系数降低了。</p>
<ul>
<li>######方式二<br>sshpass实现设置和profiles设置:<a href="[http://www.cnblogs.com/onlyfu/p/4460160.html">http://www.cnblogs.com/onlyfu/p/4460160.html</a></li>
<li>######方式三<br>sshpass 上面sshpass这个教程的方式是把你的服务器登录密码保存在文件系统中了，然后profiles的Command设置相应的命令在执行的时候去读取密码文件自动帮你登录，我个人推荐的是使用第一个方式使用ssh key设置好免密码登录，然后用第二个方式设置profiles，直接在profiles的Command选项填写ssh Host（就是第一个方式的第四步那个命令），这样每次需要连接自己的服务器只需要iTerm2的菜单栏——Profiles——选择你的服务器名称，就连上了，又避免了方式二在文件系统中明文保存密码的危险性。</li>
<li>iTerm使用技巧：<a href="http://wulfric.me/2015/08/iterm2/" target="_blank" rel="external">http://wulfric.me/2015/08/iterm2/</a></li>
<li><a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">Inteillj IDEA</a></li>
</ul>
<ol>
<li>安装没难度啊，官网下载，主要是破解教程，给个给力教程，jetbrains所有最新IDE都能用：<a href="http://blog.lanyus.com/archives/228.html" target="_blank" rel="external">http://blog.lanyus.com/archives/228.html</a><blockquote>
<ul>
<li>干货就是Mac上要运行darwin x64那个文件，并且sudo执行，建议写成一个shell脚本以后方便使用，这个License Server不运行的话有时候idea的激活就会失效，需要重新打开再激活，写个脚本使用率还是很高的。</li>
</ul>
</blockquote>
</li>
<li>个性化设置：这个和你个人习惯有关，主要推荐设置的有keymap、显示行号、maven相关设置、github相关设置、tomcat设置、dark皮肤、字体字号，当然keymap建议还是用Mac OS X那套，快捷键你改的太多以后换电脑什么的挺麻烦，会不适应，除非你记录好自己改了些什么</li>
<li>设置完当然是导出设置，把你的设置保存一份，以后可以随时还原：File——Export settings，选择好导出目录即可。</li>
</ol>
<ul>
<li>xmind 7：这货装完了，还没用，以后再更新，破解教程不方便公布，需要的单独联系。</li>
<li>OmniGraffle 7 ：这货装完了，还没用，以后再更新，破解教程不方便公布，需要的单独联系。</li>
<li><a href="https://www.sublimetext.com/" target="_blank" rel="external">sublime</a> ：用的人很多，也很好用，没什么可说的。。。</li>
<li><a href="http://download.oracle.com/otn-pub/java/jdk/8u111-b14/jdk-8u111-macosx-x64.dmg" target="_blank" rel="external">jdk</a> ：Java狗必备。。。</li>
<li><a href="https://git-scm.com/download/mac" target="_blank" rel="external">git</a> ：程序猿必备了基本上。。。</li>
<li><a href="https://desktop.github.com/" target="_blank" rel="external">github desktop</a> ：github图形化界面，爱要不要吧。。。</li>
<li><a href="https://www.apachefriends.org/zh_cn/index.html" target="_blank" rel="external">xampp</a> ：web开发套件，其实我只是用其中的mysql模块，但是比正式版的好处是这里面的mysql需要再开，占用资源少，你装正式版的mysql试试？反正我觉得正式版的平时不用的时候后台肯定也给你占用点资源，强迫症不能忍。。。</li>
<li><a href="http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html" target="_blank" rel="external">chrome</a> ： 浏览器我只推chrome</li>
<li>输入法：百度或者搜狗，目前感觉差不多，可以用久点看看哪个广告少。。。这个是我win端用qq输入法的原因。。。</li>
<li>用了多年的qq输入法，结果在mac上极其难用，打拼音的时候上下居然很难翻页，不能忍</li>
<li>系统自带：必须吐槽，中英文符号切换，*居然有中英文两个版本，我只要ASCII那个版好吗，导致我code时输入个注释中英文切换都很频繁。。。这也就算了，关键是中英文切换需要control+space，不像第三方输入法直接shift搞定，这效率太低了。。。</li>
<li>haroopad：markdown编辑器，安装使用homebrew，给教程：<a href="http://macappstore.org/haroopad/" target="_blank" rel="external">http://macappstore.org/haroopad/</a><br>当然Macdowm也不错，但是haroopad的菜单栏有插入，里面有常用控件的快捷插入方式，如果你markdown语法倒背如流，那还是Macdown吧，感觉漂亮点。。。</li>
<li>navcat：使用多年，有感（习）情（惯）了，给破解教程：<a href="https://my.oschina.net/shyann/blog/515237" target="_blank" rel="external">https://my.oschina.net/shyann/blog/515237</a></li>
<li>######没难度的过程，但是有一个坑，破解工具需要右键——显示简介——32位方式打开，我忘记在哪个博客上看到很关键的这句话了，感谢博主！！！</li>
<li><a href="https://github.com/shadowsocks/shadowsocks-iOS/releases" target="_blank" rel="external">ShadowsocksX</a> ：科学上网。。。</li>
<li><a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external">xx-net</a> ：GoAgent快捷工具，自己到github上下。。。打开方式为sudo打开start.command这个脚本。</li>
<li><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="external">WebStorm</a> ：jetbrains公司的前端开发IDE，相关说明同IntelliJ IDEA</li>
<li><a href="https://www.python.org/" target="_blank" rel="external">python</a> ：python爱好者必备。。。</li>
<li>office ：目前装着MS Office 2011破解版，手上有MS Office 2016破解教程，不方便公布。。。</li>
<li>虚拟机：Parallels Desktop,也是装的破解版，都不需要破解。。。比win端的VMware强大的多，运行流畅，并且和物理系统贴合很强，对物理磁盘的访问纯天然，也可以在macOS上右键windows方式打开一个.exe文件，谁用谁知道。。。</li>
<li><a href="http://cidian.youdao.com/index-mac.html?keyfrom=dict2.index" target="_blank" rel="external">有道词典</a>：。。。</li>
<li><a href="https://eclipse.org/downloads/" target="_blank" rel="external">eclipse</a>：装的JavaSE最小版本，装着有时候写小程序、demo用，做项目还是idea好用。</li>
<li><a href="https://developer.android.com/studio/index.html" target="_blank" rel="external">android studio</a> ： Android狗也要有的吧。。。mac版居然才400+M，没占多少地。。。相关设置同IntelliJ IDEA</li>
<li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="external">nodejs</a> ： js爱好者哈哈哈，目前没装，先下了。。。</li>
<li>xcode(应用商店) ： macOS上也要体验看看的，有空再玩。。。</li>
<li>homebrew ：mac端包管理工具，以后研究。。。</li>
<li><a href="https://appcleaner.en.softonic.com/mac" target="_blank" rel="external">AppCleaner</a> ：这东西有意思，每次你卸载删除软件它会自动弹窗提醒你是否清除软件相关数据，感觉是拯救强迫症患者的！</li>
<li>视频软件：Movist，付费版的。。。不贵。。。感觉是mac端的PotPlayer</li>
<li><a href="https://filezilla-project.org/download.php" target="_blank" rel="external">Filezilla</a> ：ftp、scp、sftp客户端</li>
<li>下载工具：迅雷，有些下载链接只能用迅雷。。。</li>
<li>管理软件：<a href="https://www.macupdate.com/app/mac/52661/dr-cleaner" target="_blank" rel="external">Dr.Cleaner</a>，管理内存，清除垃圾，删除大文件，重复文件，先用着。。。</li>
<li>chm文档：<a href="https://itunes.apple.com/cn/app/chm-reader/id424182884?mt=12" target="_blank" rel="external">CHM Reader</a>，后来找到了Dash神奇就不想用这个了</li>
<li>#####<a href="https://kapeli.com/dash" target="_blank" rel="external">Dash</a>：mac端强大的文档管理工具，反正里面bootstrap、js、jquery、JavaSE、JavaEE、Spring、python、Android、MySQL、Linux、Markdown、Git等各种教程文档都有，还有局部搜索和全局搜索，再也不用保存着一堆的chm文件了，强力推荐！！！！！！！！！！</li>
<li>蓝牙：该有的功能得试试。。。</li>
<li>移动硬盘相关：NTFS的移动硬盘在mac只能读无法写，装插件实现：</li>
<li>Paragon NTFS for Mac：这东西据说很好用，然而它的激活码居然是硬件关联的，换个电脑都不能用，目前没破解</li>
<li><a href="http://www.tuxera.com/products/tuxera-ntfs-for-mac/" target="_blank" rel="external">Tuxera ntfs for mac</a>：这个是基于一个开源项目做的，虽然收费，但是很好破解，序列号：J0M1H-37VYL-YEVNK-VFVM5<br>感谢学弟给的资源！</li>
<li>photoshop CC 2017：已有破解教程，不方便公布，需要请单独联系</li>
<li><a href="https://itunes.apple.com/app/the-unarchiver/id425424353?mt=12&amp;ls=1&amp;utm_source=next.36kr.com" target="_blank" rel="external">The Unarchiver</a>:压缩软件，系统自带的不能解压rar的，以备不时之需。。。</li>
<li>Mail：</li>
<li>设置QQ、163、gmail都天然兼容，一路通畅</li>
<li>######企业邮箱：我司的企业邮箱一开始我在安全设置设置了个六位短信验证码，之后在系统自带的Mail上设置邮箱账户就死活无法登录，之后把动态验证码去掉即可——这绝对干货，浪费了两个多小时得到的教训！！！！</li>
</ul>
</blockquote>
</blockquote>
<h3 id="第三步、系统折腾"><a href="#第三步、系统折腾" class="headerlink" title="第三步、系统折腾"></a>第三步、系统折腾</h3><h5 id="这里给出我折腾的各种东西，装完软件整个电脑系统还用着很不习惯啊。。。"><a href="#这里给出我折腾的各种东西，装完软件整个电脑系统还用着很不习惯啊。。。" class="headerlink" title="这里给出我折腾的各种东西，装完软件整个电脑系统还用着很不习惯啊。。。"></a>这里给出我折腾的各种东西，装完软件整个电脑系统还用着很不习惯啊。。。</h5><blockquote>
<ul>
<li>LanchPad整理：和IOS上图标整理差不多，拖动一个图标到另一个图标上面可以合成文件夹，这里主要给出如何删除不想要的图标：按住control+option+command或option+command即可看到一个叉叉。。。</li>
<li>Docker整理，桌面整理：鼠标拖动。。。和win差不多</li>
<li>文件整理：文件系统和linux差不多，自己根据文件树好好把自己的个人文件整理好，以后查找方便，不过macOS的Spotlight搜索异常强大。。。不过我个人对电脑中乱糟糟的文件分布不能忍。。。</li>
<li>系统设置：自己弄。。。主要是安全性、鼠标、键盘、触控板、TimeMachine有比较有用的设置</li>
<li>密码修改：密码严格点好。。。</li>
<li>文件系统常用功能：macOS上的Finder相当于win的资源管理器，但是新建文件、command+X剪切文件等很多win的资源管理器常用功能这里都没有，一开始不习惯，连复制个文件路径都不行，编程怎么忍？<a href="http://www.trankynam.com/xtrafinder/" target="_blank" rel="external">XtraFinder</a> 用这个插件可以拓展Finder的功能，安装好需要重启按command+R去设置System Integrity Protection，具体安装好就能看到相关提醒。重启完自己打开就能看到各种设置。。。</li>
<li>Finder相关设置：<a href="http://www.macx.cn/thread-2080254-1-1.html" target="_blank" rel="external">http://www.macx.cn/thread-2080254-1-1.html</a></li>
<li>获取文件夹路径，这个教程主要是开启了我的macOS的事件流设置之旅，有意思！！！<br><a href="http://jingyan.baidu.com/article/380abd0a12007b1d91192c5e.html" target="_blank" rel="external">http://jingyan.baidu.com/article/380abd0a12007b1d91192c5e.html</a></li>
<li>触摸板：macOS的触摸板异常强大！！！特别爽，不需要教程，自己到偏好设置看！</li>
<li>环境变量:<a href="http://www.cnblogs.com/shineqiujuan/p/4693404.html" target="_blank" rel="external">http://www.cnblogs.com/shineqiujuan/p/4693404.html</a><blockquote>
<p>JDK环境变量：<a href="http://www.mamicode.com/info-detail-425131.html" target="_blank" rel="external">http://www.mamicode.com/info-detail-425131.html</a><br>都和linux一样的，没难度</p>
</blockquote>
</li>
<li>进程管理：<a href="https://www.douban.com/group/topic/29517146/" target="_blank" rel="external">https://www.douban.com/group/topic/29517146/</a></li>
<li>开机启动：<a href="http://www.mac52ipod.cn/post/apple-mac-os-x-auto-startup-items.php" target="_blank" rel="external">http://www.mac52ipod.cn/post/apple-mac-os-x-auto-startup-items.php</a></li>
<li>关闭Guest用户：进偏好设置，然后打开左下角的那个锁，点那个Guest。右面有界面让你关掉</li>
<li>多屏幕使用：<blockquote>
<p>原先苦恼我的问题是两个屏幕如何控制鼠标键盘焦点在哪个屏幕上，<a href="http://shengbinxu.github.io/mac/2015/06/28/mac%E4%B8%8B%E5%8F%8C%E5%B1%8F%E5%88%87%E6%8D%A2/" target="_blank" rel="external">教程1</a>,<a href="http://blog.csdn.net/chenyufeng1991/article/details/50493362" target="_blank" rel="external">教程2</a>等等，类似教程很多可以多看看，下面说说我的使用体验：</p>
<ol>
<li>显示器公司会有适配的数据线，插上就能用~~</li>
<li>系统偏好设置——显示器——排列，可以设置两块显示器的排列位置关系，之后你拖动鼠标从一个屏幕移动到另一个屏幕就是根据这个位置关系的；并且其中一个上面有个白条，那个代表了状态栏，相当于是主屏幕的标志。</li>
<li>屏幕位置关系建议左右关系，因为上下关系的话你的Dock会不好切换，Dock是根据你在哪个屏幕下方停留就自动跳到那个屏幕的，会和鼠标屏幕间移动冲突。。。</li>
<li>鼠标焦点转移：根据你设置的屏幕位置关系，移动到一个屏幕边缘就能在另一个屏幕出现，就像两个屏幕是连着的一样。</li>
<li>键盘焦点转移：鼠标点击就自然转移了；或者command+tab转移app焦点的时候也能转移键盘焦点，但是这个时候鼠标焦点没变，比如你从主屏幕的chrome浏览器转移到副屏幕的终端输入命令行，命令行不需要鼠标，用这个方式显然提高效率的~~</li>
<li>屏幕间拖动：可以从一个屏幕把整个桌面、程序窗口、文件等直接拖动到另一个屏幕，试试就知道~~</li>
<li>举个例子：比如你在副屏幕idea编辑web程序运行（control+R）测试，这时候command+tab切换到chrome，然后command+R刷新，不需要动鼠标，多快~~</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="第四步、快捷键："><a href="#第四步、快捷键：" class="headerlink" title="第四步、快捷键："></a>第四步、快捷键：</h3><blockquote>
<ul>
<li><p>显示桌面：</p>
<blockquote>
<ul>
<li>F11</li>
<li>Command + F3</li>
<li>Trackpad 上 五指散开</li>
<li>如果有多个桌面，四指滑动到空白的桌面即可</li>
<li>配置触角：偏好设置——Mission Control——左下角触发角，就能设置鼠标移动到屏幕四个角触发的动作。</li>
</ul>
</blockquote>
</li>
<li><p>打开iFinder：shift+command+H</p>
</li>
<li><p>窗口相关：</p>
<blockquote>
<ol>
<li>关闭屏幕:Ctrl+Shift+Power</li>
<li>最小化窗口：command+M</li>
<li>窗口全屏：control+command+F</li>
<li>隐藏窗口：Command+H</li>
<li>窗口切换：Command+tab（app间）、command+~（同一app的不同窗口间）</li>
<li>开启新标签：command+T</li>
<li>开启新窗口：command+N</li>
<li>关闭当前标签：command+W</li>
<li>切换标签：control+tab</li>
<li>窗口关闭：command+W</li>
<li>退出：command+Q</li>
<li>强制退出程序：command+option+esc</li>
<li>全屏标识（绿色圆圈）：<blockquote>
<ul>
<li>按住 Option 全屏按钮就会变为 + ， 点就是垂直最大化；</li>
<li>按住 shift+Opt 全屏按钮也会变为 + ， 点击就是最大化，而不是全屏；</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
</li>
<li><p>编辑相关：</p>
<blockquote>
<ol>
<li>剪切：command+X</li>
<li>复制：command+C</li>
<li>粘贴：command+V</li>
<li>删除：command+delete</li>
<li>全选：command+A</li>
<li>撤销：command+Z</li>
<li>重做：command+Y</li>
<li>保存：command+S</li>
<li>打印：command+P</li>
<li>查找：command+F</li>
<li>网页刷新：command+R</li>
</ol>
</blockquote>
</li>
<li><p>QQ:</p>
<blockquote>
<ol>
<li>qq发送消息：return</li>
<li>qq查看消息：control+command+Z</li>
<li>qq会话切换：command+上下</li>
<li>截图：control+command+A</li>
</ol>
</blockquote>
</li>
<li><p>微信：control+command+W</p>
</li>
<li><p>企业微信查看消息：shift+command+W</p>
</li>
<li><p>网易云音乐:</p>
<blockquote>
<ol>
<li>上下曲：option+command+左右</li>
<li>调节音量：option+command+上下</li>
<li>播放/暂停：option+command+space</li>
</ol>
</blockquote>
</li>
<li><p>切换输入法：control+option+space、control+space</p>
</li>
<li>调节音量：功能键</li>
<li>调节屏幕亮度：功能键</li>
<li>睡眠 (sleep):Cmd+Opt+Power</li>
<li>注销：shift+command+Q</li>
<li><p>关机：control+power</p>
</li>
<li><p>idea快捷键：</p>
<blockquote>
<ol>
<li>格式化代码：command+option+L</li>
<li>注释：command+/</li>
<li>代码提醒（系统输入法切换快捷键更改，冲突了）：control+space、control+shift+space</li>
<li>生成代码：control+return</li>
<li>快速修复：option+return</li>
<li>导包：control+option+O</li>
<li>移动当前行：option+shift+上下方向键、command+shift+上下方向键</li>
<li>全屏：control+command+F</li>
<li>覆盖方法：control+O</li>
<li>实现方法：control+I</li>
<li>全部大写：command+shift+U</li>
<li>编译project：command+F9</li>
<li>运行：control+R</li>
<li>调试：control+D</li>
<li>包围代码：Option+Command+T</li>
<li>插入模板代码：command+J</li>
<li>command+option+左右方向键：查看代码的前后跳转，相当于win版的alt+左右方向键</li>
</ol>
</blockquote>
</li>
<li><p>chrome快捷键：</p>
<blockquote>
<ol>
<li>新窗口：command+N</li>
<li>新标签：command+T</li>
<li>标签间切换：control+tab</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<p>###第五、额外推荐</p>
<blockquote>
<ul>
<li>移动硬盘文件整理:</li>
</ul>
<ol>
<li>sd卡:京东有MacBook专用SD拓容卡，新版MacBook Pro已不支持，目前还在纠结</li>
<li>移动硬盘：需要分一个区格式化为HFS+专供TimeMachine电脑备份使用</li>
</ol>
</blockquote>
<p>###感谢</p>
<blockquote>
<ul>
<li><a href="http://blog.jobbole.com/104138/" target="_blank" rel="external">http://blog.jobbole.com/104138/</a></li>
<li><a href="http://www.macx.cn/thread-2078092-1-1.html" target="_blank" rel="external">http://www.macx.cn/thread-2078092-1-1.html</a></li>
<li><a href="http://www.apple.com/cn/support/macbasics/" target="_blank" rel="external">http://www.apple.com/cn/support/macbasics/</a></li>
<li><a href="https://support.apple.com/zh-cn/HT201236" target="_blank" rel="external">https://support.apple.com/zh-cn/HT201236</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/keymap-mac-introduce.html</a></li>
<li><a href="http://www.ifunmac.com/" target="_blank" rel="external">玩转苹果</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li>
<li>还有知乎上各种大神的教程和软件推荐，我遇到问题时搜到的各个博客，数量太多，没能及时记录，大家弄出来都是互相分享的嘛~~</li>
<li>然后就是感谢好多个给力的学弟分享的各种软件的破解教程，真的炒鸡给力！！！</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我这个不怕折腾星人入职一个多星期除了完成老大安排的任务外，其余时间都在没日没夜地折腾电脑，写这篇文章也算是对这次的折腾宣告结束，至少我觉得我与这台电脑的磨合期过了。。。可以愉快地用这台电脑学东西，做东西，不过这篇文章也算是一个笔记，比如快捷键，还没那么快完全记住。。。毕竟那
    
    </summary>
    
      <category term="个人心得" scheme="http://www.coselding.cn/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="macOS" scheme="http://www.coselding.cn/tags/macOS/"/>
    
      <category term="折腾" scheme="http://www.coselding.cn/tags/%E6%8A%98%E8%85%BE/"/>
    
      <category term="环境搭建" scheme="http://www.coselding.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
      <category term="mac实用插件" scheme="http://www.coselding.cn/tags/mac%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>校招之路</title>
    <link href="http://www.coselding.cn/2016/10/19/%E6%A0%A1%E6%8B%9B%E4%B9%8B%E8%B7%AF/"/>
    <id>http://www.coselding.cn/2016/10/19/校招之路/</id>
    <published>2016-10-18T23:14:38.000Z</published>
    <updated>2016-10-18T23:14:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行程经历："><a href="#行程经历：" class="headerlink" title="行程经历："></a>行程经历：</h1><blockquote>
<ul>
<li>华为实习生性格测试——一面——二面——面试通过（备胎）——no result</li>
<li>华为校招提前批一面——二面——三面主管谈心——offer</li>
<li>阿里内推电话一面挂</li>
<li>网易笔试——一面——二面——HR面，挂</li>
<li>微店内推电话一面——视频二面——HR面——Offer</li>
<li>百度内推一面——二面挂（C++岗位。。。）</li>
<li>58笔试——一面——二面——HR面——未知</li>
<li>360笔试——一面——二面——HR面——未知（大数据岗位）</li>
<li>小米笔试——一面——二面——三面——未知</li>
<li><p>之后又有四五个公司笔试过了，都拒了。</p>
</li>
<li><h3 id="在没得到允许的情况下，出于对各个公司的校招团队的尊重，我这里不专门贴题目，而且每个人遇到的题目也不见得一样，很多都是在当时的特定情况下面试官跟着你的表述追问的。"><a href="#在没得到允许的情况下，出于对各个公司的校招团队的尊重，我这里不专门贴题目，而且每个人遇到的题目也不见得一样，很多都是在当时的特定情况下面试官跟着你的表述追问的。" class="headerlink" title="在没得到允许的情况下，出于对各个公司的校招团队的尊重，我这里不专门贴题目，而且每个人遇到的题目也不见得一样，很多都是在当时的特定情况下面试官跟着你的表述追问的。"></a>在没得到允许的情况下，出于对各个公司的校招团队的尊重，我这里不专门贴题目，而且每个人遇到的题目也不见得一样，很多都是在当时的特定情况下面试官跟着你的表述追问的。</h3></li>
<li><h3 id="网上面经很多啊，大多都是针对某个公司的，然后列出一面二面三面HR面的问题列表啊，针对的点比较窄，我一向有自己的特点，列题目没意思啊，提取成知识点你自己去学吧，我能保证的是这些如果能好好掌握的话，可以很轻松应对大多数公司，其实你只要能坚持下去，校招拿到若干个offer来选择都不是问题的，好好加油"><a href="#网上面经很多啊，大多都是针对某个公司的，然后列出一面二面三面HR面的问题列表啊，针对的点比较窄，我一向有自己的特点，列题目没意思啊，提取成知识点你自己去学吧，我能保证的是这些如果能好好掌握的话，可以很轻松应对大多数公司，其实你只要能坚持下去，校招拿到若干个offer来选择都不是问题的，好好加油" class="headerlink" title="网上面经很多啊，大多都是针对某个公司的，然后列出一面二面三面HR面的问题列表啊，针对的点比较窄，我一向有自己的特点，列题目没意思啊，提取成知识点你自己去学吧，我能保证的是这些如果能好好掌握的话，可以很轻松应对大多数公司，其实你只要能坚持下去，校招拿到若干个offer来选择都不是问题的，好好加油~"></a>网上面经很多啊，大多都是针对某个公司的，然后列出一面二面三面HR面的问题列表啊，针对的点比较窄，我一向有自己的特点，列题目没意思啊，提取成知识点你自己去学吧，我能保证的是这些如果能好好掌握的话，可以很轻松应对大多数公司，其实你只要能坚持下去，校招拿到若干个offer来选择都不是问题的，好好加油~</h3></li>
</ul>
</blockquote>
<h1 id="感悟："><a href="#感悟：" class="headerlink" title="感悟："></a>感悟：</h1><blockquote>
<ul>
<li><p>谁有我这种心理承受能力。。。特别是前期，全部失败。。。几乎看不到希望的曙光，害的我都在我家找了一家小公司面试兜底。。。</p>
</li>
<li><p>后来想想，不就是笔试嘛，和初高中的考试差不多，开始拿起以前的学习方法准备，狂填简历啊，笔试挂了不要紧啊，记住自己不会的，下次会了就行，反正公司多，怕什么。</p>
</li>
<li><p>笔试面试有机缘性，有时候你遇到的题目和你不是对口的，这就是缘分问题了，面试还能跟面试官说我这方面不擅长，笔试只能认了。</p>
</li>
<li><p>面试的时候自己不会的就说不会啊，不懂装懂等会深入问你懵逼。</p>
</li>
<li><p>笔试面试其实是有一些常用题库的，因为公司也没那么多时间专门创造题，所以多刷刷题是有用的，最多会有些简单变体，但是本质不变。</p>
</li>
<li><p>每次的笔试面试过后，一定要及时总结自己的缺漏，把自己不擅长的补上，因为你下次遇到相同的题的几率很大。</p>
</li>
<li><p>笔试面试真的是一个很好的成长过程，我在这个过程中查缺补漏，把很多以前不注重的编程细节弄懂弄清楚，解答了很多以前不懂的疑问。从我四月份腾讯阿里实习生开始，就开始了我的查缺补漏的过程。因为那时的我以为自己差不多都会，没什么问题，但是给我的教训就是：自己的知识面和公司的笔试面试的知识面有可能不重合，这个时候意味着你会有很多东西就不会，所以就要有方向性地把一些重点知识点完全掌握，完全理清思路，比如所有的数据结构、计算机网络特别是TCP和HTTP、数据库事务和SQL、操作系统内存和进线程，可能你原来就都懂，但是你能在面试官面前有可能神经紧张的情况下完好地表达出来吗?提前做好准备吧，这样才能稳。</p>
</li>
<li><p>找工作是一个双向选择的过程，有可能你在某个公司表现很好拿到offer，但是在另一个公司就不是对口的，当然提前调查好公司的技术栈可以减少失败，像我这种海投作死方式纯粹是安全感不足导致，完全没必要这么做。</p>
</li>
<li><p>别把事情留到明天，有任何疑问第一时间马上解决，我的网易堆排序，百度快排，阿里红黑树，以及很多笔试都是拖延症导致的，而且这些东西我本来就预感会遇到，但是因为之前一直没遇到就怀着侥幸心理，拖延啊。。。自扇10巴掌。</p>
</li>
<li><p>在你有实力的情况下，还有一个很重要的东西：你要确保能在面试官面前（有些面试官会很冷淡给你施加压力），在各种极端条件下表现出最好的自己，因为就算你再优秀，在面试官面前没表现出来他也不知道啊。</p>
</li>
</ul>
</blockquote>
<h1 id="必会知识点："><a href="#必会知识点：" class="headerlink" title="必会知识点："></a>必会知识点：</h1><blockquote>
<ul>
<li>数据结构全部，别偷懒，红黑树了解</li>
<li>计算机网络：TCP和HTTP，TCP水很深（58就被问的招架不住）</li>
<li>数据库原理：范式、事务和隔离级别、SQL各种、SQL优化(mysql)</li>
<li>算法：快排、堆排序、归并排序等八大排序，回溯法，动态规划，分支限界，递归，分治，数组，链表，二叉树，字符串，栈，队列</li>
<li>操作系统：内存管理，进线程并发同步，IO等</li>
<li>Java：基础知识、反射、内省、动态代理、NIO、类加载器——原理和用处</li>
<li>常用API：手写代码用</li>
<li>Spring要会，Ioc和AOP，水很深，看源码</li>
<li>ORM：Mybatis源码够了，Hibernate再涉及点复杂的关系映射，entity的状态转换</li>
<li>JVM：Java内存模型、GC算法、class文件格式了解、Java锁、volatile、高并发优化</li>
<li>JDK源码：容器、并发包、常用类</li>
<li>linux常用命令(这东西看运气)</li>
<li>高并发：Java并发包、CAS原则、ConcurrentHashMap、CopyOnWriteArrayList、乐观锁、自旋锁、非阻塞编程等</li>
<li>Hadoop系列：主要用来学习体会分布式和高可用的思想</li>
<li>分布式和高可用架构：mysql读写分离和分库分表、动静分离、请求分流、前端缓存、后端缓存、分布式事务、负载均衡、如何实现高可用等等</li>
<li>redis、memcache、mongodb等NoSQL</li>
<li>超大规模数据量的一些算法设计：无非是Hash、分块、汇总、可以分布式设计、并行计算、集群运算、详见MapReduce思想，别怕，就是考考分布式的思路和任务划分，网上有题库</li>
</ul>
<p>再一些你自己技能相关的东西吧</p>
</blockquote>
<h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><blockquote>
<ul>
<li>STAR法则</li>
<li>####每个公司的简历最好不要都一样，看好对应公司的JD，将自己的简历中和JD关联大的进行排序靠前或者着重强调，无关东西能删则删</li>
<li>GPA要有，专业排名要有，毕业时间</li>
<li>求职意向明确</li>
<li>简要个人信息和详细的联系方式</li>
<li>技能掌握谦虚写</li>
<li>获奖经历真实填写</li>
<li>项目经历、博客、github都能加分</li>
</ul>
</blockquote>
<h1 id="性格测试、素质测评"><a href="#性格测试、素质测评" class="headerlink" title="性格测试、素质测评"></a>性格测试、素质测评</h1><blockquote>
<ul>
<li>前后可能有相同相似题，要前后一致</li>
<li>IQ题看发挥</li>
<li>行测题看发挥</li>
</ul>
</blockquote>
<h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><blockquote>
<p>好好准备计算机基础课程知识和数据结构、OJ刷题</p>
</blockquote>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><blockquote>
<ul>
<li>沉着冷静、不能怂</li>
<li>算法题冷静分析，问好具体情况</li>
<li>表达好，让面试官知道你懂</li>
<li>自己不会的就说不会，让面试官问别的</li>
<li>面试官对于你会的东西都要根据你的描述进行相应的追问，毕竟很多问题网上都有答案，而面试官的即时追问是未知的，从这点可以更好地确认你对该知识点的掌握程度。</li>
</ul>
<p>我遇到的面试官都还好，一看就是技术男，不会在技术以外的地方为难你。</p>
</blockquote>
<h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><blockquote>
<ul>
<li>谈人生啊，谈理想啊，谈薪资啊，只要你不是别有用心，这是最轻松的面试。</li>
</ul>
<p>HR都很nice，没机会会会传说中的阿里HR哈哈哈，不知道恐不恐怖 &gt;.&lt;</p>
</blockquote>
<h1 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h1><blockquote>
<ul>
<li>Java并发编程实战</li>
<li>Java编程思想</li>
<li>Effective Java</li>
<li>编程之美</li>
<li>剑指Offer</li>
<li>程序员面试金典</li>
<li>编程珠玑</li>
<li>深入浅出设计模式</li>
<li>Hadoop权威指南</li>
<li>高性能MySQL</li>
<li>深入理解Java虚拟机</li>
<li>大型网站技术架构：核心原理与案例分析</li>
<li>Spring源码深度解析</li>
</ul>
<p>水深的很，尽量看吧</p>
</blockquote>
<h1 id="辅助网站"><a href="#辅助网站" class="headerlink" title="辅助网站"></a>辅助网站</h1><blockquote>
<p><a href="http://www.acmcoder.com/" target="_blank" rel="external">赛码</a><br><a href="http://www.nowcoder.com/" target="_blank" rel="external">牛客网</a><br><a href="http://www.jianshu.com/" target="_blank" rel="external">简书</a><br><a href="http://ifeve.com/" target="_blank" rel="external">并发编程网</a><br><a href="https://segmentfault.com/" target="_blank" rel="external">segmentfault</a><br><a href="http://www.kuqin.com/" target="_blank" rel="external">酷勤网</a><br><a href="http://www.ibm.com/developerworks/cn/topics/" target="_blank" rel="external">IBM技术网站</a></p>
</blockquote>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<ul>
<li>千万准备充分啊，从我一开始的自以为是，慌张应对，结果结局惨重，到最后及时总结，稳扎稳打，面试时胸有成竹，甚至超常发挥最大的分界点就在于八月中旬网易失利之后到八月末我开始的对之前面试的总结和知识点的系统梳理，可以说那段时间总结出的文档奠定了我九月份开始的大规模校招从容应对的基础，从我360、58和小米的面试感受出来，面对面试题都能从容分析，笔试题也能有信心。</li>
<li>成功找到喜欢的东家，可以好好继续学喜欢的东西了，不用再为了工作到处奔波，随时担心面试电话和邮件了，哈哈哈，全世界又重新轻松起来了~</li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;行程经历：&quot;&gt;&lt;a href=&quot;#行程经历：&quot; class=&quot;headerlink&quot; title=&quot;行程经历：&quot;&gt;&lt;/a&gt;行程经历：&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;华为实习生性格测试——一面——二面——面试通过（备胎）——no result&lt;
    
    </summary>
    
      <category term="个人心得" scheme="http://www.coselding.cn/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    
      <category term="经验" scheme="http://www.coselding.cn/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="面试" scheme="http://www.coselding.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="校招" scheme="http://www.coselding.cn/tags/%E6%A0%A1%E6%8B%9B/"/>
    
  </entry>
  
</feed>
